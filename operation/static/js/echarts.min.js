!function (t, e) {
    "function" == typeof define && define.amd ? define([], e) : "object" == typeof module && module.exports ? module.exports = e() : t.echarts = e()
}(this, function () {
    var t, e;
    !function () {
        function i(t, e) {
            if (!e)return t;
            if (0 === t.indexOf(".")) {
                var i = e.split("/"), n = t.split("/"), r = i.length - 1, a = n.length, o = 0, s = 0;
                t:for (var l = 0; a > l; l++)switch (n[l]) {
                    case"..":
                        if (!(r > o))break t;
                        o++, s++;
                        break;
                    case".":
                        s++;
                        break;
                    default:
                        break t
                }
                return i.length = r - o, n = n.slice(s), i.concat(n).join("/")
            }
            return t
        }

        function n(t) {
            function e(e, o) {
                if ("string" == typeof e) {
                    var s = n[e];
                    return s || (s = a(i(e, t)), n[e] = s), s
                }
                e instanceof Array && (o = o || function () {
                    }, o.apply(this, r(e, o, t)))
            }

            var n = {};
            return e
        }

        function r(e, n, r) {
            for (var s = [], l = o[r], c = 0, u = Math.min(e.length, n.length); u > c; c++) {
                var h, d = i(e[c], r);
                switch (d) {
                    case"require":
                        h = l && l.require || t;
                        break;
                    case"exports":
                        h = l.exports;
                        break;
                    case"module":
                        h = l;
                        break;
                    default:
                        h = a(d)
                }
                s.push(h)
            }
            return s
        }

        function a(t) {
            var e = o[t];
            if (!e)throw new Error("No " + t);
            if (!e.defined) {
                var i = e.factory, n = i.apply(this, r(e.deps || [], i, t));
                "undefined" != typeof n && (e.exports = n), e.defined = 1
            }
            return e.exports
        }

        var o = {};
        e = function (t, e, i) {
            o[t] = {id: t, deps: e, factory: i, defined: 0, exports: {}, require: n(t)}
        }, t = n("")
    }();
    var i = "closePath", n = "lineTo", r = "bezierCurveTo", a = "buildPath", o = "beginPath", s = "__dirty", l = "rotate", c = "../../model/Component", u = "orient", h = "mousemove", d = "moveTo", f = "vertical", p = "../core/util", v = "undefined", g = "parallel", m = "lineWidth", y = "Circle", x = "indexOfName", _ = "draggable", w = "mainType", b = "normalizeToArray", M = "formatter", S = "splitNumber", A = "axisLabel", C = "axisTick", T = "axisLine", L = "zoomLimit", k = "reverse", D = "categories", I = "getGraph", P = "mergeDefaultAndTheme", z = "getAreaStyle", V = "points", R = "Polygon", O = "createSymbol", E = "../../util/symbol", B = "parentNode", N = "getShallow", G = "getVisual", Z = "offsetY", F = "offsetX", H = "getLayout", W = "enable", q = "invisible", U = "parent", j = "ecModel", X = "zrender/core/BoundingRect", Y = "polarIndex", K = "mapArray", J = "applyTransform", Q = "interval", $ = "setLayout", te = "dataToCoord", ee = "getOtherAxis", ie = "itemStyle.normal", ne = "eachItemGraphicEl", re = "../../model/Model", ae = "getLabel", oe = "getTicks", se = "ordinal", le = "coordDimToDataDim", ce = "cartesian2d", ue = "boundaryGap", he = "getAxis", de = "setExtent", fe = "inverse", pe = "getFormattedLabels", ve = "getComponent", ge = "../../CoordinateSystem", me = "../../util/layout", ye = "getRawValue", xe = "symbolSize", _e = "symbol", we = "getExtent", be = "category", Me = "getBaseAxis", Se = "dataToPoint", Ae = "horizontal", Ce = "layout", Te = "dimensions", Le = "<br />", ke = "addCommas", De = "encodeHTML", Ie = "../../util/format", Pe = "../../model/Series", ze = "linearMap", Ve = "setItemLayout", Re = "getDataExtent", Oe = "radius", Ee = "parsePercent", Be = "../../util/number", Ne = "stroke", Ge = "borderColor", Ze = "initProps", Fe = "clockwise", He = "setItemGraphicEl", We = "eachChild", qe = "execute", Ue = "getLineStyle", je = "label.emphasis", Xe = "label.normal", Ye = "rotation", Ke = "setHoverStyle", Je = "animation", Qe = "selected", $e = "hoverStyle", ti = "useStyle", ei = "updateProps", ii = "setShape", ni = "childAt", ri = "hostModel", ai = "getFormattedLabel", oi = "retrieve", si = "inside", li = "updateData", ci = "Polyline", ui = "Sector", hi = "animate", di = "startAngle", fi = "getItemLayout", pi = "getItemGraphicEl", vi = "../../util/graphic", gi = "normalize", mi = "contain", yi = "../util/number", xi = "getName", _i = "findComponents", wi = "setItemVisual", bi = "itemStyle.normal.color", Mi = "getItemVisual", Si = "getRawIndex", Ai = "getItemModel", Ci = "getRect", Ti = "emphasis", Li = "normal", ki = "defaultEmphasis", Di = "toFixed", Ii = "initData", Pi = "option", zi = "mergeOption", Vi = "superApply", Ri = "../../echarts", Oi = "../../data/helper/completeDimensions", Ei = "../../util/model", Bi = "../../data/List", Ni = "coordinateSystem", Gi = "concat", Zi = "getContext", Fi = "createElement", Hi = "opacity", Wi = "getItemStyle", qi = "setStyle", Ui = "position", ji = "center", Xi = "middle", Yi = "padding", Ki = "getLayoutRect", Ji = "getBoxLayoutParams", Qi = "getBoundingRect", $i = "getTextColor", tn = "getFont", en = "textAlign", nn = "textStyle", rn = "removeAll", an = "isString", on = "inherits", sn = "number", ln = "itemStyle", cn = "extendComponentView", un = "extendComponentModel", hn = "extendChartView", dn = "register", fn = "function", pn = "registerAction", vn = "indexOf", gn = "isArray", mn = "replace", yn = "traverse", xn = "zlevel", _n = "dataType", wn = "getDataParams", bn = "seriesIndex", Mn = "dataIndex", Sn = "target", An = "mouseout", Cn = "mouseover", Tn = "render", Ln = "splice", kn = "dispose", Dn = "series", In = "eachSeries", Pn = "trigger", zn = "length", Vn = "defaults", Rn = "dispatchAction", On = "extend", En = "remove", Bn = "isObject", Nn = "updateLayout", Gn = "update", Zn = "create", Fn = "height", Hn = "bottom", Wn = "ignore", qn = "eachComponent", Un = "stopAnimation", jn = "backgroundColor", Xn = "canvasSupported", Yn = "getHeight", Kn = "getWidth", Jn = "getModel", Qn = "_model", $n = "resize", tr = "canvas", er = "string", ir = "prototype", nr = "toLowerCase", rr = "transform", ar = "zrender/core/vector", or = "zrender/core/matrix", sr = "zrender/core/env", lr = "lineStyle", cr = "setVisual", ur = "getData", hr = "eachSeriesByType", dr = "circle", fr = "filter", pr = "../echarts", vr = "zrender/core/util", gr = "require";
    e("echarts/chart/pie", [gr, vr, pr, "./pie/PieSeries", "./pie/PieView", "../action/createDataSelectAction", "../visual/dataColor", "./pie/pieLayout", "../processor/dataFilter"], function (t) {
        var e = t(vr), i = t(pr);
        t("./pie/PieSeries"), t("./pie/PieView"), t("../action/createDataSelectAction")("pie", [{
            type: "pieToggleSelect",
            event: "pieselectchanged",
            method: "toggleSelected"
        }, {type: "pieSelect", event: "pieselected", method: "select"}, {
            type: "pieUnSelect",
            event: "pieunselected",
            method: "unSelect"
        }]), i.registerVisualCoding("chart", e.curry(t("../visual/dataColor"), "pie")), i.registerLayout(e.curry(t("./pie/pieLayout"), "pie")), i.registerProcessor(fr, e.curry(t("../processor/dataFilter"), "pie"))
    }), e("echarts/chart/candlestick", [gr, pr, "./candlestick/CandlestickSeries", "./candlestick/CandlestickView", "./candlestick/preprocessor", "./candlestick/candlestickVisual", "./candlestick/candlestickLayout"], function (t) {
        var e = t(pr);
        t("./candlestick/CandlestickSeries"), t("./candlestick/CandlestickView"), e.registerPreprocessor(t("./candlestick/preprocessor")), e.registerVisualCoding("chart", t("./candlestick/candlestickVisual")), e.registerLayout(t("./candlestick/candlestickLayout"))
    }), e("echarts/chart/scatter", [gr, vr, pr, "./scatter/ScatterSeries", "./scatter/ScatterView", "../visual/symbol", "../layout/points", "../component/grid"], function (t) {
        var e = t(vr), i = t(pr);
        t("./scatter/ScatterSeries"), t("./scatter/ScatterView"), i.registerVisualCoding("chart", e.curry(t("../visual/symbol"), "scatter", dr, null)), i.registerLayout(e.curry(t("../layout/points"), "scatter")), t("../component/grid")
    }), e("echarts/chart/bar", [gr, vr, "../coord/cartesian/Grid", "./bar/BarSeries", "./bar/BarView", "../layout/barGrid", pr, "../component/grid"], function (t) {
        var e = t(vr);
        t("../coord/cartesian/Grid"), t("./bar/BarSeries"), t("./bar/BarView");
        var i = t("../layout/barGrid"), n = t(pr);
        n.registerLayout(e.curry(i, "bar")), n.registerVisualCoding("chart", function (t) {
            t[hr]("bar", function (t) {
                var e = t[ur]();
                e[cr]("legendSymbol", "roundRect")
            })
        }), t("../component/grid")
    }), e("echarts/chart/heatmap", [gr, "./heatmap/HeatmapSeries", "./heatmap/HeatmapView"], function (t) {
        t("./heatmap/HeatmapSeries"), t("./heatmap/HeatmapView")
    }), e("echarts/chart/radar", [gr, vr, pr, "../component/radar", "./radar/RadarSeries", "./radar/RadarView", "../visual/dataColor", "../visual/symbol", "./radar/radarLayout", "../processor/dataFilter", "./radar/backwardCompat"], function (t) {
        var e = t(vr), i = t(pr);
        t("../component/radar"), t("./radar/RadarSeries"), t("./radar/RadarView"), i.registerVisualCoding("chart", e.curry(t("../visual/dataColor"), "radar")), i.registerVisualCoding("chart", e.curry(t("../visual/symbol"), "radar", dr, null)), i.registerLayout(t("./radar/radarLayout")), i.registerProcessor(fr, e.curry(t("../processor/dataFilter"), "radar")), i.registerPreprocessor(t("./radar/backwardCompat"))
    }), e("echarts/chart/treemap", [gr, pr, "./treemap/TreemapSeries", "./treemap/TreemapView", "./treemap/treemapAction", "./treemap/treemapVisual", "./treemap/treemapLayout"], function (t) {
        var e = t(pr);
        t("./treemap/TreemapSeries"), t("./treemap/TreemapView"), t("./treemap/treemapAction"), e.registerVisualCoding("chart", t("./treemap/treemapVisual")), e.registerLayout(t("./treemap/treemapLayout"))
    }), e("echarts/chart/lines", [gr, "./lines/LinesSeries", "./lines/LinesView", vr, pr, "./lines/linesLayout", "../visual/seriesColor"], function (t) {
        t("./lines/LinesSeries"), t("./lines/LinesView");
        var e = t(vr), i = t(pr);
        i.registerLayout(t("./lines/linesLayout")), i.registerVisualCoding("chart", e.curry(t("../visual/seriesColor"), "lines", lr))
    }), e("echarts/chart/graph", [gr, pr, vr, "./graph/GraphSeries", "./graph/GraphView", "./graph/roamAction", "./graph/categoryFilter", "../visual/symbol", "./graph/categoryVisual", "./graph/edgeVisual", "./graph/simpleLayout", "./graph/circularLayout", "./graph/forceLayout", "./graph/createView"], function (t) {
        var e = t(pr), i = t(vr);
        t("./graph/GraphSeries"), t("./graph/GraphView"), t("./graph/roamAction"), e.registerProcessor(fr, t("./graph/categoryFilter")), e.registerVisualCoding("chart", i.curry(t("../visual/symbol"), "graph", dr, null)), e.registerVisualCoding("chart", t("./graph/categoryVisual")), e.registerVisualCoding("chart", t("./graph/edgeVisual")), e.registerLayout(t("./graph/simpleLayout")), e.registerLayout(t("./graph/circularLayout")), e.registerLayout(t("./graph/forceLayout")), e.registerCoordinateSystem("graphView", {create: t("./graph/createView")})
    }), e("echarts/chart/gauge", [gr, "./gauge/GaugeSeries", "./gauge/GaugeView"], function (t) {
        t("./gauge/GaugeSeries"), t("./gauge/GaugeView")
    }), e("echarts/echarts", [gr, "./model/Global", "./ExtensionAPI", "./CoordinateSystem", "./model/OptionManager", "./model/Component", "./model/Series", "./view/Component", "./view/Chart", "./util/graphic", "zrender", vr, "zrender/tool/color", sr, "zrender/mixin/Eventful", "./loading/default", "./visual/seriesColor", "./preprocessor/backwardCompat", "./util/number", "./util/format", or, ar], function (t) {
        function e(t) {
            return function (e, i, n) {
                e = e && e[nr](), T[ir][t].call(this, e, i, n)
            }
        }

        function i() {
            T.call(this)
        }

        function n(t, e, n) {
            n = n || {}, typeof e === er && (e = Z[e]), e && L(N, function (t) {
                t(e)
            }), this.id, this.group, this._dom = t, this._zr = M.init(t, {
                renderer: n.renderer || tr,
                devicePixelRatio: n.devicePixelRatio
            }), this._theme = S.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._api = new v(this), this._coordSysMgr = new g, T.call(this), this._messageCenter = new i, this._initEvents(), this[$n] = S.bind(this[$n], this)
        }

        function r(t, e) {
            var i = this[Qn];
            i && i[qn]({mainType: "series", query: e}, function (n) {
                var r = this._chartsMap[n.__viewId];
                r && r.__alive && r[t](n, i, this._api, e)
            }, this)
        }

        function a(t, e, i) {
            var n = this._api;
            L(this._componentsViews, function (r) {
                var a = r.__model;
                r[t](a, e, n, i), d(a, r)
            }, this), e[In](function (r) {
                var a = this._chartsMap[r.__viewId];
                a[t](r, e, n, i), d(r, a)
            }, this)
        }

        function o(t, e) {
            for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, r = i ? this._componentsMap : this._chartsMap, a = this._zr, o = 0; o < n[zn]; o++)n[o].__alive = !1;
            e[i ? qn : In](function (t, o) {
                if (i) {
                    if (t === Dn)return
                } else o = t;
                var s = o.id + "_" + o.type, l = r[s];
                if (!l) {
                    var c = y.parseClassType(o.type), u = i ? _.getClass(c.main, c.sub) : w.getClass(c.sub);
                    if (!u)return;
                    l = new u, l.init(e, this._api), r[s] = l, n.push(l), a.add(l.group)
                }
                o.__viewId = s, l.__alive = !0, l.__id = s, l.__model = o
            }, this);
            for (var o = 0; o < n[zn];) {
                var s = n[o];
                s.__alive ? o++ : (a[En](s.group), s[kn](e, this._api), n[Ln](o, 1), delete r[s.__id])
            }
        }

        function s(t, e) {
            L(D, function (i) {
                L(B[i] || [], function (i) {
                    i(t, e)
                })
            })
        }

        function l(t) {
            var e = {};
            t[In](function (t) {
                var i = t.get("stack"), n = t[ur]();
                if (i && "list" === n.type) {
                    var r = e[i];
                    r && (n.stackedOn = r), e[i] = n
                }
            })
        }

        function c(t, e) {
            var i = this._api;
            L(E, function (n) {
                n(t, i, e)
            })
        }

        function u(t, e) {
            L(k, function (i) {
                L(G[i] || [], function (i) {
                    i(t, e)
                })
            })
        }

        function h(t, e) {
            var i = this._api;
            L(this._componentsViews, function (n) {
                var r = n.__model;
                n[Tn](r, t, i, e), d(r, n)
            }, this), L(this._chartsViews, function (t) {
                t.__alive = !1
            }, this), t[In](function (n) {
                var r = this._chartsMap[n.__viewId];
                r.__alive = !0, r[Tn](n, t, i, e), r.group.silent = !!n.get("silent"), d(n, r)
            }, this), L(this._chartsViews, function (e) {
                e.__alive || e[En](t, i)
            }, this)
        }

        function d(t, e) {
            var i = t.get("z"), n = t.get(xn);
            e.group[yn](function (t) {
                null != i && (t.z = i), null != n && (t[xn] = n)
            })
        }

        function f(t) {
            function e(t, e) {
                for (var i = 0; i < t[zn]; i++) {
                    var n = t[i];
                    n[a] = e
                }
            }

            var i = 0, n = 1, r = 2, a = "__connectUpdateStatus";
            S.each(O, function (o, s) {
                t._messageCenter.on(s, function (o) {
                    if (H[t.group] && t[a] !== i) {
                        var s = t.makeActionFromEvent(o), l = [];
                        for (var c in F) {
                            var u = F[c];
                            u !== t && u.group === t.group && l.push(u)
                        }
                        e(l, i), L(l, function (t) {
                            t[a] !== n && t[Rn](s)
                        }), e(l, r)
                    }
                })
            })
        }

        var p = t("./model/Global"), v = t("./ExtensionAPI"), g = t("./CoordinateSystem"), m = t("./model/OptionManager"), y = t("./model/Component"), x = t("./model/Series"), _ = t("./view/Component"), w = t("./view/Chart"), b = t("./util/graphic"), M = t("zrender"), S = t(vr), A = t("zrender/tool/color"), C = t(sr), T = t("zrender/mixin/Eventful"), L = S.each, k = ["echarts", "chart", "component"], D = [rr, fr, "statistic"];
        i[ir].on = e("on"), i[ir].off = e("off"), i[ir].one = e("one"), S.mixin(i, T);
        var I = n[ir];
        I.getDom = function () {
            return this._dom
        }, I.getZr = function () {
            return this._zr
        }, I.setOption = function (t, e, i) {
            (!this[Qn] || e) && (this[Qn] = new p(null, null, this._theme, new m(this._api))), this[Qn].setOption(t, N), P.prepareAndUpdate.call(this), !i && this._zr.refreshImmediately()
        }, I.setTheme = function () {
            console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
        }, I[Jn] = function () {
            return this[Qn]
        }, I.getOption = function () {
            return this[Qn].getOption()
        }, I[Kn] = function () {
            return this._zr[Kn]()
        }, I[Yn] = function () {
            return this._zr[Yn]()
        }, I.getRenderedCanvas = function (t) {
            if (C[Xn]) {
                t = t || {}, t.pixelRatio = t.pixelRatio || 1, t[jn] = t[jn] || this[Qn].get(jn);
                var e = this._zr, i = e.storage.getDisplayList();
                return S.each(i, function (t) {
                    t[Un](!0)
                }), e.painter.getRenderedCanvas(t)
            }
        }, I.getDataURL = function (t) {
            t = t || {};
            var e = t.excludeComponents, i = this[Qn], n = [], r = this;
            L(e, function (t) {
                i[qn]({mainType: t}, function (t) {
                    var e = r._componentsMap[t.__viewId];
                    e.group[Wn] || (n.push(e), e.group[Wn] = !0)
                })
            });
            var a = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
            return L(n, function (t) {
                t.group[Wn] = !1
            }), a
        }, I.getConnectedDataURL = function (t) {
            if (C[Xn]) {
                var e = this.group, i = Math.min, n = Math.max, r = 1 / 0;
                if (H[e]) {
                    var a = r, o = r, s = -r, l = -r, c = [], u = t && t.pixelRatio || 1;
                    for (var h in F) {
                        var d = F[h];
                        if (d.group === e) {
                            var f = d.getRenderedCanvas(S.clone(t)), p = d.getDom().getBoundingClientRect();
                            a = i(p.left, a), o = i(p.top, o), s = n(p.right, s), l = n(p[Hn], l), c.push({
                                dom: f,
                                left: p.left,
                                top: p.top
                            })
                        }
                    }
                    a *= u, o *= u, s *= u, l *= u;
                    var v = s - a, g = l - o, m = S.createCanvas();
                    m.width = v, m[Fn] = g;
                    var y = M.init(m);
                    return L(c, function (t) {
                        var e = new b.Image({style: {x: t.left * u - a, y: t.top * u - o, image: t.dom}});
                        y.add(e)
                    }), y.refreshImmediately(), m.toDataURL("image/" + (t && t.type || "png"))
                }
                return this.getDataURL(t)
            }
        };
        var P = {
            update: function (t) {
                var e = this[Qn], i = this._api, n = this._coordSysMgr;
                if (e) {
                    e.restoreData(), n[Zn](this[Qn], this._api), s.call(this, e, i), l.call(this, e), n[Gn](e, i), c.call(this, e, t), u.call(this, e, t), h.call(this, e, t);
                    var r = e.get(jn) || "transparent", a = this._zr.painter;
                    if (a.isSingleCanvas && a.isSingleCanvas())this._zr.configLayer(0, {clearColor: r}); else {
                        if (!C[Xn]) {
                            var o = A.parse(r);
                            r = A.stringify(o, "rgb"), 0 === o[3] && (r = "transparent")
                        }
                        r = r, this._dom.style[jn] = r
                    }
                }
            }, updateView: function (t) {
                var e = this[Qn];
                e && (c.call(this, e, t), u.call(this, e, t), a.call(this, "updateView", e, t))
            }, updateVisual: function (t) {
                var e = this[Qn];
                e && (u.call(this, e, t), a.call(this, "updateVisual", e, t))
            }, updateLayout: function (t) {
                var e = this[Qn];
                e && (c.call(this, e, t), a.call(this, Nn, e, t))
            }, highlight: function (t) {
                r.call(this, "highlight", t)
            }, downplay: function (t) {
                r.call(this, "downplay", t)
            }, prepareAndUpdate: function (t) {
                var e = this[Qn];
                o.call(this, "component", e), o.call(this, "chart", e), P[Gn].call(this, t)
            }
        };
        I[$n] = function () {
            this._zr[$n]();
            var t = this[Qn] && this[Qn].resetOption("media");
            P[t ? "prepareAndUpdate" : Gn].call(this), this._loadingFX && this._loadingFX[$n]()
        };
        var z = t("./loading/default");
        I.showLoading = function (t, e) {
            S[Bn](t) && (e = t, t = "default"), this.hideLoading();
            var i = z(this._api, e), n = this._zr;
            this._loadingFX = i, n.add(i)
        }, I.hideLoading = function () {
            this._loadingFX && this._zr[En](this._loadingFX), this._loadingFX = null
        }, I.makeActionFromEvent = function (t) {
            var e = S[On]({}, t);
            return e.type = O[t.type], e
        }, I[Rn] = function (t, e) {
            var i = R[t.type];
            if (i) {
                var n = i.actionInfo, r = n[Gn] || Gn, a = [t], o = !1;
                t.batch && (o = !0, a = S.map(t.batch, function (e) {
                    return e = S[Vn](S[On]({}, e), t), e.batch = null, e
                }));
                for (var s, l = [], c = "highlight" === t.type || "downplay" === t.type, u = 0; u < a[zn]; u++) {
                    var h = a[u];
                    s = i.action(h, this[Qn]), s = s || S[On]({}, h), s.type = n.event || s.type, l.push(s), c && P[r].call(this, h)
                }
                "none" !== r && !c && P[r].call(this, t), e || (s = o ? {
                    type: n.event || t.type,
                    batch: l
                } : l[0], this._messageCenter[Pn](s.type, s))
            }
        }, I.on = e("on"), I.off = e("off"), I.one = e("one");
        var V = ["click", "dblclick", Cn, An, "mousedown", "mouseup", "globalout"];
        I._initEvents = function () {
            L(V, function (t) {
                this._zr.on(t, function (e) {
                    var i = this[Jn](), n = e[Sn];
                    if (n && null != n[Mn]) {
                        var r = n.dataModel || i.getSeriesByIndex(n[bn]), a = r && r[wn](n[Mn], n[_n]) || {};
                        a.event = e, a.type = t, this[Pn](t, a)
                    } else n && n.eventData && this[Pn](t, n.eventData)
                }, this)
            }, this), L(O, function (t, e) {
                this._messageCenter.on(e, function (t) {
                    this[Pn](e, t)
                }, this)
            }, this)
        }, I.isDisposed = function () {
            return this._disposed
        }, I.clear = function () {
            this.setOption({}, !0)
        }, I[kn] = function () {
            this._disposed = !0;
            var t = this._api, e = this[Qn];
            L(this._componentsViews, function (i) {
                i[kn](e, t)
            }), L(this._chartsViews, function (i) {
                i[kn](e, t)
            }), this._zr[kn](), delete F[this.id]
        }, S.mixin(n, T);
        var R = [], O = {}, E = [], B = {}, N = [], G = {}, Z = {}, F = {}, H = {}, W = new Date - 0, q = new Date - 0, U = "_echarts_instance_", j = {
            version: "3.1.10",
            dependencies: {zrender: "3.1.0"}
        };
        return j.init = function (t, e, i) {
            if (M.version[mn](".", "") - 0 < j.dependencies.zrender[mn](".", "") - 0)throw new Error("ZRender " + M.version + " is too old for ECharts " + j.version + ". Current version need ZRender " + j.dependencies.zrender + "+");
            if (!t)throw new Error("Initialize failed: invalid dom.");
            var r = new n(t, e, i);
            return r.id = "ec_" + W++, F[r.id] = r, t.setAttribute && t.setAttribute(U, r.id), f(r), r
        }, j.connect = function (t) {
            if (S[gn](t)) {
                var e = t;
                t = null, S.each(e, function (e) {
                    null != e.group && (t = e.group)
                }), t = t || "g_" + q++, S.each(e, function (e) {
                    e.group = t
                })
            }
            return H[t] = !0, t
        }, j.disConnect = function (t) {
            H[t] = !1
        }, j[kn] = function (t) {
            S.isDom(t) ? t = j.getInstanceByDom(t) : typeof t === er && (t = F[t]), t instanceof n && !t.isDisposed() && t[kn]()
        }, j.getInstanceByDom = function (t) {
            var e = t.getAttribute(U);
            return F[e]
        }, j.getInstanceById = function (t) {
            return F[t]
        }, j.registerTheme = function (t, e) {
            Z[t] = e
        }, j.registerPreprocessor = function (t) {
            N.push(t)
        }, j.registerProcessor = function (t, e) {
            if (S[vn](D, t) < 0)throw new Error("stage should be one of " + D);
            var i = B[t] || (B[t] = []);
            i.push(e)
        }, j[pn] = function (t, e, i) {
            typeof e === fn && (i = e, e = "");
            var n = S[Bn](t) ? t.type : [t, t = {event: e}][0];
            t.event = (t.event || n)[nr](), e = t.event, R[n] || (R[n] = {action: i, actionInfo: t}), O[e] = n
        }, j.registerCoordinateSystem = function (t, e) {
            g[dn](t, e)
        }, j.registerLayout = function (t) {
            S[vn](E, t) < 0 && E.push(t)
        }, j.registerVisualCoding = function (t, e) {
            if (S[vn](k, t) < 0)throw new Error("stage should be one of " + k);
            var i = G[t] || (G[t] = []);
            i.push(e)
        }, j[hn] = function (t) {
            return w[On](t)
        }, j[un] = function (t) {
            return y[On](t)
        }, j.extendSeriesModel = function (t) {
            return x[On](t)
        }, j[cn] = function (t) {
            return _[On](t)
        }, j.setCanvasCreator = function (t) {
            S.createCanvas = t
        }, j.registerVisualCoding("echarts", S.curry(t("./visual/seriesColor"), "", ln)), j.registerPreprocessor(t("./preprocessor/backwardCompat")), j[pn]({
            type: "highlight",
            event: "highlight",
            update: "highlight"
        }, S.noop), j[pn]({
            type: "downplay",
            event: "downplay",
            update: "downplay"
        }, S.noop), j.graphic = t("./util/graphic"), j[sn] = t("./util/number"), j.format = t("./util/format"), j.matrix = t(or), j.vector = t(ar), j.util = {}, L(["map", "each", fr, vn, on, "reduce", fr, "bind", "curry", gn, an, Bn, "isFunction", On], function (t) {
            j.util[t] = S[t]
        }), j
    }), e("echarts/chart/line", [gr, vr, pr, "./line/LineSeries", "./line/LineView", "../visual/symbol", "../layout/points", "../processor/dataSample", "../component/grid"], function (t) {
        var e = t(vr), i = t(pr);
        t("./line/LineSeries"), t("./line/LineView"), i.registerVisualCoding("chart", e.curry(t("../visual/symbol"), "line", dr, "line")), i.registerLayout(e.curry(t("../layout/points"), "line")), i.registerProcessor("statistic", e.curry(t("../processor/dataSample"), "line")), t("../component/grid")
    }), e("echarts/chart/effectScatter", [gr, vr, pr, "./effectScatter/EffectScatterSeries", "./effectScatter/EffectScatterView", "../visual/symbol", "../layout/points"], function (t) {
        var e = t(vr), i = t(pr);
        t("./effectScatter/EffectScatterSeries"), t("./effectScatter/EffectScatterView"), i.registerVisualCoding("chart", e.curry(t("../visual/symbol"), "effectScatter", dr, null)), i.registerLayout(e.curry(t("../layout/points"), "effectScatter"))
    }), e("echarts/chart/map", [gr, pr, "./map/MapSeries", "./map/MapView", "../action/geoRoam", "../coord/geo/geoCreator", "./map/mapSymbolLayout", "./map/mapVisual", "./map/mapDataStatistic", "./map/backwardCompat", "../action/createDataSelectAction"], function (t) {
        var e = t(pr);
        t("./map/MapSeries"), t("./map/MapView"), t("../action/geoRoam"), t("../coord/geo/geoCreator"), e.registerLayout(t("./map/mapSymbolLayout")), e.registerVisualCoding("chart", t("./map/mapVisual")), e.registerProcessor("statistic", t("./map/mapDataStatistic")), e.registerPreprocessor(t("./map/backwardCompat")), t("../action/createDataSelectAction")("map", [{
            type: "mapToggleSelect",
            event: "mapselectchanged",
            method: "toggleSelected"
        }, {type: "mapSelect", event: "mapselected", method: "select"}, {
            type: "mapUnSelect",
            event: "mapunselected",
            method: "unSelect"
        }])
    }), e("echarts/chart/boxplot", [gr, pr, "./boxplot/BoxplotSeries", "./boxplot/BoxplotView", "./boxplot/boxplotVisual", "./boxplot/boxplotLayout"], function (t) {
        var e = t(pr);
        t("./boxplot/BoxplotSeries"), t("./boxplot/BoxplotView"), e.registerVisualCoding("chart", t("./boxplot/boxplotVisual")), e.registerLayout(t("./boxplot/boxplotLayout"))
    }), e("echarts/chart/parallel", [gr, pr, "../component/parallel", "./parallel/ParallelSeries", "./parallel/ParallelView", "./parallel/parallelVisual"], function (t) {
        var e = t(pr);
        t("../component/parallel"), t("./parallel/ParallelSeries"), t("./parallel/ParallelView"), e.registerVisualCoding("chart", t("./parallel/parallelVisual"))
    }), e("echarts/component/title", [gr, pr, "../util/graphic", "../util/layout"], function (t) {
        var e = t(pr), i = t("../util/graphic"), n = t("../util/layout");
        e[un]({
            type: "title",
            layoutMode: {type: "box", ignoreSize: !0},
            defaultOption: {
                zlevel: 0,
                z: 6,
                show: !0,
                text: "",
                target: "blank",
                subtext: "",
                subtarget: "blank",
                left: 0,
                top: 0,
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                textStyle: {fontSize: 18, fontWeight: "bolder", color: "#333"},
                subtextStyle: {color: "#aaa"}
            }
        }), e[cn]({
            type: "title", render: function (t, e, r) {
                if (this.group[rn](), t.get("show")) {
                    var a = this.group, o = t[Jn](nn), s = t[Jn]("subtextStyle"), l = t.get(en), c = new i.Text({
                        style: {
                            text: t.get("text"),
                            textFont: o[tn](),
                            fill: o[$i](),
                            textBaseline: "top"
                        }, z2: 10
                    }), u = c[Qi](), h = t.get("subtext"), d = new i.Text({
                        style: {
                            text: h,
                            textFont: s[tn](),
                            fill: s[$i](),
                            y: u[Fn] + t.get("itemGap"),
                            textBaseline: "top"
                        }, z2: 10
                    }), f = t.get("link"), p = t.get("sublink");
                    c.silent = !f, d.silent = !p, f && c.on("click", function () {
                        window.open(f, "_" + t.get(Sn))
                    }), p && d.on("click", function () {
                        window.open(p, "_" + t.get("subtarget"))
                    }), a.add(c), h && a.add(d);
                    var v = a[Qi](), g = t[Ji]();
                    g.width = v.width, g[Fn] = v[Fn];
                    var m = n[Ki](g, {width: r[Kn](), height: r[Yn]()}, t.get(Yi));
                    l || (l = t.get("left") || t.get("right"), l === Xi && (l = ji), "right" === l ? m.x += m.width : l === ji && (m.x += m.width / 2)), a[Ui] = [m.x, m.y], c[qi](en, l), d[qi](en, l), v = a[Qi]();
                    var y = m.margin, x = t[Wi](["color", Hi]);
                    x.fill = t.get(jn);
                    var _ = new i.Rect({
                        shape: {
                            x: v.x - y[3],
                            y: v.y - y[0],
                            width: v.width + y[1] + y[3],
                            height: v[Fn] + y[0] + y[2]
                        }, style: x, silent: !0
                    });
                    i.subPixelOptimizeRect(_), a.add(_)
                }
            }
        })
    }), e("echarts/component/polar", [gr, "../coord/polar/polarCreator", "./angleAxis", "./radiusAxis", pr], function (t) {
        t("../coord/polar/polarCreator"), t("./angleAxis"), t("./radiusAxis"), t(pr)[cn]({type: "polar"})
    }), e("echarts/component/tooltip", [gr, "./tooltip/TooltipModel", "./tooltip/TooltipView", pr], function (t) {
        t("./tooltip/TooltipModel"), t("./tooltip/TooltipView"), t(pr)[pn]({
            type: "showTip",
            event: "showTip",
            update: "none"
        }, function () {
        }), t(pr)[pn]({type: "hideTip", event: "hideTip", update: "none"}, function () {
        })
    }), e("echarts/chart/funnel", [gr, vr, pr, "./funnel/FunnelSeries", "./funnel/FunnelView", "../visual/dataColor", "./funnel/funnelLayout", "../processor/dataFilter"], function (t) {
        var e = t(vr), i = t(pr);
        t("./funnel/FunnelSeries"), t("./funnel/FunnelView"), i.registerVisualCoding("chart", e.curry(t("../visual/dataColor"), "funnel")), i.registerLayout(t("./funnel/funnelLayout")), i.registerProcessor(fr, e.curry(t("../processor/dataFilter"), "funnel"))
    }), e("echarts/component/markLine", [gr, "./marker/MarkLineModel", "./marker/MarkLineView", pr], function (t) {
        t("./marker/MarkLineModel"), t("./marker/MarkLineView"), t(pr).registerPreprocessor(function (t) {
            t.markLine = t.markLine || {}
        })
    }), e("echarts/component/markPoint", [gr, "./marker/MarkPointModel", "./marker/MarkPointView", pr], function (t) {
        t("./marker/MarkPointModel"), t("./marker/MarkPointView"), t(pr).registerPreprocessor(function (t) {
            t.markPoint = t.markPoint || {}
        })
    }), e("echarts/component/timeline", [gr, pr, "./timeline/preprocessor", "./timeline/typeDefaulter", "./timeline/timelineAction", "./timeline/SliderTimelineModel", "./timeline/SliderTimelineView"], function (t) {
        var e = t(pr);
        e.registerPreprocessor(t("./timeline/preprocessor")), t("./timeline/typeDefaulter"), t("./timeline/timelineAction"), t("./timeline/SliderTimelineModel"), t("./timeline/SliderTimelineView")
    }), e("echarts/component/dataZoom", [gr, "./dataZoom/typeDefaulter", "./dataZoom/DataZoomModel", "./dataZoom/DataZoomView", "./dataZoom/SliderZoomModel", "./dataZoom/SliderZoomView", "./dataZoom/InsideZoomModel", "./dataZoom/InsideZoomView", "./dataZoom/dataZoomProcessor", "./dataZoom/dataZoomAction"], function (t) {
        t("./dataZoom/typeDefaulter"), t("./dataZoom/DataZoomModel"), t("./dataZoom/DataZoomView"), t("./dataZoom/SliderZoomModel"), t("./dataZoom/SliderZoomView"), t("./dataZoom/InsideZoomModel"), t("./dataZoom/InsideZoomView"), t("./dataZoom/dataZoomProcessor"), t("./dataZoom/dataZoomAction")
    }), e("echarts/component/visualMap", [gr, "./visualMapContinuous", "./visualMapPiecewise"], function (t) {
        t("./visualMapContinuous"), t("./visualMapPiecewise")
    }), e("echarts/component/toolbox", [gr, "./toolbox/ToolboxModel", "./toolbox/ToolboxView", "./toolbox/feature/SaveAsImage", "./toolbox/feature/MagicType", "./toolbox/feature/DataView", "./toolbox/feature/DataZoom", "./toolbox/feature/Restore"], function (t) {
        t("./toolbox/ToolboxModel"), t("./toolbox/ToolboxView"), t("./toolbox/feature/SaveAsImage"), t("./toolbox/feature/MagicType"), t("./toolbox/feature/DataView"), t("./toolbox/feature/DataZoom"), t("./toolbox/feature/Restore")
    }), e("zrender/vml/vml", [gr, "./graphic", "../zrender", "./Painter"], function (t) {
        t("./graphic"), t("../zrender").registerPainter("vml", t("./Painter"))
    }), e("echarts/chart/sankey", [gr, pr, "./sankey/SankeySeries", "./sankey/SankeyView", "./sankey/sankeyLayout", "./sankey/sankeyVisual"], function (t) {
        var e = t(pr);
        t("./sankey/SankeySeries"), t("./sankey/SankeyView"), e.registerLayout(t("./sankey/sankeyLayout")), e.registerVisualCoding("chart", t("./sankey/sankeyVisual"))
    }), e(vr, [gr, "../graphic/Gradient"], function (t) {
        function e(t) {
            if ("object" == typeof t && null !== t) {
                var i = t;
                if (t instanceof Array) {
                    i = [];
                    for (var n = 0, r = t[zn]; r > n; n++)i[n] = e(t[n])
                } else if (!M(t) && !S(t)) {
                    i = {};
                    for (var a in t)t.hasOwnProperty(a) && (i[a] = e(t[a]))
                }
                return i
            }
            return t
        }

        function i(t, n, r) {
            if (!b(n) || !b(t))return r ? e(n) : t;
            for (var a in n)if (n.hasOwnProperty(a)) {
                var o = t[a], s = n[a];
                !b(s) || !b(o) || x(s) || x(o) || S(s) || S(o) || M(s) || M(o) ? !r && a in t || (t[a] = e(n[a], !0)) : i(o, s, r)
            }
            return t
        }

        function n(t, e) {
            for (var n = t[0], r = 1, a = t[zn]; a > r; r++)n = i(n, t[r], e);
            return n
        }

        function r(t, e) {
            for (var i in e)e.hasOwnProperty(i) && (t[i] = e[i]);
            return t
        }

        function a(t, e, i) {
            for (var n in e)e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
            return t
        }

        function o() {
            return document[Fi](tr)
        }

        function s() {
            return L || (L = B.createCanvas()[Zi]("2d")), L
        }

        function l(t, e) {
            if (t) {
                if (t[vn])return t[vn](e);
                for (var i = 0, n = t[zn]; n > i; i++)if (t[i] === e)return i
            }
            return -1
        }

        function c(t, e) {
            function i() {
            }

            var n = t[ir];
            i[ir] = e[ir], t[ir] = new i;
            for (var r in n)t[ir][r] = n[r];
            t[ir].constructor = t, t.superClass = e
        }

        function u(t, e, i) {
            t = ir in t ? t[ir] : t, e = ir in e ? e[ir] : e, a(t, e, i)
        }

        function h(t) {
            return t ? typeof t == er ? !1 : typeof t[zn] == sn : void 0
        }

        function d(t, e, i) {
            if (t && e)if (t.forEach && t.forEach === z)t.forEach(e, i); else if (t[zn] === +t[zn])for (var n = 0, r = t[zn]; r > n; n++)e.call(i, t[n], n, t); else for (var a in t)t.hasOwnProperty(a) && e.call(i, t[a], a, t)
        }

        function f(t, e, i) {
            if (t && e) {
                if (t.map && t.map === O)return t.map(e, i);
                for (var n = [], r = 0, a = t[zn]; a > r; r++)n.push(e.call(i, t[r], r, t));
                return n
            }
        }

        function p(t, e, i, n) {
            if (t && e) {
                if (t.reduce && t.reduce === E)return t.reduce(e, i, n);
                for (var r = 0, a = t[zn]; a > r; r++)i = e.call(n, i, t[r], r, t);
                return i
            }
        }

        function v(t, e, i) {
            if (t && e) {
                if (t[fr] && t[fr] === V)return t[fr](e, i);
                for (var n = [], r = 0, a = t[zn]; a > r; r++)e.call(i, t[r], r, t) && n.push(t[r]);
                return n
            }
        }

        function g(t, e, i) {
            if (t && e)for (var n = 0, r = t[zn]; r > n; n++)if (e.call(i, t[n], n, t))return t[n]
        }

        function m(t, e) {
            var i = R.call(arguments, 2);
            return function () {
                return t.apply(e, i[Gi](R.call(arguments)))
            }
        }

        function y(t) {
            var e = R.call(arguments, 1);
            return function () {
                return t.apply(this, e[Gi](R.call(arguments)))
            }
        }

        function x(t) {
            return "[object Array]" === I.call(t)
        }

        function _(t) {
            return typeof t === fn
        }

        function w(t) {
            return "[object String]" === I.call(t)
        }

        function b(t) {
            var e = typeof t;
            return e === fn || !!t && "object" == e
        }

        function M(t) {
            return !!D[I.call(t)] || t instanceof k
        }

        function S(t) {
            return t && 1 === t.nodeType && typeof t.nodeName == er
        }

        function A() {
            for (var t = 0, e = arguments[zn]; e > t; t++)if (null != arguments[t])return arguments[t]
        }

        function C() {
            return Function.call.apply(R, arguments)
        }

        function T(t, e) {
            if (!t)throw new Error(e)
        }

        var L, k = t("../graphic/Gradient"), D = {
            "[object Function]": 1,
            "[object RegExp]": 1,
            "[object Date]": 1,
            "[object Error]": 1,
            "[object CanvasGradient]": 1
        }, I = Object[ir].toString, P = Array[ir], z = P.forEach, V = P[fr], R = P.slice, O = P.map, E = P.reduce, B = {
            inherits: c,
            mixin: u,
            clone: e,
            merge: i,
            mergeAll: n,
            extend: r,
            defaults: a,
            getContext: s,
            createCanvas: o,
            indexOf: l,
            slice: C,
            find: g,
            isArrayLike: h,
            each: d,
            map: f,
            reduce: p,
            filter: v,
            bind: m,
            curry: y,
            isArray: x,
            isString: w,
            isObject: b,
            isFunction: _,
            isBuildInObject: M,
            isDom: S,
            retrieve: A,
            assert: T,
            noop: function () {
            }
        };
        return B
    }), e("echarts/component/geo", [gr, "../coord/geo/GeoModel", "../coord/geo/geoCreator", "./geo/GeoView", "../action/geoRoam", pr, vr], function (t) {
        function e(t, e) {
            e[Gn] = "updateView", i[pn](e, function (e, i) {
                var r = {};
                return i[qn]({mainType: "geo", query: e}, function (i) {
                    i[t](e.name);
                    var a = i[Ni];
                    n.each(a.regions, function (t) {
                        r[t.name] = i.isSelected(t.name) || !1
                    })
                }), {selected: r, name: e.name}
            })
        }

        t("../coord/geo/GeoModel"), t("../coord/geo/geoCreator"), t("./geo/GeoView"), t("../action/geoRoam");
        var i = t(pr), n = t(vr);
        e("toggleSelected", {type: "geoToggleSelect", event: "geoselectchanged"}), e("select", {
            type: "geoSelect",
            event: "geoselected"
        }), e("unSelect", {type: "geoUnSelect", event: "geounselected"})
    }), e("echarts/chart/pie/PieSeries", [gr, Bi, vr, Ei, Oi, "../../component/helper/selectableMixin", Ri], function (t) {
        var e = t(Bi), i = t(vr), n = t(Ei), r = t(Oi), a = t("../../component/helper/selectableMixin"), o = t(Ri).extendSeriesModel({
            type: "series.pie",
            init: function (t) {
                o[Vi](this, "init", arguments), this.legendDataProvider = function () {
                    return this._dataBeforeProcessed
                }, this.updateSelectedMap(t.data), this._defaultLabelLine(t)
            },
            mergeOption: function (t) {
                o.superCall(this, zi, t), this.updateSelectedMap(this[Pi].data)
            },
            getInitialData: function (t) {
                var i = r(["value"], t.data), n = new e(i, this);
                return n[Ii](t.data), n
            },
            getDataParams: function (t) {
                var e = this._data, i = o.superCall(this, wn, t), n = e.getSum("value");
                return i.percent = n ? +(e.get("value", t) / n * 100)[Di](2) : 0, i.$vars.push("percent"), i
            },
            _defaultLabelLine: function (t) {
                n[ki](t.labelLine, ["show"]);
                var e = t.labelLine[Li], i = t.labelLine[Ti];
                e.show = e.show && t.label[Li].show, i.show = i.show && t.label[Ti].show
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                center: ["50%", "50%"],
                radius: [0, "75%"],
                clockwise: !0,
                startAngle: 90,
                minAngle: 0,
                selectedOffset: 10,
                avoidLabelOverlap: !0,
                label: {normal: {rotate: !1, show: !0, position: "outer"}, emphasis: {}},
                labelLine: {
                    normal: {
                        show: !0,
                        length: 15,
                        length2: 15,
                        smooth: !1,
                        lineStyle: {width: 1, type: "solid"}
                    }
                },
                itemStyle: {
                    normal: {borderColor: "rgba(0,0,0,0)", borderWidth: 1},
                    emphasis: {borderColor: "rgba(0,0,0,0)", borderWidth: 1}
                },
                animationEasing: "cubicOut",
                data: []
            }
        });
        return i.mixin(o, a), o
    }), e("echarts/component/grid", [gr, "../util/graphic", vr, "../coord/cartesian/Grid", "./axis", pr], function (t) {
        var e = t("../util/graphic"), i = t(vr);
        t("../coord/cartesian/Grid"), t("./axis"), t(pr)[cn]({
            type: "grid", render: function (t) {
                this.group[rn](), t.get("show") && this.group.add(new e.Rect({
                    shape: t[Ni][Ci](),
                    style: i[Vn]({fill: t.get(jn)}, t[Wi]()),
                    silent: !0
                }))
            }
        })
    }), e("echarts/visual/dataColor", [gr], function () {
        return function (t, e) {
            var i = e.get("color"), n = 0;
            e.eachRawSeriesByType(t, function (t) {
                var r = t.get("color", !0), a = t.getRawData();
                if (!e.isSeriesFiltered(t)) {
                    var o = t[ur]();
                    o.each(function (t) {
                        var e = o[Ai](t), s = o[Si](t), l = o[Mi](t, "color", !0);
                        if (l)a[wi](s, "color", l); else {
                            var c = r ? r[s % r[zn]] : i[(s + n) % i[zn]], u = e.get(bi) || c;
                            a[wi](s, "color", u), o[wi](t, "color", u)
                        }
                    })
                }
                n += a.count()
            })
        }
    }), e("echarts/component/legend", [gr, "./legend/LegendModel", "./legend/legendAction", "./legend/LegendView", pr, "./legend/legendFilter"], function (t) {
        t("./legend/LegendModel"), t("./legend/legendAction"), t("./legend/LegendView");
        var e = t(pr);
        e.registerProcessor(fr, t("./legend/legendFilter"))
    }), e("echarts/processor/dataFilter", [], function () {
        return function (t, e) {
            var i = e[_i]({mainType: "legend"});
            i && i[zn] && e[hr](t, function (t) {
                var e = t[ur]();
                e.filterSelf(function (t) {
                    for (var n = e[xi](t), r = 0; r < i[zn]; r++)if (!i[r].isSelected(n))return !1;
                    return !0
                }, this)
            }, this)
        }
    }), e("echarts/scale/Time", [gr, vr, yi, "../util/format", "./Interval"], function (t) {
        var e = t(vr), i = t(yi), n = t("../util/format"), r = t("./Interval"), a = r[ir], o = Math.ceil, s = Math.floor, l = 1e3, c = 60 * l, u = 60 * c, h = 24 * u, d = function (t, e, i, n) {
            for (; n > i;) {
                var r = i + n >>> 1;
                t[r][2] < e ? i = r + 1 : n = r
            }
            return i
        }, f = r[On]({
            type: "time", getLabel: function (t) {
                var e = this._stepLvl, i = new Date(t);
                return n.formatTime(e[0], i)
            }, niceExtent: function (t, e, n) {
                var r = this._extent;
                if (r[0] === r[1] && (r[0] -= h, r[1] += h), r[1] === -1 / 0 && 1 / 0 === r[0]) {
                    var a = new Date;
                    r[1] = new Date(a.getFullYear(), a.getMonth(), a.getDate()), r[0] = r[1] - h
                }
                this.niceTicks(t);
                var l = this._interval;
                e || (r[0] = i.round(s(r[0] / l) * l)), n || (r[1] = i.round(o(r[1] / l) * l))
            }, niceTicks: function (t) {
                t = t || 10;
                var e = this._extent, n = e[1] - e[0], r = n / t, a = p[zn], l = d(p, r, 0, a), c = p[Math.min(l, a - 1)], u = c[2];
                if ("year" === c[0]) {
                    var h = n / u, f = i.nice(h / t, !0);
                    u *= f
                }
                var v = [o(e[0] / u) * u, s(e[1] / u) * u];
                this._stepLvl = c, this._interval = u, this._niceExtent = v
            }, parse: function (t) {
                return +i.parseDate(t)
            }
        });
        e.each([mi, gi], function (t) {
            f[ir][t] = function (e) {
                return a[t].call(this, this.parse(e))
            }
        });
        var p = [["hh:mm:ss", 1, l], ["hh:mm:ss", 5, 5 * l], ["hh:mm:ss", 10, 10 * l], ["hh:mm:ss", 15, 15 * l], ["hh:mm:ss", 30, 30 * l], ["hh:mm\nMM-dd", 1, c], ["hh:mm\nMM-dd", 5, 5 * c], ["hh:mm\nMM-dd", 10, 10 * c], ["hh:mm\nMM-dd", 15, 15 * c], ["hh:mm\nMM-dd", 30, 30 * c], ["hh:mm\nMM-dd", 1, u], ["hh:mm\nMM-dd", 2, 2 * u], ["hh:mm\nMM-dd", 6, 6 * u], ["hh:mm\nMM-dd", 12, 12 * u], ["MM-dd\nyyyy", 1, h], ["week", 7, 7 * h], ["month", 1, 31 * h], ["quarter", 3, 380 * h / 4], ["half-year", 6, 380 * h / 2], ["year", 1, 380 * h]];
        return f[Zn] = function () {
            return new f
        }, f
    }), e("echarts/chart/pie/PieView", [gr, vi, vr, "../../view/Chart"], function (t) {
        function e(t, e, n, r) {
            var a = e[ur](), o = this[Mn], s = a[xi](o), l = e.get("selectedOffset");
            r[Rn]({type: "pieToggleSelect", from: t, name: s, seriesId: e.id}), a.each(function (t) {
                i(a[pi](t), a[fi](t), e.isSelected(a[xi](t)), l, n)
            })
        }

        function i(t, e, i, n, r) {
            var a = (e[di] + e.endAngle) / 2, o = Math.cos(a), s = Math.sin(a), l = i ? n : 0, c = [o * l, s * l];
            r ? t[hi]().when(200, {position: c}).start("bounceOut") : t.attr(Ui, c)
        }

        function n(t, e) {
            function i() {
                o[Wn] = o.hoverIgnore, s[Wn] = s.hoverIgnore
            }

            function n() {
                o[Wn] = o.normalIgnore, s[Wn] = s.normalIgnore
            }

            a.Group.call(this);
            var r = new a[ui]({z2: 2}), o = new a[ci], s = new a.Text;
            this.add(r), this.add(o), this.add(s), this[li](t, e, !0), this.on(Ti, i).on(Li, n).on(Cn, i).on(An, n)
        }

        function r(t, e, i, n, r) {
            var a = n[Jn](nn), s = r === si || "inner" === r;
            return {
                fill: a[$i]() || (s ? "#fff" : t[Mi](e, "color")),
                opacity: t[Mi](e, Hi),
                textFont: a[tn](),
                text: o[oi](t[ri][ai](e, i), t[xi](e))
            }
        }

        var a = t(vi), o = t(vr), s = n[ir];
        s[li] = function (t, e, n) {
            function r() {
                l[Un](!0), l.animateTo({shape: {r: h.r + 10}}, 300, "elasticOut")
            }

            function s() {
                l[Un](!0), l.animateTo({shape: {r: h.r}}, 300, "elasticOut")
            }

            var l = this[ni](0), c = t[ri], u = t[Ai](e), h = t[fi](e), d = o[On]({}, h);
            d.label = null, n ? (l[ii](d), l.shape.endAngle = h[di], a[ei](l, {shape: {endAngle: h.endAngle}}, c, e)) : a[ei](l, {shape: d}, c, e);
            var f = u[Jn](ln), p = t[Mi](e, "color");
            l[ti](o[Vn]({fill: p}, f[Jn](Li)[Wi]())), l[$e] = f[Jn](Ti)[Wi](), i(this, t[fi](e), u.get(Qe), c.get("selectedOffset"), c.get(Je)), l.off(Cn).off(An).off(Ti).off(Li), u.get("hoverAnimation") && l.on(Cn, r).on(An, s).on(Ti, r).on(Li, s), this._updateLabel(t, e), a[Ke](this)
        }, s._updateLabel = function (t, e) {
            var i = this[ni](1), n = this[ni](2), o = t[ri], s = t[Ai](e), l = t[fi](e), c = l.label, u = t[Mi](e, "color");
            a[ei](i, {shape: {points: c.linePoints || [[c.x, c.y], [c.x, c.y], [c.x, c.y]]}}, o, e), a[ei](n, {
                style: {
                    x: c.x,
                    y: c.y
                }
            }, o, e), n.attr({
                style: {textVerticalAlign: c.verticalAlign, textAlign: c[en], textFont: c.font},
                rotation: c[Ye],
                origin: [c.x, c.y],
                z2: 10
            });
            var h = s[Jn](Xe), d = s[Jn](je), f = s[Jn]("labelLine.normal"), p = s[Jn]("labelLine.emphasis"), v = h.get(Ui) || d.get(Ui);
            n[qi](r(t, e, Li, h, v)), n[Wn] = n.normalIgnore = !h.get("show"), n.hoverIgnore = !d.get("show"), i[Wn] = i.normalIgnore = !f.get("show"), i.hoverIgnore = !p.get("show"), i[qi]({
                stroke: u,
                opacity: t[Mi](e, Hi)
            }), i[qi](f[Jn](lr)[Ue]()), n[$e] = r(t, e, Ti, d, v), i[$e] = p[Jn](lr)[Ue]();
            var g = f.get("smooth");
            g && g === !0 && (g = .4), i[ii]({smooth: g})
        }, o[on](n, a.Group);
        var l = t("../../view/Chart")[On]({
            type: "pie", init: function () {
                var t = new a.Group;
                this._sectorGroup = t
            }, render: function (t, i, r, a) {
                if (!a || a.from !== this.uid) {
                    var s = t[ur](), l = this._data, c = this.group, u = i.get(Je), h = !l, d = o.curry(e, this.uid, t, u, r), f = t.get("selectedMode");
                    if (s.diff(l).add(function (t) {
                            var e = new n(s, t);
                            h && e[We](function (t) {
                                t[Un](!0)
                            }), f && e.on("click", d), s[He](t, e), c.add(e)
                        })[Gn](function (t, e) {
                            var i = l[pi](e);
                            i[li](s, t), i.off("click"), f && i.on("click", d), c.add(i), s[He](t, i)
                        })[En](function (t) {
                            var e = l[pi](t);
                            c[En](e)
                        })[qe](), u && h && s.count() > 0) {
                        var p = s[fi](0), v = Math.max(r[Kn](), r[Yn]()) / 2, g = o.bind(c.removeClipPath, c);
                        c.setClipPath(this._createClipPath(p.cx, p.cy, v, p[di], p[Fe], g, t))
                    }
                    this._data = s
                }
            }, _createClipPath: function (t, e, i, n, r, o, s) {
                var l = new a[ui]({shape: {cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: r}});
                return a[Ze](l, {shape: {endAngle: n + (r ? 1 : -1) * Math.PI * 2}}, s, o), l
            }
        });
        return l
    }), e("echarts/action/createDataSelectAction", [gr, pr, vr], function (t) {
        var e = t(pr), i = t(vr);
        return function (t, n) {
            i.each(n, function (i) {
                i[Gn] = "updateView", e[pn](i, function (e, n) {
                    var r = {};
                    return n[qn]({mainType: "series", subType: t, query: e}, function (t) {
                        t[i.method] && t[i.method](e.name);
                        var n = t[ur]();
                        n.each(function (e) {
                            var i = n[xi](e);
                            r[i] = t.isSelected(i) || !1
                        })
                    }), {name: e.name, selected: r}
                })
            })
        }
    }), e("echarts/chart/candlestick/CandlestickView", [gr, vr, "../../view/Chart", vi, "../helper/whiskerBoxCommon"], function (t) {
        function e(t, e, i) {
            var n = e[Ai](i), a = n[Jn](s), o = e[Mi](i, "color"), c = e[Mi](i, Ge), u = a[Wi](["color", "color0", Ge, "borderColor0"]), h = t[ni](t.whiskerIndex);
            h[ti](u), h.style[Ne] = c;
            var d = t[ni](t.bodyIndex);
            d[ti](u), d.style.fill = o, d.style[Ne] = c;
            var f = n[Jn](l)[Wi]();
            r[Ke](t, f)
        }

        var i = t(vr), n = t("../../view/Chart"), r = t(vi), a = t("../helper/whiskerBoxCommon"), o = n[On]({
            type: "candlestick",
            getStyleUpdater: function () {
                return e
            }
        });
        i.mixin(o, a.viewMixin, !0);
        var s = [ln, Li], l = [ln, Ti];
        return o
    }), e("echarts/chart/pie/pieLayout", [gr, Be, "./labelLayout", vr], function (t) {
        var e = t(Be), i = e[Ee], n = t("./labelLayout"), r = t(vr), a = 2 * Math.PI, o = Math.PI / 180;
        return function (t, s, l) {
            s[hr](t, function (t) {
                var s = t.get(ji), c = t.get(Oe);
                r[gn](c) || (c = [0, c]), r[gn](s) || (s = [s, s]);
                var u = l[Kn](), h = l[Yn](), d = Math.min(u, h), f = i(s[0], u), p = i(s[1], h), v = i(c[0], d / 2), g = i(c[1], d / 2), m = t[ur](), y = -t.get(di) * o, x = t.get("minAngle") * o, _ = m.getSum("value"), w = Math.PI / (_ || m.count()) * 2, b = t.get(Fe), M = t.get("roseType"), S = m[Re]("value");
                S[0] = 0;
                var A = a, C = 0, T = y, L = b ? 1 : -1;
                if (m.each("value", function (t, i) {
                        var n;
                        n = "area" !== M ? 0 === _ ? w : t * w : a / (m.count() || 1), x > n ? (n = x, A -= x) : C += t;
                        var r = T + L * n;
                        m[Ve](i, {
                            angle: n,
                            startAngle: T,
                            endAngle: r,
                            clockwise: b,
                            cx: f,
                            cy: p,
                            r0: v,
                            r: M ? e[ze](t, S, [v, g]) : g
                        }), T = r
                    }, !0), a > A)if (.001 >= A) {
                    var k = a / m.count();
                    m.each(function (t) {
                        var e = m[fi](t);
                        e[di] = y + L * t * k, e.endAngle = y + L * (t + 1) * k
                    })
                } else w = A / C, T = y, m.each("value", function (t, e) {
                    var i = m[fi](e), n = i.angle === x ? x : t * w;
                    i[di] = T, i.endAngle = T + L * n, T += n
                });
                n(t, g, u, h)
            })
        }
    }), e("echarts/chart/candlestick/CandlestickSeries", [gr, vr, Pe, "../helper/whiskerBoxCommon", Ie], function (t) {
        var e = t(vr), i = t(Pe), n = t("../helper/whiskerBoxCommon"), r = t(Ie), a = r[De], o = r[ke], s = i[On]({
            type: "series.candlestick",
            dependencies: ["xAxis", "yAxis", "grid"],
            valueDimensions: ["open", "close", "lowest", "highest"],
            dimensions: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                layout: null,
                itemStyle: {
                    normal: {
                        color: "#c23531",
                        color0: "#314656",
                        borderWidth: 1,
                        borderColor: "#c23531",
                        borderColor0: "#314656"
                    }, emphasis: {borderWidth: 2}
                },
                animationUpdate: !1,
                animationEasing: "linear",
                animationDuration: 300
            },
            getShadowDim: function () {
                return "open"
            },
            formatTooltip: function (t) {
                var i = e.map(this.valueDimensions, function (e) {
                    return e + ": " + o(this._data.get(e, t))
                }, this);
                return a(this.name) + Le + i.join(Le)
            }
        });
        return e.mixin(s, n.seriesModelMixin, !0), s
    }), e("echarts/chart/candlestick/candlestickLayout", [gr], function () {
        function t(t, r) {
            var a, o = t[Me](), s = o.type === be ? o.getBandWidth() : (a = o[we](), Math.abs(a[1] - a[0]) / r.count());
            return s / 2 - 2 > i ? s / 2 - 2 : s - i > n ? i : Math.max(s - n, e)
        }

        var e = 2, i = 5, n = 4;
        return function (e) {
            e[hr]("candlestick", function (e) {
                var i = e[Ni], n = e[ur](), r = e[Te], a = e.get(Ce), o = t(e, n);
                n.each(r, function () {
                    function t(t) {
                        var e = [];
                        return e[h] = c, e[d] = t, isNaN(c) || isNaN(t) ? [0 / 0, 0 / 0] : i[Se](e)
                    }

                    function e(t, e) {
                        var i = t.slice(), n = t.slice();
                        i[h] += o / 2, n[h] -= o / 2, e ? S.push(i, n) : S.push(n, i)
                    }

                    var s = arguments, l = r[zn], c = s[0], u = s[l], h = a === Ae ? 0 : 1, d = 1 - h, f = s[1], p = s[2], v = s[3], g = s[4], m = Math.min(f, p), y = Math.max(f, p), x = t(m), _ = t(y), w = t(v), b = t(g), M = [[b, _], [w, x]], S = [];
                    e(_, 0), e(x, 1), n[Ve](u, {
                        chartLayout: a,
                        sign: f > p ? -1 : p > f ? 1 : 0,
                        initBaseline: f > p ? _[d] : x[d],
                        bodyEnds: S,
                        whiskerEnds: M
                    })
                }, !0)
            })
        }
    }), e("echarts/chart/scatter/ScatterSeries", [gr, "../helper/createListFromArray", Pe], function (t) {
        var e = t("../helper/createListFromArray"), i = t(Pe);
        return i[On]({
            type: "series.scatter",
            dependencies: ["grid", "polar"],
            getInitialData: function (t, i) {
                var n = e(t.data, this, i);
                return n
            },
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                polarIndex: 0,
                geoIndex: 0,
                symbolSize: 10,
                large: !1,
                largeThreshold: 2e3,
                itemStyle: {normal: {opacity: .8}}
            }
        })
    }), e("echarts/chart/scatter/ScatterView", [gr, "../helper/SymbolDraw", "../helper/LargeSymbolDraw", Ri], function (t) {
        var e = t("../helper/SymbolDraw"), i = t("../helper/LargeSymbolDraw");
        t(Ri)[hn]({
            type: "scatter", init: function () {
                this._normalSymbolDraw = new e, this._largeSymbolDraw = new i
            }, render: function (t) {
                var e = t[ur](), i = this._largeSymbolDraw, n = this._normalSymbolDraw, r = this.group, a = t.get("large") && e.count() > t.get("largeThreshold") ? i : n;
                this._symbolDraw = a, a[li](e), r.add(a.group), r[En](a === i ? n.group : i.group)
            }, updateLayout: function (t) {
                this._symbolDraw[Nn](t)
            }, remove: function (t, e) {
                this._symbolDraw && this._symbolDraw[En](e, !0)
            }
        })
    }), e("echarts/visual/symbol", [gr], function () {
        return function (t, e, i, n) {
            n.eachRawSeriesByType(t, function (t) {
                var r = t[ur](), a = t.get(_e) || e, o = t.get(xe);
                r[cr]({
                    legendSymbol: i || a,
                    symbol: a,
                    symbolSize: o
                }), n.isSeriesFiltered(t) || (typeof o === fn && r.each(function (e) {
                    var i = t[ye](e), n = t[wn](e);
                    r[wi](e, xe, o(i, n))
                }), r.each(function (t) {
                    var e = r[Ai](t), i = e.get(_e, !0), n = e.get(xe, !0);
                    null != i && r[wi](t, _e, i), null != n && r[wi](t, xe, n)
                }))
            })
        }
    }), e("echarts/coord/cartesian/Grid", [gr, "exports", me, "../../coord/axisHelper", vr, "./Cartesian2D", "./Axis2D", "./GridModel", ge], function (t) {
        function e(t, e, i) {
            return i[ve]("grid", t.get("gridIndex")) === e
        }

        function i(t) {
            var e, i = t.model, n = i[pe](), r = 1, a = n[zn];
            a > 40 && (r = Math.ceil(a / 40));
            for (var o = 0; a > o; o += r)if (!t.isLabelIgnored(o)) {
                var s = i.getTextRect(n[o]);
                e ? e.union(s) : e = s
            }
            return e
        }

        function n(t, e, i) {
            this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this[Qn] = t
        }

        function r(t, e) {
            var i = t[we](), n = i[0] + i[1];
            t.toGlobalCoord = "x" === t.dim ? function (t) {
                return t + e
            } : function (t) {
                return n - t + e
            }, t.toLocalCoord = "x" === t.dim ? function (t) {
                return t - e
            } : function (t) {
                return n - t + e
            }
        }

        var a = t(me), o = t("../../coord/axisHelper"), s = t(vr), l = t("./Cartesian2D"), c = t("./Axis2D"), u = s.each, h = o.ifAxisCrossZero, d = o.niceScaleExtent;
        t("./GridModel");
        var f = n[ir];
        return f.type = "grid", f[Ci] = function () {
            return this._rect
        }, f[Gn] = function (t, e) {
            function i(t) {
                var e = n[t];
                for (var i in e) {
                    var r = e[i];
                    if (r && (r.type === be || !h(r)))return !0
                }
                return !1
            }

            var n = this._axesMap;
            this._updateScale(t, this[Qn]), u(n.x, function (t) {
                d(t, t.model)
            }), u(n.y, function (t) {
                d(t, t.model)
            }), u(n.x, function (t) {
                i("y") && (t.onZero = !1)
            }), u(n.y, function (t) {
                i("x") && (t.onZero = !1)
            }), this[$n](this[Qn], e)
        }, f[$n] = function (t, e) {
            function n() {
                u(s, function (t) {
                    var e = t.isHorizontal(), i = e ? [0, o.width] : [0, o[Fn]], n = t[fe] ? 1 : 0;
                    t[de](i[n], i[1 - n]), r(t, e ? o.x : o.y)
                })
            }

            var o = a[Ki](t[Ji](), {width: e[Kn](), height: e[Yn]()});
            this._rect = o;
            var s = this._axesList;
            n(), t.get("containLabel") && (u(s, function (t) {
                if (!t.model.get("axisLabel.inside")) {
                    var e = i(t);
                    if (e) {
                        var n = t.isHorizontal() ? Fn : "width", r = t.model.get("axisLabel.margin");
                        o[n] -= e[n] + r, "top" === t[Ui] ? o.y += e[Fn] + r : "left" === t[Ui] && (o.x += e.width + r)
                    }
                }
            }), n())
        }, f[he] = function (t, e) {
            var i = this._axesMap[t];
            if (null != i) {
                if (null == e)for (var n in i)return i[n];
                return i[e]
            }
        }, f.getCartesian = function (t, e) {
            var i = "x" + t + "y" + e;
            return this._coordsMap[i]
        }, f._initCartesian = function (t, i) {
            function n(n) {
                return function (l, u) {
                    if (e(l, t, i)) {
                        var h = l.get(Ui);
                        "x" === n ? ("top" !== h && h !== Hn && (h = Hn), r[h] && (h = "top" === h ? Hn : "top")) : ("left" !== h && "right" !== h && (h = "left"), r[h] && (h = "left" === h ? "right" : "left")), r[h] = !0;
                        var d = new c(n, o.createScaleByModel(l), [0, 0], l.get("type"), h), f = d.type === be;
                        d.onBand = f && l.get(ue), d[fe] = l.get(fe), d.onZero = l.get("axisLine.onZero"), l.axis = d, d.model = l, d.index = u, this._axesList.push(d), a[n][u] = d, s[n]++
                    }
                }
            }

            var r = {left: !1, right: !1, top: !1, bottom: !1}, a = {x: {}, y: {}}, s = {x: 0, y: 0};
            return i[qn]("xAxis", n("x"), this), i[qn]("yAxis", n("y"), this), s.x && s.y ? (this._axesMap = a, void u(a.x, function (t, e) {
                u(a.y, function (i, n) {
                    var r = "x" + e + "y" + n, a = new l(r);
                    a.grid = this, this._coordsMap[r] = a, this._coordsList.push(a), a.addAxis(t), a.addAxis(i)
                }, this)
            }, this)) : (this._axesMap = {}, void(this._axesList = []))
        }, f._updateScale = function (t, i) {
            function n(t, e, i) {
                u(i[le](e.dim), function (i) {
                    e.scale.unionExtent(t[Re](i, e.scale.type !== se))
                })
            }

            s.each(this._axesList, function (t) {
                t.scale[de](1 / 0, -1 / 0)
            }), t[In](function (r) {
                if (r.get(Ni) === ce) {
                    var a = r.get("xAxisIndex"), o = r.get("yAxisIndex"), s = t[ve]("xAxis", a), l = t[ve]("yAxis", o);
                    if (!e(s, i, t) || !e(l, i, t))return;
                    var c = this.getCartesian(a, o), u = r[ur](), h = c[he]("x"), d = c[he]("y");
                    "list" === u.type && (n(u, h, r), n(u, d, r))
                }
            }, this)
        }, n[Zn] = function (t, e) {
            var i = [];
            return t[qn]("grid", function (r, a) {
                var o = new n(r, t, e);
                o.name = "grid_" + a, o[$n](r, e), r[Ni] = o, i.push(o)
            }), t[In](function (e) {
                if (e.get(Ni) === ce) {
                    var n = e.get("xAxisIndex"), r = t[ve]("xAxis", n), a = i[r.get("gridIndex")];
                    e[Ni] = a.getCartesian(n, e.get("yAxisIndex"))
                }
            }), i
        }, n[Te] = l[ir][Te], t(ge)[dn](ce, n), n
    }), e("echarts/scale/Log", [gr, vr, "./Scale", yi, "./Interval"], function (t) {
        var e = t(vr), i = t("./Scale"), n = t(yi), r = t("./Interval"), a = i[ir], o = r[ir], s = Math.floor, l = Math.ceil, c = Math.pow, u = 10, h = Math.log, d = i[On]({
            type: "log",
            getTicks: function () {
                return e.map(o[oe].call(this), function (t) {
                    return n.round(c(u, t))
                })
            },
            getLabel: o[ae],
            scale: function (t) {
                return t = a.scale.call(this, t), c(u, t)
            },
            setExtent: function (t, e) {
                t = h(t) / h(u), e = h(e) / h(u), o[de].call(this, t, e)
            },
            getExtent: function () {
                var t = a[we].call(this);
                return t[0] = c(u, t[0]), t[1] = c(u, t[1]), t
            },
            unionExtent: function (t) {
                t[0] = h(t[0]) / h(u), t[1] = h(t[1]) / h(u), a.unionExtent.call(this, t)
            },
            niceTicks: function (t) {
                t = t || 10;
                var e = this._extent, i = e[1] - e[0];
                if (!(1 / 0 === i || 0 >= i)) {
                    var r = c(10, s(h(i / t) / Math.LN10)), a = t / i * r;
                    .5 >= a && (r *= 10);
                    var o = [n.round(l(e[0] / r) * r), n.round(s(e[1] / r) * r)];
                    this._interval = r, this._niceExtent = o
                }
            },
            niceExtent: o.niceExtent
        });
        return e.each([mi, gi], function (t) {
            d[ir][t] = function (e) {
                return e = h(e) / h(u), a[t].call(this, e)
            }
        }), d[Zn] = function () {
            return new d
        }, d
    }), e("echarts/chart/bar/BarView", [gr, vr, vi, re, "./barItemStyle", Ri], function (t) {
        function e(t, e) {
            var i = t.width > 0 ? 1 : -1, n = t[Fn] > 0 ? 1 : -1;
            e = Math.min(e, Math.abs(t.width), Math.abs(t[Fn])), t.x += i * e / 2, t.y += n * e / 2, t.width -= i * e, t[Fn] -= n * e
        }

        var i = t(vr), n = t(vi);
        return i[On](t(re)[ir], t("./barItemStyle")), t(Ri)[hn]({
            type: "bar", render: function (t, e, i) {
                var n = t.get(Ni);
                return n === ce && this._renderOnCartesian(t, e, i), this.group
            }, _renderOnCartesian: function (t) {
                function r(r, a) {
                    var s = o[fi](r), l = o[Ai](r).get(d) || 0;
                    e(s, l);
                    var c = new n.Rect({shape: i[On]({}, s)});
                    if (h) {
                        var f = c.shape, p = u ? Fn : "width", v = {};
                        f[p] = 0, v[p] = s[p], n[a ? ei : Ze](c, {shape: v}, t, r)
                    }
                    return c
                }

                var a = this.group, o = t[ur](), s = this._data, l = t[Ni], c = l[Me](), u = c.isHorizontal(), h = t.get(Je), d = [ln, Li, "barBorderWidth"];
                o.diff(s).add(function (t) {
                    if (o.hasValue(t)) {
                        var e = r(t);
                        o[He](t, e), a.add(e)
                    }
                })[Gn](function (i, l) {
                    var c = s[pi](l);
                    if (!o.hasValue(i))return void a[En](c);
                    c || (c = r(i, !0));
                    var u = o[fi](i), h = o[Ai](i).get(d) || 0;
                    e(u, h), n[ei](c, {shape: u}, t, i), o[He](i, c), a.add(c)
                })[En](function (e) {
                    var i = s[pi](e);
                    i && (i.style.text = "", n[ei](i, {shape: {width: 0}}, t, e, function () {
                        a[En](i)
                    }))
                })[qe](), this._updateStyle(t, o, u), this._data = o
            }, _updateStyle: function (t, e, r) {
                function a(t, e, i, r, a) {
                    n.setText(t, e, i), t.text = r, "outside" === t.textPosition && (t.textPosition = a)
                }

                e[ne](function (o, s) {
                    var l = e[Ai](s), c = e[Mi](s, "color"), u = e[Mi](s, Hi), h = e[fi](s), d = l[Jn](ie), f = l[Jn]("itemStyle.emphasis").getBarItemStyle();
                    o[ii]("r", d.get("barBorderRadius") || 0), o[ti](i[Vn]({fill: c, opacity: u}, d.getBarItemStyle()));
                    var p = r ? h[Fn] > 0 ? Hn : "top" : h.width > 0 ? "left" : "right", v = l[Jn](Xe), g = l[Jn](je), m = o.style;
                    v.get("show") ? a(m, v, c, i[oi](t[ai](s, Li), t[ye](s)), p) : m.text = "", g.get("show") ? a(f, g, c, i[oi](t[ai](s, Ti), t[ye](s)), p) : f.text = "", n[Ke](o, f)
                })
            }, remove: function (t) {
                var e = this.group;
                t.get(Je) ? this._data && this._data[ne](function (i) {
                    i.style.text = "", n[ei](i, {shape: {width: 0}}, t, i[Mn], function () {
                        e[En](i)
                    })
                }) : e[rn]()
            }
        })
    }), e("echarts/layout/barGrid", [gr, vr, yi], function (t) {
        function e(t) {
            return t.get("stack") || "__ec_stack_" + t[bn]
        }

        function i(t) {
            var i = {};
            r.each(t, function (t) {
                var n = t[Ni], r = n[Me](), a = i[r.index] || {
                        remainedWidth: r.getBandWidth(),
                        autoWidthCount: 0,
                        categoryGap: "20%",
                        gap: "30%",
                        axis: r,
                        stacks: {}
                    }, o = a.stacks;
                i[r.index] = a;
                var s = e(t);
                o[s] || a.autoWidthCount++, o[s] = o[s] || {width: 0, maxWidth: 0};
                var l = t.get("barWidth"), c = t.get("barMaxWidth"), u = t.get("barGap"), h = t.get("barCategoryGap");
                l && !o[s].width && (l = Math.min(a.remainedWidth, l), o[s].width = l, a.remainedWidth -= l), c && (o[s].maxWidth = c), null != u && (a.gap = u), null != h && (a.categoryGap = h)
            });
            var n = {};
            return r.each(i, function (t, e) {
                n[e] = {};
                var i = t.stacks, a = t.axis, s = a.getBandWidth(), l = o(t.categoryGap, s), c = o(t.gap, 1), u = t.remainedWidth, h = t.autoWidthCount, d = (u - l) / (h + (h - 1) * c);
                d = Math.max(d, 0), r.each(i, function (t) {
                    var e = t.maxWidth;
                    !t.width && e && d > e && (e = Math.min(e, u), u -= e, t.width = e, h--)
                }), d = (u - l) / (h + (h - 1) * c), d = Math.max(d, 0);
                var f, p = 0;
                r.each(i, function (t) {
                    t.width || (t.width = d), f = t, p += t.width * (1 + c)
                }), f && (p -= f.width * c);
                var v = -p / 2;
                r.each(i, function (t, i) {
                    n[e][i] = n[e][i] || {offset: v, width: t.width}, v += t.width * (1 + c)
                })
            }), n
        }

        function n(t, n) {
            var a = i(r[fr](n.getSeriesByType(t), function (t) {
                return !n.isSeriesFiltered(t) && t[Ni] && t[Ni].type === ce
            })), o = {};
            n[hr](t, function (t) {
                var i = t[ur](), n = t[Ni], r = n[Me](), s = e(t), l = a[r.index][s], c = l.offset, u = l.width, h = n[ee](r), d = t.get("barMinHeight") || 0, f = r.onZero ? h.toGlobalCoord(h[te](0)) : h.getGlobalExtent()[0], p = n.dataToPoints(i, !0);
                o[s] = o[s] || [], i[$]({offset: c, size: u}), i.each(h.dim, function (t, e) {
                    if (!isNaN(t)) {
                        o[s][e] || (o[s][e] = {p: f, n: f});
                        var n, r, a, l, v = t >= 0 ? "p" : "n", g = p[e], m = o[s][e][v];
                        h.isHorizontal() ? (n = m, r = g[1] + c, a = g[0] - m, l = u, Math.abs(a) < d && (a = (0 > a ? -1 : 1) * d), o[s][e][v] += a) : (n = g[0] + c, r = m, a = u, l = g[1] - m, Math.abs(l) < d && (l = (0 >= l ? -1 : 1) * d), o[s][e][v] += l), i[Ve](e, {
                            x: n,
                            y: r,
                            width: a,
                            height: l
                        })
                    }
                }, !0)
            }, this)
        }

        var r = t(vr), a = t(yi), o = a[Ee];
        return n
    }), e("echarts/chart/heatmap/HeatmapSeries", [gr, Pe, "../helper/createListFromArray"], function (t) {
        var e = t(Pe), i = t("../helper/createListFromArray");
        return e[On]({
            type: "series.heatmap",
            getInitialData: function (t, e) {
                return i(t.data, this, e)
            },
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                xAxisIndex: 0,
                yAxisIndex: 0,
                geoIndex: 0,
                blurSize: 30,
                pointSize: 20,
                maxOpacity: 1,
                minOpacity: 0
            }
        })
    }), e("echarts/chart/heatmap/HeatmapView", [gr, vi, "./HeatmapLayer", vr, Ri], function (t) {
        function e(t, e, i) {
            var n = t[1] - t[0];
            e = o.map(e, function (e) {
                return {interval: [(e[Q][0] - t[0]) / n, (e[Q][1] - t[0]) / n]}
            });
            var r = e[zn], a = 0;
            return function (t) {
                for (var n = a; r > n; n++) {
                    var o = e[n][Q];
                    if (o[0] <= t && t <= o[1]) {
                        a = n;
                        break
                    }
                }
                if (n === r)for (var n = a - 1; n >= 0; n--) {
                    var o = e[n][Q];
                    if (o[0] <= t && t <= o[1]) {
                        a = n;
                        break
                    }
                }
                return n >= 0 && r > n && i[n]
            }
        }

        function i(t, e) {
            var i = t[1] - t[0];
            return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i], function (t) {
                return t >= e[0] && t <= e[1]
            }
        }

        function n(t) {
            var e = t[Te];
            return "lng" === e[0] && "lat" === e[1]
        }

        var r = t(vi), a = t("./HeatmapLayer"), o = t(vr);
        return t(Ri)[hn]({
            type: "heatmap", render: function (t, e, i) {
                var r;
                if (e[qn]("visualMap", function (e) {
                        e.eachTargetSeries(function (i) {
                            i === t && (r = e)
                        })
                    }), !r)throw new Error("Heatmap must use with visualMap");
                this.group[rn]();
                var a = t[Ni];
                a.type === ce ? this._renderOnCartesian(a, t, i) : n(a) && this._renderOnGeo(a, t, r, i)
            }, _renderOnCartesian: function (t, e) {
                var i = t[he]("x"), n = t[he]("y"), a = this.group;
                if (i.type !== be || n.type !== be)throw new Error("Heatmap on cartesian must have two category axes");
                if (!i.onBand || !n.onBand)throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
                var o = i.getBandWidth(), s = n.getBandWidth(), l = e[ur]();
                l.each(["x", "y", "z"], function (i, n, c, u) {
                    var h = l[Ai](u), d = t[Se]([i, n]);
                    if (!isNaN(c)) {
                        var f = new r.Rect({
                            shape: {x: d[0] - o / 2, y: d[1] - s / 2, width: o, height: s},
                            style: {fill: l[Mi](u, "color"), opacity: l[Mi](u, Hi)}
                        }), p = h[Jn](ie)[Wi](["color"]), v = h[Jn]("itemStyle.emphasis")[Wi](), g = h[Jn](Xe), m = h[Jn](je), y = e[ye](u), x = "-";
                        y && null != y[2] && (x = y[2]), g.get("show") && (r.setText(p, g), p.text = e[ai](u, Li) || x), m.get("show") && (r.setText(v, m), v.text = e[ai](u, Ti) || x), f[qi](p), r[Ke](f, v), a.add(f), l[He](u, f)
                    }
                })
            }, _renderOnGeo: function (t, n, o, s) {
                var l = o.targetVisuals.inRange, c = o.targetVisuals.outOfRange, u = n[ur](), h = this._hmLayer || this._hmLayer || new a;
                h.blurSize = n.get("blurSize"), h.pointSize = n.get("pointSize"), h.minOpacity = n.get("minOpacity"), h.maxOpacity = n.get("maxOpacity");
                var d = t.getViewRect().clone(), f = t.getRoamTransform()[rr];
                d[J](f);
                var p = Math.max(d.x, 0), v = Math.max(d.y, 0), g = Math.min(d.width + d.x, s[Kn]()), m = Math.min(d[Fn] + d.y, s[Yn]()), y = g - p, x = m - v, _ = u[K](["lng", "lat", "value"], function (e, i, n) {
                    var r = t[Se]([e, i]);
                    return r[0] -= p, r[1] -= v, r.push(n), r
                }), w = o[we](), b = "visualMap.continuous" === o.type ? i(w, o[Pi].range) : e(w, o.getPieceList(), o[Pi][Qe]);
                h[Gn](_, y, x, l.color.getNormalizer(), {
                    inRange: l.color.getColorMapper(),
                    outOfRange: c.color.getColorMapper()
                }, b);
                var M = new r.Image({style: {width: y, height: x, x: p, y: v, image: h[tr]}, silent: !0});
                this.group.add(M)
            }
        })
    }), e("echarts/component/radar", [gr, "../coord/radar/Radar", "../coord/radar/RadarModel", "./radar/RadarView"], function (t) {
        t("../coord/radar/Radar"), t("../coord/radar/RadarModel"), t("./radar/RadarView")
    }), e("echarts/chart/radar/RadarSeries", [gr, Pe, Bi, Oi, vr], function (t) {
        var e = t(Pe), i = t(Bi), n = t(Oi), r = t(vr), a = e[On]({
            type: "series.radar",
            dependencies: ["radar"],
            init: function () {
                a[Vi](this, "init", arguments), this.legendDataProvider = function () {
                    return this._dataBeforeProcessed
                }
            },
            getInitialData: function (t) {
                var e = t.data || [], r = n([], e, [], "indicator_"), a = new i(r, this);
                return a[Ii](e), a
            },
            formatTooltip: function (t) {
                var e = this[ye](t), i = this[Ni], n = i.getIndicatorAxes();
                return this._data[xi](t) + Le + r.map(n, function (t, i) {
                        return t.name + " : " + e[i]
                    }).join(Le)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "radar",
                legendHoverLink: !0,
                radarIndex: 0,
                lineStyle: {normal: {width: 2, type: "solid"}},
                label: {normal: {position: "top"}},
                symbol: "emptyCircle",
                symbolSize: 4
            }
        });
        return a
    }), e("echarts/chart/candlestick/preprocessor", [gr, vr], function (t) {
        var e = t(vr);
        return function (t) {
            t && e[gn](t[Dn]) && e.each(t[Dn], function (t) {
                e[Bn](t) && "k" === t.type && (t.type = "candlestick")
            })
        }
    }), e("echarts/chart/candlestick/candlestickVisual", [gr], function () {
        var t = [ln, Li, Ge], e = [ln, Li, "borderColor0"], i = [ln, Li, "color"], n = [ln, Li, "color0"];
        return function (r) {
            r.eachRawSeriesByType("candlestick", function (a) {
                var o = a[ur]();
                o[cr]({legendSymbol: "roundRect"}), r.isSeriesFiltered(a) || o.each(function (r) {
                    var a = o[Ai](r), s = o[fi](r).sign;
                    o[wi](r, {color: a.get(s > 0 ? i : n), borderColor: a.get(s > 0 ? t : e)})
                })
            })
        }
    }), e("echarts/chart/radar/backwardCompat", [gr, vr], function (t) {
        var e = t(vr);
        return function (t) {
            var i = t.polar;
            if (i) {
                e[gn](i) || (i = [i]);
                var n = [];
                e.each(i, function (i) {
                    i.indicator ? (i.type && !i.shape && (i.shape = i.type), t.radar = t.radar || [], e[gn](t.radar) || (t.radar = [t.radar]), t.radar.push(i)) : n.push(i)
                }), t.polar = n
            }
            e.each(t[Dn], function (t) {
                "radar" === t.type && t[Y] && (t.radarIndex = t[Y])
            })
        }
    }), e("echarts/layout/points", [gr], function () {
        return function (t, e) {
            e[hr](t, function (t) {
                var e = t[ur](), i = t[Ni];
                if (i) {
                    var n = i[Te];
                    e.each(n, function (t, n, r) {
                        var a;
                        a = isNaN(t) || isNaN(n) ? [0 / 0, 0 / 0] : i[Se]([t, n]), e[Ve](r, a)
                    }, !0)
                }
            })
        }
    }), e("echarts/chart/treemap/TreemapView", [gr, vr, vi, "../../data/DataDiffer", "./helper", "./Breadcrumb", "../../component/helper/RoamController", X, or, "../../util/animation", Ri], function (t) {
        function e() {
            return {nodeGroup: [], background: [], content: []}
        }

        function i(t, e, i, o, s, l, c, u, h, d) {
            function f(e) {
                R[Mn] = c[Mn], R[bn] = t[bn];
                var i = C.borderWidth, n = Math.max(T - 2 * i, 0), r = Math.max(L - 2 * i, 0);
                R.culling = !0, R[ii]({x: i, y: i, width: n, height: r});
                var o = c[G]("color", !0);
                g(R, function () {
                    var t = {fill: o}, e = c[Jn]("itemStyle.emphasis")[Wi]();
                    m(t, e, o, n, r), R[qi](t), a[Ke](R, e)
                }), e.add(R)
            }

            function g(t, e) {
                k ? !t[q] && l.push(t) : (e(), t.__tmWillVisible || (t[q] = !1))
            }

            function m(e, i, n, r, a) {
                var o = c[Jn](), s = o.get("name");
                if (C.isLeafRoot) {
                    var l = t.get("drillDownIcon", !0);
                    s += l ? "  " + l : ""
                }
                _(s, e, o, y, n, r, a), _(s, i, o, x, n, r, a)
            }

            function _(t, e, i, n, r, o, s) {
                var l = i[Jn](n), c = l[Jn](nn);
                a.setText(e, l, r), e[en] = c.get("align"), e.textVerticalAlign = c.get("baseline");
                var u = c.getTextRect(t);
                e.text = !l[N]("show") || u[Fn] > s ? "" : u.width > o ? c.get("ellipsis") ? c.ellipsis(t, o) : "" : t
            }

            function M(t, r, a, o) {
                var l = null != I && i[t][I], c = s[t];
                return l ? (i[t][I] = null, S(c, l, t)) : k || (l = new r({z: n(a, o)}), l.__tmDepth = a, l.__tmStorageName = t, A(c, l, t)), e[t][D] = l
            }

            function S(t, e, i) {
                var n = t[D] = {};
                n.old = "nodeGroup" === i ? e[Ui].slice() : r[On]({}, e.shape)
            }

            function A(t, e, i) {
                var n = t[D] = {}, r = c[B];
                if (r && (!o || "drillDown" === o.direction)) {
                    var a = 0, l = 0, u = s.background[r[Si]()];
                    !o && u && u.old && (a = u.old.width, l = u.old[Fn]), n.old = "nodeGroup" === i ? [0, l] : {
                        x: a,
                        y: l,
                        width: 0,
                        height: 0
                    }
                }
                n.fadein = "nodeGroup" !== i
            }

            if (c) {
                var C = c[H]();
                if (C && C.isInView) {
                    var T = C.width, L = C[Fn], k = C[q], D = c[Si](), I = u && u[Si](), P = M("nodeGroup", p);
                    if (P) {
                        if (h.add(P), P[Ui] = [C.x || 0, C.y || 0], P.__tmNodeWidth = T, P.__tmNodeHeight = L, C.isAboveViewRoot)return P;
                        var z = M("background", v, d, w);
                        z && (z[ii]({x: 0, y: 0, width: T, height: L}), g(z, function () {
                            z[qi]("fill", c[G](Ge, !0))
                        }), P.add(z));
                        var V = c.viewChildren;
                        if (!V || !V[zn]) {
                            var R = M("content", v, d, b);
                            R && f(P)
                        }
                        return P
                    }
                }
            }
        }

        function n(t, e) {
            var i = t * _ + e;
            return (i - 1) / i
        }

        var r = t(vr), a = t(vi), o = t("../../data/DataDiffer"), s = t("./helper"), l = t("./Breadcrumb"), c = t("../../component/helper/RoamController"), u = t(X), h = t(or), d = t("../../util/animation"), f = r.bind, p = a.Group, v = a.Rect, g = r.each, m = 3, y = ["label", Li], x = ["label", Ti], _ = 10, w = 1, b = 2;
        return t(Ri)[hn]({
            type: "treemap", init: function () {
                this._containerGroup, this._storage = e(), this._oldTree, this._breadcrumb, this._controller, this._state = "ready", this._mayClick
            }, render: function (t, e, i, n) {
                var a = e[_i]({mainType: "series", subType: "treemap", query: n});
                if (!(r[vn](a, t) < 0)) {
                    this.seriesModel = t, this.api = i, this[j] = e;
                    var o = s.retrieveTargetInfo(n, t), l = n && n.type, c = t.layoutInfo, u = !this._oldTree, h = this._storage, d = "treemapRootToNode" === l && o && h ? {
                        rootNodeGroup: h.nodeGroup[o.node[Si]()],
                        direction: n.direction
                    } : null, f = this._giveContainerGroup(c), p = this._doRender(f, t, d);
                    u || l && "treemapZoomToNode" !== l && "treemapRootToNode" !== l ? p.renderFinally() : this._doAnimation(f, p, t, d), this._resetController(i), this._renderBreadcrumb(t, i, o)
                }
            }, _giveContainerGroup: function (t) {
                var e = this._containerGroup;
                return e || (e = this._containerGroup = new p, this._initEvents(e), this.group.add(e)), e[Ui] = [t.x, t.y], e
            }, _doRender: function (t, n, a) {
                function s(t, e, i, n, a) {
                    function l(t) {
                        return t.getId()
                    }

                    function c(r, o) {
                        var l = null != r ? t[r] : null, c = null != o ? e[o] : null, u = m(l, c, i, a);
                        u && s(l && l.viewChildren || [], c && c.viewChildren || [], u, n, a + 1)
                    }

                    n ? (e = t, g(t, function (t, e) {
                        !t.isRemoved() && c(e, e)
                    })) : new o(e, t, l, l).add(c)[Gn](c)[En](r.curry(c, null))[qe]()
                }

                function l(t) {
                    var i = e();
                    return t && g(t, function (t, e) {
                        var n = i[e];
                        g(t, function (t) {
                            t && (n.push(t), t.__tmWillDelete = 1)
                        })
                    }), i
                }

                function c() {
                    g(y, function (t) {
                        g(t, function (t) {
                            t[U] && t[U][En](t)
                        })
                    }), g(v, function (t) {
                        t[q] = !0, t.dirty()
                    })
                }

                var u = n[ur]().tree, h = this._oldTree, d = e(), f = e(), p = this._storage, v = [], m = r.curry(i, n, f, p, a, d, v);
                s(u.root ? [u.root] : [], h && h.root ? [h.root] : [], t, u === h || !h, 0);
                var y = l(p);
                return this._oldTree = u, this._storage = f, {lastsForAnimation: d, willDeleteEls: y, renderFinally: c}
            }, _doAnimation: function (t, e, i, n) {
                if (i.get(Je)) {
                    var a = i.get("animationDurationUpdate"), o = i.get("animationEasing"), s = d.createWrap();
                    g(e.willDeleteEls, function (t, e) {
                        g(t, function (t) {
                            if (!t[q]) {
                                var i, r = t[U];
                                if (n && "drillDown" === n.direction)i = r === n.rootNodeGroup ? {
                                    shape: {
                                        x: 0,
                                        y: 0,
                                        width: r.__tmNodeWidth,
                                        height: r.__tmNodeHeight
                                    }, style: {opacity: 0}
                                } : {style: {opacity: 0}}; else {
                                    var l = 0, c = 0;
                                    r.__tmWillDelete || (l = r.__tmNodeWidth / 2, c = r.__tmNodeHeight / 2), i = "nodeGroup" === e ? {
                                        position: [l, c],
                                        style: {opacity: 0}
                                    } : {shape: {x: l, y: c, width: 0, height: 0}, style: {opacity: 0}}
                                }
                                i && s.add(t, i, a, o)
                            }
                        })
                    }), g(this._storage, function (t, i) {
                        g(t, function (t, n) {
                            var l = e.lastsForAnimation[i][n], c = {};
                            l && ("nodeGroup" === i ? l.old && (c[Ui] = t[Ui].slice(), t[Ui] = l.old) : (l.old && (c.shape = r[On]({}, t.shape), t[ii](l.old)), l.fadein ? (t[qi](Hi, 0), c.style = {opacity: 1}) : 1 !== t.style[Hi] && (c.style = {opacity: 1})), s.add(t, c, a, o))
                        })
                    }, this), this._state = "animating", s.done(f(function () {
                        this._state = "ready", e.renderFinally()
                    }, this)).start()
                }
            }, _resetController: function (t) {
                var e = this._controller;
                e || (e = this._controller = new c(t.getZr()), e[W](this.seriesModel.get("roam")), e.on("pan", f(this._onPan, this)), e.on("zoom", f(this._onZoom, this)));
                var i = new u(0, 0, t[Kn](), t[Yn]());
                e.rectProvider = function () {
                    return i
                }
            }, _clearController: function () {
                var t = this._controller;
                t && (t.off("pan").off("zoom"), t = null)
            }, _onPan: function (t, e) {
                if (this._mayClick = !1, "animating" !== this._state && (Math.abs(t) > m || Math.abs(e) > m)) {
                    var i = this.seriesModel[ur]().tree.root;
                    if (!i)return;
                    var n = i[H]();
                    if (!n)return;
                    this.api[Rn]({
                        type: "treemapMove",
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        rootRect: {x: n.x + t, y: n.y + e, width: n.width, height: n[Fn]}
                    })
                }
            }, _onZoom: function (t, e, i) {
                if (this._mayClick = !1, "animating" !== this._state) {
                    var n = this.seriesModel[ur]().tree.root;
                    if (!n)return;
                    var r = n[H]();
                    if (!r)return;
                    var a = new u(r.x, r.y, r.width, r[Fn]), o = this.seriesModel.layoutInfo;
                    e -= o.x, i -= o.y;
                    var s = h[Zn]();
                    h.translate(s, s, [-e, -i]), h.scale(s, s, [t, t]), h.translate(s, s, [e, i]), a[J](s), this.api[Rn]({
                        type: "treemapRender",
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        rootRect: {x: a.x, y: a.y, width: a.width, height: a[Fn]}
                    })
                }
            }, _initEvents: function (t) {
                function e(t) {
                    var e = this.seriesModel.get("nodeClick", !0);
                    if (e) {
                        var i = this.findTarget(t[F], t[Z]);
                        if (i) {
                            var n = i.node;
                            if (n[H]().isLeafRoot)this._rootToNode(i); else if ("zoomToNode" === e)this._zoomToNode(i); else if ("link" === e) {
                                var r = n.hostTree.data[Ai](n[Mn]), a = r.get("link", !0), o = r.get(Sn, !0) || "blank";
                                a && window.open(a, o)
                            }
                        }
                    }
                }

                t.on("mousedown", function () {
                    "ready" === this._state && (this._mayClick = !0)
                }, this), t.on("mouseup", function (t) {
                    this._mayClick && (this._mayClick = !1, "ready" === this._state && e.call(this, t))
                }, this)
            }, _renderBreadcrumb: function (t, e, i) {
                function n(e) {
                    "animating" !== this._state && (s.aboveViewRoot(t.getViewRoot(), e) ? this._rootToNode({node: e}) : this._zoomToNode({node: e}))
                }

                i || (i = this.findTarget(e[Kn]() / 2, e[Yn]() / 2), i || (i = {node: t[ur]().tree.root})), (this._breadcrumb || (this._breadcrumb = new l(this.group, f(n, this))))[Tn](t, e, i.node)
            }, remove: function () {
                this._clearController(), this._containerGroup && this._containerGroup[rn](), this._storage = e(), this._state = "ready", this._breadcrumb && this._breadcrumb[En]()
            }, dispose: function () {
                this._clearController()
            }, _zoomToNode: function (t) {
                this.api[Rn]({
                    type: "treemapZoomToNode",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    targetNode: t.node
                })
            }, _rootToNode: function (t) {
                this.api[Rn]({
                    type: "treemapRootToNode",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    targetNode: t.node
                })
            }, findTarget: function (t, e) {
                var i, n = this.seriesModel.getViewRoot();
                return n.eachNode({attr: "viewChildren", order: "preorder"}, function (n) {
                    var r = this._storage.background[n[Si]()];
                    if (r) {
                        var a = r.transformCoordToLocal(t, e), o = r.shape;
                        if (!(o.x <= a[0] && a[0] <= o.x + o.width && o.y <= a[1] && a[1] <= o.y + o[Fn]))return !1;
                        i = {node: n, offsetX: a[0], offsetY: a[1]}
                    }
                }, this), i
            }
        })
    }), e("echarts/chart/bar/BarSeries", [gr, Pe, "../helper/createListFromArray"], function (t) {
        var e = t(Pe), i = t("../helper/createListFromArray");
        return e[On]({
            type: "series.bar",
            dependencies: ["grid", "polar"],
            getInitialData: function (t, e) {
                return i(t.data, this, e)
            },
            getMarkerPosition: function (t) {
                var e = this[Ni];
                if (e) {
                    var i = e[Se](t), n = this[ur](), r = n[H]("offset"), a = n[H]("size"), o = e[Me]().isHorizontal() ? 0 : 1;
                    return i[o] += r + a / 2, i
                }
                return [0 / 0, 0 / 0]
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                barMinHeight: 0,
                itemStyle: {
                    normal: {barBorderColor: "#fff", barBorderWidth: 0},
                    emphasis: {barBorderColor: "#fff", barBorderWidth: 0}
                }
            }
        })
    }), e("echarts/chart/treemap/treemapAction", [gr, Ri, "./helper"], function (t) {
        for (var e = t(Ri), i = t("./helper"), n = function () {
        }, r = ["treemapZoomToNode", "treemapRender", "treemapMove"], a = 0; a < r[zn]; a++)e[pn]({
            type: r[a],
            update: "updateView"
        }, n);
        e[pn]({type: "treemapRootToNode", update: "updateView"}, function (t, e) {
            function n(e) {
                var n = i.retrieveTargetInfo(t, e);
                if (n) {
                    var r = e.getViewRoot();
                    r && (t.direction = i.aboveViewRoot(r, n.node) ? "rollUp" : "drillDown"), e.resetViewRoot(n.node)
                }
            }

            e[qn]({mainType: "series", subType: "treemap", query: t}, n)
        })
    }), e("echarts/chart/treemap/treemapVisual", [gr, "../../visual/VisualMapping", "zrender/tool/color", vr], function (t) {
        function e(t, a, s, c, u, d) {
            var p = t[Jn](), v = t[H]();
            if (v && !v[q] && v.isInView) {
                var g, m = t[Jn](f), y = s[t.depth], x = i(m, a, y, c), _ = m.get(Ge), w = m.get("borderColorSaturation");
                null != w && (g = n(x, t), _ = r(w, g)), t[cr](Ge, _);
                var b = t.viewChildren;
                if (b && b[zn]) {
                    var M = o(t, p, v, m, x, b);
                    h.each(b, function (t, i) {
                        if (t.depth >= u[zn] || t === u[t.depth]) {
                            var n = l(p, x, t, i, M, d);
                            e(t, n, s, c, u, d)
                        }
                    })
                } else g = n(x, t), t[cr]("color", g)
            }
        }

        function i(t, e, i, n) {
            var r = h[On]({}, e);
            return h.each(["color", "colorAlpha", "colorSaturation"], function (a) {
                var o = t.get(a, !0);
                null == o && i && (o = i[a]), null == o && (o = e[a]), null == o && (o = n.get(a)), null != o && (r[a] = o)
            }), r
        }

        function n(t) {
            var e = a(t, "color");
            if (e) {
                var i = a(t, "colorAlpha"), n = a(t, "colorSaturation");
                return n && (e = u.modifyHSL(e, null, null, n)), i && (e = u.modifyAlpha(e, i)), e
            }
        }

        function r(t, e) {
            return null != e ? u.modifyHSL(e, null, null, t) : null
        }

        function a(t, e) {
            var i = t[e];
            return null != i && "none" !== i ? i : void 0
        }

        function o(t, e, i, n, r, a) {
            if (a && a[zn]) {
                var o = s(e, "color") || null != r.color && "none" !== r.color && (s(e, "colorAlpha") || s(e, "colorSaturation"));
                if (o) {
                    var l = e.get("colorMappingBy"), u = {type: o.name, dataExtent: i.dataExtent, visual: o.range};
                    "color" !== u.type || "index" !== l && "id" !== l ? u.mappingMethod = "linear" : (u.mappingMethod = be, u.loop = !0);
                    var h = new c(u);
                    return h.__drColorMappingBy = l, h
                }
            }
        }

        function s(t, e) {
            var i = t.get(e);
            return d(i) && i[zn] ? {name: e, range: i} : null
        }

        function l(t, e, i, n, r, a) {
            var o = h[On]({}, e);
            if (r) {
                var s = r.type, l = "color" === s && r.__drColorMappingBy, c = "index" === l ? n : "id" === l ? a.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension"));
                o[s] = r.mapValueToVisual(c)
            }
            return o
        }

        var c = t("../../visual/VisualMapping"), u = t("zrender/tool/color"), h = t(vr), d = h[gn], f = ie;
        return function (t, i) {
            var n = {mainType: "series", subType: "treemap", query: i};
            t[qn](n, function (t) {
                var i = t[ur]().tree, n = i.root, r = t[Jn](f);
                if (!n.isRemoved()) {
                    var a = h.map(i.levelModels, function (t) {
                        return t ? t.get(f) : null
                    });
                    e(n, {}, a, r, t.getViewRoot().getAncestors(), t)
                }
            })
        }
    }), e("echarts/chart/lines/LinesSeries", [gr, Pe, Bi, vr, ge], function (t) {
        var e = t(Pe), i = t(Bi), n = t(vr), r = t(ge);
        return e[On]({
            type: "series.lines",
            dependencies: ["grid", "polar"],
            getInitialData: function (t) {
                function e(t, e, i, n) {
                    return t.coord && t.coord[n]
                }

                var a = [], o = [], s = [];
                n.each(t.data, function (t) {
                    a.push(t[0]), o.push(t[1]), s.push(n[On](n[On]({}, n[gn](t[0]) ? null : t[0]), n[gn](t[1]) ? null : t[1]))
                });
                var l = r.get(t[Ni]);
                if (!l)throw new Error("Invalid coordinate system");
                var c = l[Te], u = new i(c, this), h = new i(c, this), d = new i(["value"], this);
                return u[Ii](a, null, e), h[Ii](o, null, e), d[Ii](s), this.fromData = u, this.toData = h, d
            },
            formatTooltip: function (t) {
                var e = this.fromData[xi](t), i = this.toData[xi](t);
                return e + " > " + i
            },
            defaultOption: {
                coordinateSystem: "geo",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                geoIndex: 0,
                effect: {show: !1, period: 4, symbol: "circle", symbolSize: 3, trailLength: .2},
                large: !1,
                largeThreshold: 2e3,
                label: {normal: {show: !1, position: "end"}},
                lineStyle: {normal: {opacity: .5}}
            }
        })
    }), e("echarts/chart/lines/LinesView", [gr, "../helper/LineDraw", "../helper/EffectLine", "../helper/Line", Ri], function (t) {
        var e = t("../helper/LineDraw"), i = t("../helper/EffectLine"), n = t("../helper/Line");
        t(Ri)[hn]({
            type: "lines", init: function () {
            }, render: function (t, r, a) {
                var o = t[ur](), s = this._lineDraw, l = t.get("effect.show");
                l !== this._hasEffet && (s && s[En](), s = this._lineDraw = new e(l ? i : n), this._hasEffet = l);
                var c = t.get(xn), u = t.get("effect.trailLength"), h = a.getZr();
                h.painter.getLayer(c).clear(!0), null != this._lastZlevel && h.configLayer(this._lastZlevel, {motionBlur: !1}), l && u && h.configLayer(c, {
                    motionBlur: !0,
                    lastFrameAlpha: Math.max(Math.min(u / 10 + .9, 1), 0)
                }), this.group.add(s.group), s[li](o), this._lastZlevel = c
            }, updateLayout: function (t, e, i) {
                this._lineDraw[Nn]();
                var n = i.getZr();
                n.painter.getLayer(this._lastZlevel).clear(!0)
            }, remove: function (t, e) {
                this._lineDraw && this._lineDraw[En](e, !0)
            }
        })
    }), e("echarts/chart/radar/RadarView", [gr, vi, vr, E, Ri], function (t) {
        function e(t) {
            return n[gn](t) || (t = [+t, +t]), t
        }

        var i = t(vi), n = t(vr), r = t(E);
        return t(Ri)[hn]({
            type: "radar", render: function (t) {
                function a(t, i) {
                    var n = t[Mi](i, _e) || dr, a = t[Mi](i, "color");
                    if ("none" !== n) {
                        var o = r[O](n, -.5, -.5, 1, 1, a);
                        return o.attr({style: {strokeNoScale: !0}, z2: 100, scale: e(t[Mi](i, xe))}), o
                    }
                }

                function o(e, n, r, o, s, l) {
                    r[rn]();
                    for (var c = 0; c < n[zn] - 1; c++) {
                        var u = a(o, s);
                        u && (u.__dimIdx = c, e[c] ? (u.attr(Ui, e[c]), i[l ? Ze : ei](u, {position: n[c]}, t, s)) : u.attr(Ui, n[c]), r.add(u))
                    }
                }

                function s(t) {
                    return n.map(t, function () {
                        return [l.cx, l.cy]
                    })
                }

                var l = t[Ni], c = this.group, u = t[ur](), h = this._data;
                u.diff(h).add(function (e) {
                    var n = u[fi](e);
                    if (n) {
                        var r = new i[R], a = new i[ci], l = {shape: {points: n}};
                        r.shape[V] = s(n), a.shape[V] = s(n), i[Ze](r, l, t, e), i[Ze](a, l, t, e);
                        var c = new i.Group, h = new i.Group;
                        c.add(a), c.add(r), c.add(h), o(a.shape[V], n, h, u, e, !0), u[He](e, c)
                    }
                })[Gn](function (e, n) {
                    var r = h[pi](n), a = r[ni](0), s = r[ni](1), l = r[ni](2), c = {shape: {points: u[fi](e)}};
                    c.shape[V] && (o(a.shape[V], c.shape[V], l, u, e, !1), i[ei](a, c, t), i[ei](s, c, t), u[He](e, r))
                })[En](function (t) {
                    c[En](h[pi](t))
                })[qe](), u[ne](function (e, r) {
                    function a() {
                        h.attr(Wn, m)
                    }

                    function o() {
                        h.attr(Wn, g)
                    }

                    var s = u[Ai](r), l = e[ni](0), h = e[ni](1), d = e[ni](2), f = u[Mi](r, "color");
                    c.add(e), l[ti](n[On](s[Jn]("lineStyle.normal")[Ue](), {
                        fill: "none",
                        stroke: f
                    })), l[$e] = s[Jn]("lineStyle.emphasis")[Ue]();
                    var p = s[Jn]("areaStyle.normal"), v = s[Jn]("areaStyle.emphasis"), g = p.isEmpty() && p.parentModel.isEmpty(), m = v.isEmpty() && v.parentModel.isEmpty();
                    m = m && g, h[Wn] = g, h[ti](n[Vn](p[z](), {fill: f, opacity: .7})), h[$e] = v[z]();
                    var y = s[Jn](ie)[Wi](["color"]), x = s[Jn]("itemStyle.emphasis")[Wi](), _ = s[Jn](Xe), w = s[Jn](je);
                    d[We](function (e) {
                        e[qi](y), e[$e] = n.clone(x);
                        var a = u.get(u[Te][e.__dimIdx], r);
                        i.setText(e.style, _, f), e[qi]({text: _.get("show") ? n[oi](t[ai](r, Li, null, e.__dimIdx), a) : ""}), i.setText(e[$e], w, f), e[$e].text = w.get("show") ? n[oi](t[ai](r, Ti, null, e.__dimIdx), a) : ""
                    }), e.off(Cn).off(An).off(Li).off(Ti), e.on(Ti, a).on(Cn, a).on(Li, o).on(An, o), i[Ke](e)
                }), this._data = u
            }, remove: function () {
                this.group[rn](), this._data = null
            }
        })
    }), e("echarts/visual/seriesColor", [gr, "zrender/graphic/Gradient"], function (t) {
        var e = t("zrender/graphic/Gradient");
        return function (t, i, n) {
            function r(t) {
                var r = [i, Li, "color"], a = n.get("color"), o = t[ur](), s = t.get(r) || a[t[bn] % a[zn]];
                o[cr]("color", s), n.isSeriesFiltered(t) || (typeof s !== fn || s instanceof e || o.each(function (e) {
                    o[wi](e, "color", s(t[wn](e)))
                }), o.each(function (t) {
                    var e = o[Ai](t), i = e.get(r, !0);
                    null != i && o[wi](t, "color", i)
                }))
            }

            t ? n[hr](t, r) : n[In](r)
        }
    }), e("echarts/chart/graph/GraphSeries", [gr, Bi, vr, Ei, re, "../helper/createGraphFromNodeEdge", Ri], function (t) {
        var e = t(Bi), i = t(vr), n = t(Ei), r = t(re), a = t("../helper/createGraphFromNodeEdge"), o = t(Ri).extendSeriesModel({
            type: "series.graph",
            init: function (t) {
                o[Vi](this, "init", arguments), this.legendDataProvider = function () {
                    return this._categoriesData
                }, this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
            },
            mergeOption: function (t) {
                o[Vi](this, zi, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
            },
            mergeDefaultAndTheme: function (t) {
                o[Vi](this, P, arguments), n[ki](t.edgeLabel, n.LABEL_OPTIONS)
            },
            getInitialData: function (t) {
                function e(t, e) {
                    t.wrapMethod(Ai, function (t) {
                        var e = o._categoriesModels, i = t[N](be), n = e[i];
                        return n && (n.parentModel = t.parentModel, t.parentModel = n), t
                    });
                    var i = o[Jn]("edgeLabel"), n = function (t, e) {
                        var a = (t || "").split(".");
                        "label" === a[0] && (e = e || i[Jn](a.slice(1)));
                        var o = r[ir][Jn].call(this, a, e);
                        return o[Jn] = n, o
                    };
                    e.wrapMethod(Ai, function (t) {
                        return t[Jn] = n, t
                    })
                }

                var i = t.edges || t.links || [], n = t.data || t.nodes || [], o = this;
                return n && i ? a(n, i, this, !0, e).data : void 0
            },
            getGraph: function () {
                return this[ur]().graph
            },
            getEdgeData: function () {
                return this[I]().edgeData
            },
            getCategoriesData: function () {
                return this._categoriesData
            },
            formatTooltip: function (t, e, i) {
                if ("edge" === i) {
                    var n = this[ur](), r = this[wn](t, i), a = n.graph.getEdgeByIndex(t), s = n[xi](a.node1[Mn]), l = n[xi](a.node2[Mn]), c = s + " > " + l;
                    return r.value && (c += " : " + r.value), c
                }
                return o[Vi](this, "formatTooltip", arguments)
            },
            _updateCategoriesData: function () {
                var t = i.map(this[Pi][D] || [], function (t) {
                    return null != t.value ? t : i[On]({value: 0}, t)
                }), n = new e(["value"], this);
                n[Ii](t), this._categoriesData = n, this._categoriesModels = n[K](function (t) {
                    return n[Ai](t, !0)
                })
            },
            setZoom: function (t) {
                this[Pi].zoom = t
            },
            setCenter: function (t) {
                this[Pi][ji] = t
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                color: ["#61a0a8", "#d14a61", "#fd9c35", "#675bba", "#fec42c", "#dd4444", "#fd9c35", "#cd4870"],
                coordinateSystem: "view",
                xAxisIndex: 0,
                yAxisIndex: 0,
                polarIndex: 0,
                geoIndex: 0,
                legendHoverLink: !0,
                hoverAnimation: !0,
                layout: null,
                force: {initLayout: null, repulsion: 50, gravity: .1, edgeLength: 30, layoutAnimation: !0},
                left: "center",
                top: "center",
                symbol: "circle",
                symbolSize: 10,
                edgeSymbol: ["none", "none"],
                edgeSymbolSize: 10,
                edgeLabel: {normal: {position: "middle"}, emphasis: {}},
                draggable: !1,
                roam: !1,
                center: null,
                zoom: 1,
                nodeScaleRatio: .6,
                label: {normal: {show: !1, formatter: "{b}"}, emphasis: {show: !0}},
                itemStyle: {normal: {}, emphasis: {}},
                lineStyle: {normal: {color: "#aaa", width: 1, curveness: 0, opacity: .5}, emphasis: {}}
            }
        });
        return o
    }), e("echarts/chart/radar/radarLayout", [gr], function () {
        return function (t) {
            t[hr]("radar", function (t) {
                function e(t, e) {
                    n[e] = n[e] || [], n[e][a] = r[Se](t, a)
                }

                var i = t[ur](), n = [], r = t[Ni];
                if (r) {
                    for (var a = 0; a < r.getIndicatorAxes()[zn]; a++) {
                        var o = i[Te][a];
                        i.each(o, e)
                    }
                    i.each(function (t) {
                        n[t][0] && n[t].push(n[t][0].slice()), i[Ve](t, n[t])
                    })
                }
            })
        }
    }), e("echarts/chart/graph/roamAction", [gr, Ri, "../../action/roamHelper"], function (t) {
        var e = t(Ri), i = t("../../action/roamHelper"), n = {type: "graphRoam", event: "graphRoam", update: "none"};
        e[pn](n, function (t, e) {
            e[qn]({mainType: "series", query: t}, function (e) {
                var n = e[Ni], r = i.updateCenterAndZoom(n, t);
                e.setCenter && e.setCenter(r[ji]), e.setZoom && e.setZoom(r.zoom)
            })
        })
    }), e("echarts/chart/treemap/TreemapSeries", [gr, Pe, "../../data/Tree", vr, re, Ie], function (t) {
        function e(t, i) {
            var n = 0;
            a.each(t.children, function (t) {
                e(t, i);
                var r = t.value;
                a[gn](r) && (r = r[0]), n += r
            });
            var r = t.value;
            i >= 0 && (a[gn](r) ? r = r[0] : t.value = new Array(i)), (null == r || isNaN(r)) && (r = n), 0 > r && (r = 0), i >= 0 ? t.value[0] = r : t.value = r
        }

        function i(t, e) {
            var i = e.get("color");
            if (i) {
                t = t || [];
                var n;
                if (a.each(t, function (t) {
                        var e = new o(t), i = e.get("color");
                        (e.get(bi) || i && "none" !== i) && (n = !0)
                    }), !n) {
                    var r = t[0] || (t[0] = {});
                    r.color = i.slice()
                }
                return t
            }
        }

        var n = t(Pe), r = t("../../data/Tree"), a = t(vr), o = t(re), s = t(Ie), l = s[De], c = s[ke];
        return n[On]({
            type: "series.treemap",
            dependencies: ["grid", "polar"],
            _viewRoot: null,
            defaultOption: {
                left: "center",
                top: "middle",
                right: null,
                bottom: null,
                width: "80%",
                height: "80%",
                sort: !0,
                clipWindow: "origin",
                squareRatio: .5 * (1 + Math.sqrt(5)),
                leafDepth: null,
                drillDownIcon: "",
                visualDimension: 0,
                zoomToNodeRatio: .1024,
                roam: !0,
                nodeClick: "zoomToNode",
                animation: !0,
                animationDurationUpdate: 900,
                animationEasing: "quinticInOut",
                breadcrumb: {
                    show: !0,
                    height: 22,
                    left: "center",
                    top: "bottom",
                    emptyItemWidth: 25,
                    itemStyle: {
                        normal: {
                            color: "rgba(0,0,0,0.7)",
                            borderColor: "rgba(255,255,255,0.7)",
                            borderWidth: 1,
                            shadowColor: "rgba(150,150,150,1)",
                            shadowBlur: 3,
                            shadowOffsetX: 0,
                            shadowOffsetY: 0,
                            textStyle: {color: "#fff"}
                        }, emphasis: {textStyle: {}}
                    }
                },
                label: {normal: {show: !0, position: "inside", textStyle: {color: "#fff", ellipsis: !0}}},
                itemStyle: {
                    normal: {
                        color: null,
                        colorAlpha: null,
                        colorSaturation: null,
                        borderWidth: 0,
                        gapWidth: 0,
                        borderColor: "#fff",
                        borderColorSaturation: null
                    }, emphasis: {}
                },
                color: "none",
                colorAlpha: null,
                colorSaturation: null,
                colorMappingBy: "index",
                visibleMin: 10,
                childrenVisibleMin: null,
                levels: []
            },
            getInitialData: function (t, n) {
                var o = t.data || [], s = t.name;
                null == s && (s = t.name);
                var l = {name: s, children: t.data}, c = (o[0] || {}).value;
                e(l, a[gn](c) ? c[zn] : -1);
                var u = t.levels || [];
                return u = t.levels = i(u, n), r.createTree(l, this, u).data
            },
            optionUpdated: function () {
                this.resetViewRoot()
            },
            formatTooltip: function (t) {
                var e = this[ur](), i = this[ye](t), n = c(a[gn](i) ? i[0] : i), r = e[xi](t);
                return l(r) + ": " + n
            },
            getDataParams: function (t) {
                for (var e = n[ir][wn].apply(this, arguments), i = this[ur](), r = i.tree.getNodeByDataIndex(t), a = e.treePathInfo = []; r;) {
                    var o = r[Mn];
                    a.push({name: r.name, dataIndex: o, value: this[ye](o)}), r = r[B]
                }
                return a[k](), e
            },
            setLayoutInfo: function (t) {
                this.layoutInfo = this.layoutInfo || {}, a[On](this.layoutInfo, t)
            },
            mapIdToIndex: function (t) {
                var e = this._idIndexMap;
                e || (e = this._idIndexMap = {}, this._idIndexMapCount = 0);
                var i = e[t];
                return null == i && (e[t] = i = this._idIndexMapCount++), i
            },
            getViewRoot: function () {
                return this._viewRoot
            },
            resetViewRoot: function (t) {
                t ? this._viewRoot = t : t = this._viewRoot;
                var e = this[ur]().tree.root;
                (!t || t !== e && !e.contains(t)) && (this._viewRoot = e)
            }
        })
    }), e("echarts/chart/graph/categoryFilter", [gr], function () {
        return function (t) {
            var e = t[_i]({mainType: "legend"});
            e && e[zn] && t[hr]("graph", function (t) {
                var i = t.getCategoriesData(), n = t[I](), r = n.data, a = i[K](i[xi]);
                r.filterSelf(function (t) {
                    var i = r[Ai](t), n = i[N](be);
                    if (null != n) {
                        typeof n === sn && (n = a[n]);
                        for (var o = 0; o < e[zn]; o++)if (!e[o].isSelected(n))return !1
                    }
                    return !0
                })
            }, this)
        }
    }), e("echarts/chart/graph/categoryVisual", [gr], function () {
        return function (t) {
            t[hr]("graph", function (t) {
                var e = t.get("color"), i = t.getCategoriesData(), n = t[ur](), r = {};
                i.each(function (t) {
                    r[i[xi](t)] = t;
                    var n = i[Ai](t), a = i[Si](t), o = n.get(bi) || e[a % e[zn]];
                    i[wi](t, "color", o)
                }), i.count() && n.each(function (t) {
                    var e = n[Ai](t), a = e[N](be);
                    null != a && (typeof a === er && (a = r[a]), n[Mi](t, "color", !0) || n[wi](t, "color", i[Mi](a, "color")))
                })
            })
        }
    }), e("echarts/chart/treemap/treemapLayout", [gr, vr, Be, me, "./helper", X], function (t) {
        function e(t, e, n) {
            var r = {mainType: "series", subType: "treemap", query: n};
            t[qn](r, function (t) {
                var r = e[Kn](), a = e[Yn](), o = t[Pi], s = o.size || [], l = x(_(o.width, s[0]), r), f = x(_(o[Fn], s[1]), a), m = p[Ki](t[Ji](), {
                    width: e[Kn](),
                    height: e[Yn]()
                }), y = n && n.type, b = v.retrieveTargetInfo(n, t), M = "treemapRender" === y || "treemapMove" === y ? n.rootRect : null, S = t.getViewRoot(), A = v.getPathToRoot(S);
                if ("treemapMove" !== y) {
                    var C = "treemapZoomToNode" === y ? c(t, b, S, l, f) : M ? [M.width, M[Fn]] : [l, f], T = o.sort;
                    T && "asc" !== T && "desc" !== T && (T = "desc");
                    var L = {squareRatio: o.squareRatio, sort: T, leafDepth: o.leafDepth};
                    S.hostTree.clearLayouts();
                    var k = {x: 0, y: 0, width: C[0], height: C[1], area: C[0] * C[1]};
                    S[$](k), i(S, L, !1, 0);
                    var k = S[H]();
                    w(A, function (t, e) {
                        var i = (A[e + 1] || S).getValue();
                        t[$](d[On]({dataExtent: [i, i], borderWidth: 0}, k))
                    })
                }
                var D = t[ur]().tree.root;
                D[$](u(m, M, b), !0), t.setLayoutInfo(m), h(D, new g(-m.x, -m.y, r, a), A, S, 0)
            })
        }

        function i(t, e, r, a) {
            var o, c;
            if (!t.isRemoved()) {
                var u = t[H]();
                o = u.width, c = u[Fn];
                var h = t[Jn](ie), d = h.get("borderWidth"), f = h.get("gapWidth") / 2, p = d - f, v = t[Jn]();
                t[$]({borderWidth: d}, !0), o = m(o - 2 * p, 0), c = m(c - 2 * p, 0);
                var g = o * c, x = n(t, v, g, e, r, a);
                if (x[zn]) {
                    var _ = {x: p, y: p, width: o, height: c}, w = y(o, c), b = 1 / 0, M = [];
                    M.area = 0;
                    for (var S = 0, A = x[zn]; A > S;) {
                        var C = x[S];
                        M.push(C), M.area += C[H]().area;
                        var T = s(M, w, e.squareRatio);
                        b >= T ? (S++, b = T) : (M.area -= M.pop()[H]().area, l(M, w, _, f, !1), w = y(_.width, _[Fn]), M[zn] = M.area = 0, b = 1 / 0)
                    }
                    if (M[zn] && l(M, w, _, f, !0), !r) {
                        var L = v.get("childrenVisibleMin");
                        null != L && L > g && (r = !0)
                    }
                    for (var S = 0, A = x[zn]; A > S; S++)i(x[S], e, r, a + 1)
                }
            }
        }

        function n(t, e, i, n, s, l) {
            var c = t.children || [], u = n.sort;
            "asc" !== u && "desc" !== u && (u = null);
            var h = null != n.leafDepth && n.leafDepth <= l;
            if (s && !h)return t.viewChildren = [];
            c = d[fr](c, function (t) {
                return !t.isRemoved()
            }), a(c, u);
            var f = o(e, c, u);
            if (0 === f.sum)return t.viewChildren = [];
            if (f.sum = r(e, i, f.sum, u, c), 0 === f.sum)return t.viewChildren = [];
            for (var p = 0, v = c[zn]; v > p; p++) {
                var g = c[p].getValue() / f.sum * i;
                c[p][$]({area: g})
            }
            return h && (c[zn] && t[$]({isLeafRoot: !0}, !0), c[zn] = 0), t.viewChildren = c, t[$]({dataExtent: f.dataExtent}, !0), c
        }

        function r(t, e, i, n, r) {
            if (!n)return i;
            for (var a = t.get("visibleMin"), o = r[zn], s = o, l = o - 1; l >= 0; l--) {
                var c = r["asc" === n ? o - l - 1 : l].getValue();
                a > c / i * e && (s = l, i -= c)
            }
            return "asc" === n ? r[Ln](0, o - s) : r[Ln](s, o - s), i
        }

        function a(t, e) {
            return e && t.sort(function (t, i) {
                return "asc" === e ? t.getValue() - i.getValue() : i.getValue() - t.getValue()
            }), t
        }

        function o(t, e, i) {
            for (var n = 0, r = 0, a = e[zn]; a > r; r++)n += e[r].getValue();
            var o, s = t.get("visualDimension");
            if (e && e[zn])if ("value" === s && i)o = [e[e[zn] - 1].getValue(), e[0].getValue()], "asc" === i && o[k](); else {
                var o = [1 / 0, -1 / 0];
                w(e, function (t) {
                    var e = t.getValue(s);
                    e < o[0] && (o[0] = e), e > o[1] && (o[1] = e)
                })
            } else o = [0 / 0, 0 / 0];
            return {sum: n, dataExtent: o}
        }

        function s(t, e, i) {
            for (var n, r = 0, a = 1 / 0, o = 0, s = t[zn]; s > o; o++)n = t[o][H]().area, n && (a > n && (a = n), n > r && (r = n));
            var l = t.area * t.area, c = e * e * i;
            return l ? m(c * r / l, l / (c * a)) : 1 / 0
        }

        function l(t, e, i, n, r) {
            var a = e === i.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", Fn], c = i[s[a]], u = e ? t.area / e : 0;
            (r || u > i[l[o]]) && (u = i[l[o]]);
            for (var h = 0, d = t[zn]; d > h; h++) {
                var f = t[h], p = {}, v = u ? f[H]().area / u : 0, g = p[l[o]] = m(u - 2 * n, 0), x = i[s[a]] + i[l[a]] - c, _ = h === d - 1 || v > x ? x : v, w = p[l[a]] = m(_ - 2 * n, 0);
                p[s[o]] = i[s[o]] + y(n, g / 2), p[s[a]] = c + y(n, w / 2), c += _, f[$](p, !0)
            }
            i[s[o]] += u, i[l[o]] -= u
        }

        function c(t, e, i, n, r) {
            var a = (e || {}).node, o = [n, r];
            if (!a || a === i)return o;
            for (var s, l = n * r, c = l * t[Pi].zoomToNodeRatio; s = a[B];) {
                for (var u = 0, h = s.children, d = 0, p = h[zn]; p > d; d++)u += h[d].getValue();
                var v = a.getValue();
                if (0 === v)return o;
                c *= u / v;
                var g = s[Jn](ie).get("borderWidth");
                isFinite(g) && (c += 4 * g * g + 4 * g * Math.pow(c, .5)), c > f.MAX_SAFE_INTEGER && (c = f.MAX_SAFE_INTEGER), a = s
            }
            l > c && (c = l);
            var m = Math.pow(c / l, .5);
            return [n * m, r * m]
        }

        function u(t, e, i) {
            if (e)return {x: e.x, y: e.y};
            var n = {x: 0, y: 0};
            if (!i)return n;
            var r = i.node, a = r[H]();
            if (!a)return n;
            for (var o = [a.width / 2, a[Fn] / 2], s = r; s;) {
                var l = s[H]();
                o[0] += l.x, o[1] += l.y, s = s[B]
            }
            return {x: t.width / 2 - o[0], y: t[Fn] / 2 - o[1]}
        }

        function h(t, e, i, n, r) {
            var a = t[H](), o = i[r], s = o && o === t;
            if (!(o && !s || r === i[zn] && t !== n)) {
                t[$]({isInView: !0, invisible: !s && !e.intersect(a), isAboveViewRoot: s}, !0);
                var l = new g(e.x - a.x, e.y - a.y, e.width, e[Fn]);
                w(t.viewChildren || [], function (t) {
                    h(t, l, i, n, r + 1)
                })
            }
        }

        var d = t(vr), f = t(Be), p = t(me), v = t("./helper"), g = t(X), v = t("./helper"), m = Math.max, y = Math.min, x = f[Ee], _ = d[oi], w = d.each;
        return e
    }), e("echarts/chart/graph/simpleLayout", [gr, "./simpleLayoutHelper", "./simpleLayoutEdge"], function (t) {
        var e = t("./simpleLayoutHelper"), i = t("./simpleLayoutEdge");
        return function (t) {
            t[hr]("graph", function (t) {
                var n = t.get(Ce), r = t[Ni];
                if (r && "view" !== r.type) {
                    var a = t[ur]();
                    a.each(r[Te], function (t, e, i) {
                        isNaN(t) || isNaN(e) ? a[Ve](i, [0 / 0, 0 / 0]) : a[Ve](i, r[Se]([t, e]))
                    }), i(a.graph)
                } else n && "none" !== n || e(t)
            })
        }
    }), e("echarts/chart/graph/circularLayout", [gr, "./circularLayoutHelper"], function (t) {
        var e = t("./circularLayoutHelper");
        return function (t) {
            t[hr]("graph", function (t) {
                "circular" === t.get(Ce) && e(t)
            })
        }
    }), e("echarts/chart/graph/createView", [gr, "../../coord/View", me, "zrender/core/bbox"], function (t) {
        function e(t, e, i) {
            var r = t[Ji]();
            return r.aspect = i, n[Ki](r, {width: e[Kn](), height: e[Yn]()})
        }

        var i = t("../../coord/View"), n = t(me), r = t("zrender/core/bbox");
        return function (t, n) {
            var a = [];
            return t[hr]("graph", function (t) {
                var o = t.get(Ni);
                if (!o || "view" === o) {
                    var s = new i;
                    a.push(s);
                    var l = t[ur](), c = l[K](function (t) {
                        var e = l[Ai](t);
                        return [+e.get("x"), +e.get("y")]
                    }), u = [], h = [];
                    r.fromPoints(c, u, h), h[0] - u[0] === 0 && (h[0] += 1, u[0] -= 1), h[1] - u[1] === 0 && (h[1] += 1, u[1] -= 1);
                    var d = (h[0] - u[0]) / (h[1] - u[1]), f = e(t, n, d);
                    isNaN(d) && (u = [f.x, f.y], h = [f.x + f.width, f.y + f[Fn]]);
                    var p = h[0] - u[0], v = h[1] - u[1], g = f.width, m = f[Fn];
                    s = t[Ni] = new i, s[L] = t.get("scaleLimit"), s.setBoundingRect(u[0], u[1], p, v), s.setViewRect(f.x, f.y, g, m), s.setCenter(t.get(ji)), s.setZoom(t.get("zoom"))
                }
            }), a
        }
    }), e("echarts/chart/gauge/GaugeSeries", [gr, Bi, Pe, vr], function (t) {
        var e = t(Bi), i = t(Pe), n = t(vr), r = i[On]({
            type: "series.gauge",
            getInitialData: function (t) {
                var i = new e(["value"], this), r = t.data || [];
                return n[gn](r) || (r = [r]), i[Ii](r), i
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                center: ["50%", "50%"],
                legendHoverLink: !0,
                radius: "75%",
                startAngle: 225,
                endAngle: -45,
                clockwise: !0,
                min: 0,
                max: 100,
                splitNumber: 10,
                axisLine: {show: !0, lineStyle: {color: [[.2, "#91c7ae"], [.8, "#63869e"], [1, "#c23531"]], width: 30}},
                splitLine: {show: !0, length: 30, lineStyle: {color: "#eee", width: 2, type: "solid"}},
                axisTick: {show: !0, splitNumber: 5, length: 8, lineStyle: {color: "#eee", width: 1, type: "solid"}},
                axisLabel: {show: !0, textStyle: {color: "auto"}},
                pointer: {show: !0, length: "80%", width: 8},
                itemStyle: {normal: {color: "auto"}},
                title: {show: !0, offsetCenter: [0, "-40%"], textStyle: {color: "#333", fontSize: 15}},
                detail: {
                    show: !0,
                    backgroundColor: "rgba(0,0,0,0)",
                    borderWidth: 0,
                    borderColor: "#ccc",
                    width: 100,
                    height: 40,
                    offsetCenter: [0, "40%"],
                    textStyle: {color: "auto", fontSize: 30}
                }
            }
        });
        return r
    }), e("echarts/chart/lines/linesLayout", [gr], function () {
        return function (t) {
            t[hr]("lines", function (t) {
                var e = t[Ni], i = t.fromData, n = t.toData, r = t[ur](), a = e[Te];
                i.each(a, function (t, n, r) {
                    i[Ve](r, e[Se]([t, n]))
                }), n.each(a, function (t, i, r) {
                    n[Ve](r, e[Se]([t, i]))
                }), r.each(function (t) {
                    var e, a = i[fi](t), o = n[fi](t), s = r[Ai](t).get("lineStyle.normal.curveness");
                    s > 0 && (e = [(a[0] + o[0]) / 2 - (a[1] - o[1]) * s, (a[1] + o[1]) / 2 - (o[0] - a[0]) * s]), r[Ve](t, [a, o, e])
                })
            })
        }
    }), e("echarts/chart/gauge/GaugeView", [gr, "./PointerPath", vi, Be, "../../view/Chart"], function (t) {
        function e(t, e) {
            var i = t.get(ji), n = e[Kn](), r = e[Yn](), a = Math.min(n, r), s = o(i[0], e[Kn]()), l = o(i[1], e[Yn]()), c = o(t.get(Oe), a / 2);
            return {cx: s, cy: l, r: c}
        }

        function i(t, e) {
            return e && (typeof e === er ? t = e[mn]("{value}", t) : typeof e === fn && (t = e(t))), t
        }

        var n = t("./PointerPath"), r = t(vi), a = t(Be), o = a[Ee], s = 2 * Math.PI, l = t("../../view/Chart")[On]({
            type: "gauge",
            render: function (t, i, n) {
                this.group[rn]();
                var r = t.get("axisLine.lineStyle.color"), a = e(t, n);
                this._renderMain(t, i, n, r, a)
            },
            _renderMain: function (t, e, i, n, a) {
                for (var o = this.group, l = t[Jn](T), c = l[Jn](lr), u = t.get(Fe), h = -t.get(di) / 180 * Math.PI, d = -t.get("endAngle") / 180 * Math.PI, f = (d - h) % s, p = h, v = c.get("width"), g = 0; g < n[zn]; g++) {
                    var m = Math.min(Math.max(n[g][0], 0), 1), d = h + f * m, y = new r[ui]({
                        shape: {
                            startAngle: p,
                            endAngle: d,
                            cx: a.cx,
                            cy: a.cy,
                            clockwise: u,
                            r0: a.r - v,
                            r: a.r
                        }, silent: !0
                    });
                    y[qi]({fill: n[g][1]}), y[qi](c[Ue](["color", "borderWidth", Ge])), o.add(y), p = d
                }
                var x = function (t) {
                    if (0 >= t)return n[0][1];
                    for (var e = 0; e < n[zn]; e++)if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t)return n[e][1];
                    return n[e - 1][1]
                };
                if (!u) {
                    var _ = h;
                    h = d, d = _
                }
                this._renderTicks(t, e, i, x, a, h, d, u), this._renderPointer(t, e, i, x, a, h, d, u), this._renderTitle(t, e, i, x, a), this._renderDetail(t, e, i, x, a)
            },
            _renderTicks: function (t, e, n, s, l, c, u) {
                for (var h = this.group, d = l.cx, f = l.cy, p = l.r, v = t.get("min"), g = t.get("max"), m = t[Jn]("splitLine"), y = t[Jn](C), x = t[Jn](A), _ = t.get(S), w = y.get(S), b = o(m.get(zn), p), T = o(y.get(zn), p), L = c, k = (u - c) / _, D = k / w, I = m[Jn](lr)[Ue](), P = y[Jn](lr)[Ue](), z = x[Jn](nn), V = 0; _ >= V; V++) {
                    var R = Math.cos(L), O = Math.sin(L);
                    if (m.get("show")) {
                        var E = new r.Line({
                            shape: {
                                x1: R * p + d,
                                y1: O * p + f,
                                x2: R * (p - b) + d,
                                y2: O * (p - b) + f
                            }, style: I, silent: !0
                        });
                        "auto" === I[Ne] && E[qi]({stroke: s(V / _)}), h.add(E)
                    }
                    if (x.get("show")) {
                        var B = i(a.round(V / _ * (g - v) + v), x.get(M)), N = new r.Text({
                            style: {
                                text: B,
                                x: R * (p - b - 5) + d,
                                y: O * (p - b - 5) + f,
                                fill: z[$i](),
                                textFont: z[tn](),
                                textVerticalAlign: -.4 > O ? "top" : O > .4 ? Hn : Xi,
                                textAlign: -.4 > R ? "left" : R > .4 ? "right" : ji
                            }, silent: !0
                        });
                        "auto" === N.style.fill && N[qi]({fill: s(V / _)}), h.add(N)
                    }
                    if (y.get("show") && V !== _) {
                        for (var G = 0; w >= G; G++) {
                            var R = Math.cos(L), O = Math.sin(L), Z = new r.Line({
                                shape: {
                                    x1: R * p + d,
                                    y1: O * p + f,
                                    x2: R * (p - T) + d,
                                    y2: O * (p - T) + f
                                }, silent: !0, style: P
                            });
                            "auto" === P[Ne] && Z[qi]({stroke: s((V + G / w) / _)}), h.add(Z), L += D
                        }
                        L -= D
                    } else L += k
                }
            },
            _renderPointer: function (t, e, i, s, l, c, u, h) {
                var d = [+t.get("min"), +t.get("max")], f = [c, u];
                h || (f = f[k]());
                var p = t[ur](), v = this._data, g = this.group;
                p.diff(v).add(function (e) {
                    var i = new n({shape: {angle: c}});
                    r[ei](i, {shape: {angle: a[ze](p.get("value", e), d, f, !0)}}, t), g.add(i), p[He](e, i)
                })[Gn](function (e, i) {
                    var n = v[pi](i);
                    r[ei](n, {shape: {angle: a[ze](p.get("value", e), d, f, !0)}}, t), g.add(n), p[He](e, n)
                })[En](function (t) {
                    var e = v[pi](t);
                    g[En](e)
                })[qe](), p[ne](function (t, e) {
                    var i = p[Ai](e), n = i[Jn]("pointer");
                    t[ii]({
                        x: l.cx,
                        y: l.cy,
                        width: o(n.get("width"), l.r),
                        r: o(n.get(zn), l.r)
                    }), t[ti](i[Jn](ie)[Wi]()), "auto" === t.style.fill && t[qi]("fill", s((p.get("value", e) - d[0]) / (d[1] - d[0]))), r[Ke](t, i[Jn]("itemStyle.emphasis")[Wi]())
                }), this._data = p
            },
            _renderTitle: function (t, e, i, n, a) {
                var s = t[Jn]("title");
                if (s.get("show")) {
                    var l = s[Jn](nn), c = s.get("offsetCenter"), u = a.cx + o(c[0], a.r), h = a.cy + o(c[1], a.r), d = new r.Text({
                        style: {
                            x: u,
                            y: h,
                            text: t[ur]()[xi](0),
                            fill: l[$i](),
                            textFont: l[tn](),
                            textAlign: "center",
                            textVerticalAlign: "middle"
                        }
                    });
                    this.group.add(d)
                }
            },
            _renderDetail: function (t, e, n, s, l) {
                var c = t[Jn]("detail"), u = t.get("min"), h = t.get("max");
                if (c.get("show")) {
                    var d = c[Jn](nn), f = c.get("offsetCenter"), p = l.cx + o(f[0], l.r), v = l.cy + o(f[1], l.r), g = o(c.get("width"), l.r), m = o(c.get(Fn), l.r), y = t[ur]().get("value", 0), x = new r.Rect({
                        shape: {
                            x: p - g / 2,
                            y: v - m / 2,
                            width: g,
                            height: m
                        }, style: {text: i(y, c.get(M)), fill: c.get(jn), textFill: d[$i](), textFont: d[tn]()}
                    });
                    "auto" === x.style.textFill && x[qi]("textFill", s(a[ze](y, [u, h], [0, 1], !0))), x[qi](c[Wi](["color"])), this.group.add(x)
                }
            }
        });
        return l
    }), e("echarts/ExtensionAPI", [gr, vr], function (t) {
        function e(t) {
            i.each(n, function (e) {
                this[e] = i.bind(t[e], t)
            }, this)
        }

        var i = t(vr), n = ["getDom", "getZr", Kn, Yn, Rn, "on", "off", "getDataURL", "getConnectedDataURL", Jn, "getOption"];
        return e
    }), e("echarts/model/Global", [gr, vr, "../util/model", "./Model", "./Component", "./globalDefault"], function (t) {
        function e(t, e) {
            for (var i in e)y.hasClass(i) || ("object" == typeof e[i] ? t[i] = t[i] ? c.merge(t[i], e[i], !1) : c.clone(e[i]) : null == t[i] && (t[i] = e[i]))
        }

        function i(t) {
            t = t, this[Pi] = {}, this[Pi][_] = 1, this._componentsMap = {}, this._seriesIndices = null, e(t, this._theme[Pi]), c.merge(t, x, !1), this[zi](t)
        }

        function n(t, e) {
            c[gn](e) || (e = e ? [e] : []);
            var i = {};
            return d(e, function (e) {
                i[e] = (t[e] || []).slice()
            }), i
        }

        function r(t, e) {
            var i = {};
            d(e, function (t) {
                var e = t.exist;
                e && (i[e.id] = t)
            }), d(e, function (e) {
                var n = e[Pi];
                if (c.assert(!n || null == n.id || !i[n.id] || i[n.id] === e, "id duplicates: " + (n && n.id)), n && null != n.id && (i[n.id] = e), m(n)) {
                    var r = a(t, n, e.exist);
                    e.keyInfo = {mainType: t, subType: r}
                }
            }), d(e, function (t) {
                var e = t.exist, n = t[Pi], r = t.keyInfo;
                if (m(n)) {
                    if (r.name = null != n.name ? n.name + "" : e ? e.name : "\x00-", e)r.id = e.id; else if (null != n.id)r.id = n.id + ""; else {
                        var a = 0;
                        do r.id = "\x00" + r.name + "\x00" + a++; while (i[r.id])
                    }
                    i[r.id] = t
                }
            })
        }

        function a(t, e, i) {
            var n = e.type ? e.type : i ? i.subType : y.determineSubType(t, e);
            return n
        }

        function o(t) {
            return p(t, function (t) {
                    return t.componentIndex
                }) || []
        }

        function s(t, e) {
            return e.hasOwnProperty("subType") ? f(t, function (t) {
                return t.subType === e.subType
            }) : t
        }

        function l(t) {
            if (!t._seriesIndices)throw new Error("Series has not been initialized yet.")
        }

        var c = t(vr), u = t("../util/model"), h = t("./Model"), d = c.each, f = c[fr], p = c.map, v = c[gn], g = c[vn], m = c[Bn], y = t("./Component"), x = t("./globalDefault"), _ = "\x00_ec_inner", M = h[On]({
            constructor: M,
            init: function (t, e, i, n) {
                i = i || {}, this[Pi] = null, this._theme = new h(i), this._optionManager = n
            },
            setOption: function (t, e) {
                c.assert(!(_ in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption()
            },
            resetOption: function (t) {
                var e = !1, n = this._optionManager;
                if (!t || "recreate" === t) {
                    var r = n.mountOption("recreate" === t);
                    this[Pi] && "recreate" !== t ? (this.restoreData(), this[zi](r)) : i.call(this, r), e = !0
                }
                if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) {
                    var a = n.getTimelineOption(this);
                    a && (this[zi](a), e = !0)
                }
                if (!t || "recreate" === t || "media" === t) {
                    var o = n.getMediaOption(this, this._api);
                    o[zn] && d(o, function (t) {
                        this[zi](t, e = !0)
                    }, this)
                }
                return e
            },
            mergeOption: function (t) {
                function e(e, s) {
                    var l = u[b](t[e]), h = u.mappingToExists(a[e], l);
                    r(e, h);
                    var f = n(a, s);
                    i[e] = [], a[e] = [], d(h, function (t, n) {
                        var r = t.exist, o = t[Pi];
                        if (c.assert(m(o) || r, "Empty component definition"), o) {
                            var s = y.getClass(e, t.keyInfo.subType, !0);
                            r && r instanceof s ? (r[zi](o, this), r.optionUpdated(this)) : (r = new s(o, this, this, c[On]({
                                dependentModels: f,
                                componentIndex: n
                            }, t.keyInfo)), r.optionUpdated(this))
                        } else r[zi]({}, this), r.optionUpdated(this);
                        a[e][n] = r, i[e][n] = r[Pi]
                    }, this), e === Dn && (this._seriesIndices = o(a[Dn]))
                }

                var i = this[Pi], a = this._componentsMap, s = [];
                d(t, function (t, e) {
                    null != t && (y.hasClass(e) ? s.push(e) : i[e] = null == i[e] ? c.clone(t) : c.merge(i[e], t, !0))
                }), y.topologicalTravel(s, y.getAllClassMainTypes(), e, this)
            },
            getOption: function () {
                var t = c.clone(this[Pi]);
                return d(t, function (e, i) {
                    if (y.hasClass(i)) {
                        for (var e = u[b](e), n = e[zn] - 1; n >= 0; n--)u.isIdInner(e[n]) && e[Ln](n, 1);
                        t[i] = e
                    }
                }), delete t[_], t
            },
            getTheme: function () {
                return this._theme
            },
            getComponent: function (t, e) {
                var i = this._componentsMap[t];
                return i ? i[e || 0] : void 0
            },
            queryComponents: function (t) {
                var e = t[w];
                if (!e)return [];
                var i = t.index, n = t.id, r = t.name, a = this._componentsMap[e];
                if (!a || !a[zn])return [];
                var o;
                if (null != i)v(i) || (i = [i]), o = f(p(i, function (t) {
                    return a[t]
                }), function (t) {
                    return !!t
                }); else if (null != n) {
                    var l = v(n);
                    o = f(a, function (t) {
                        return l && g(n, t.id) >= 0 || !l && t.id === n
                    })
                } else if (null != r) {
                    var c = v(r);
                    o = f(a, function (t) {
                        return c && g(r, t.name) >= 0 || !c && t.name === r
                    })
                }
                return s(o, t)
            },
            findComponents: function (t) {
                function e(t) {
                    var e = r + "Index", i = r + "Id", n = r + "Name";
                    return t && (t.hasOwnProperty(e) || t.hasOwnProperty(i) || t.hasOwnProperty(n)) ? {
                        mainType: r,
                        index: t[e],
                        id: t[i],
                        name: t[n]
                    } : null
                }

                function i(e) {
                    return t[fr] ? f(e, t[fr]) : e
                }

                var n = t.query, r = t[w], a = e(n), o = a ? this.queryComponents(a) : this._componentsMap[r];
                return i(s(o, t))
            },
            eachComponent: function (t, e, i) {
                var n = this._componentsMap;
                if (typeof t === fn)i = e, e = t, d(n, function (t, n) {
                    d(t, function (t, r) {
                        e.call(i, n, t, r)
                    })
                }); else if (c[an](t))d(n[t], e, i); else if (m(t)) {
                    var r = this[_i](t);
                    d(r, e, i)
                }
            },
            getSeriesByName: function (t) {
                var e = this._componentsMap[Dn];
                return f(e, function (e) {
                    return e.name === t
                })
            },
            getSeriesByIndex: function (t) {
                return this._componentsMap[Dn][t]
            },
            getSeriesByType: function (t) {
                var e = this._componentsMap[Dn];
                return f(e, function (e) {
                    return e.subType === t
                })
            },
            getSeries: function () {
                return this._componentsMap[Dn].slice()
            },
            eachSeries: function (t, e) {
                l(this), d(this._seriesIndices, function (i) {
                    var n = this._componentsMap[Dn][i];
                    t.call(e, n, i)
                }, this)
            },
            eachRawSeries: function (t, e) {
                d(this._componentsMap[Dn], t, e)
            },
            eachSeriesByType: function (t, e, i) {
                l(this), d(this._seriesIndices, function (n) {
                    var r = this._componentsMap[Dn][n];
                    r.subType === t && e.call(i, r, n)
                }, this)
            },
            eachRawSeriesByType: function (t, e, i) {
                return d(this.getSeriesByType(t), e, i)
            },
            isSeriesFiltered: function (t) {
                return l(this), c[vn](this._seriesIndices, t.componentIndex) < 0
            },
            filterSeries: function (t, e) {
                l(this);
                var i = f(this._componentsMap[Dn], t, e);
                this._seriesIndices = o(i)
            },
            restoreData: function () {
                var t = this._componentsMap;
                this._seriesIndices = o(t[Dn]);
                var e = [];
                d(t, function (t, i) {
                    e.push(i)
                }), y.topologicalTravel(e, y.getAllClassMainTypes(), function (e) {
                    d(t[e], function (t) {
                        t.restoreData()
                    })
                })
            }
        });
        return M
    }), e("echarts/CoordinateSystem", [gr], function () {
        function t() {
            this._coordinateSystems = []
        }

        var e = {};
        return t[ir] = {
            constructor: t, create: function (t, i) {
                var n = [];
                for (var r in e) {
                    var a = e[r][Zn](t, i);
                    a && (n = n[Gi](a))
                }
                this._coordinateSystems = n
            }, update: function (t, e) {
                for (var i = this._coordinateSystems, n = 0; n < i[zn]; n++)i[n][Gn] && i[n][Gn](t, e)
            }
        }, t[dn] = function (t, i) {
            e[t] = i
        }, t.get = function (t) {
            return e[t]
        }, t
    }), e("echarts/model/OptionManager", [gr, vr, "../util/model", "./Component"], function (t) {
        function e(t) {
            this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption
        }

        function i(t, e) {
            var i, n, r = [], a = [], o = t.timeline;
            if (t.baseOption && (n = t.baseOption), (o || t.options) && (n = n || {}, r = (t.options || []).slice()), t.media) {
                n = n || {};
                var l = t.media;
                u(l, function (t) {
                    t && t[Pi] && (t.query ? a.push(t) : i || (i = t))
                })
            }
            return n || (n = t), n.timeline || (n.timeline = o), u([n][Gi](r)[Gi](s.map(a, function (t) {
                return t[Pi]
            })), function (t) {
                u(e, function (e) {
                    e(t)
                })
            }), {baseOption: n, timelineOptions: r, mediaDefault: i, mediaList: a}
        }

        function n(t, e, i) {
            var n = {width: e, height: i, aspectratio: e / i}, a = !0;
            return s.each(t, function (t, e) {
                var i = e.match(p);
                if (i && i[1] && i[2]) {
                    var o = i[1], s = i[2][nr]();
                    r(n[s], t, o) || (a = !1)
                }
            }), a
        }

        function r(t, e, i) {
            return "min" === i ? t >= e : "max" === i ? e >= t : t === e
        }

        function a(t, e) {
            return t.join(",") === e.join(",")
        }

        function o(t, e) {
            e = e || {}, u(e, function (e, i) {
                if (null != e) {
                    var n = t[i];
                    if (c.hasClass(i)) {
                        e = l[b](e), n = l[b](n);
                        var r = l.mappingToExists(n, e);
                        t[i] = d(r, function (t) {
                            return t[Pi] && t.exist ? f(t.exist, t[Pi], !0) : t.exist || t[Pi]
                        })
                    } else t[i] = f(n, e, !0)
                }
            })
        }

        var s = t(vr), l = t("../util/model"), c = t("./Component"), u = s.each, h = s.clone, d = s.map, f = s.merge, p = /^(min|max)?(.+)$/;
        return e[ir] = {
            constructor: e, setOption: function (t, e) {
                t = h(t, !0);
                var n = this._optionBackup, r = i.call(this, t, e);
                this._newBaseOption = r.baseOption, n ? (o(n.baseOption, r.baseOption), r.timelineOptions[zn] && (n.timelineOptions = r.timelineOptions), r.mediaList[zn] && (n.mediaList = r.mediaList), r.mediaDefault && (n.mediaDefault = r.mediaDefault)) : this._optionBackup = r
            }, mountOption: function (t) {
                var e = this._optionBackup;
                return this._timelineOptions = d(e.timelineOptions, h), this._mediaList = d(e.mediaList, h), this._mediaDefault = h(e.mediaDefault), this._currentMediaIndices = [], h(t ? e.baseOption : this._newBaseOption)
            }, getTimelineOption: function (t) {
                var e, i = this._timelineOptions;
                if (i[zn]) {
                    var n = t[ve]("timeline");
                    n && (e = h(i[n.getCurrentIndex()], !0))
                }
                return e
            }, getMediaOption: function () {
                var t = this._api[Kn](), e = this._api[Yn](), i = this._mediaList, r = this._mediaDefault, o = [], s = [];
                if (!i[zn] && !r)return s;
                for (var l = 0, c = i[zn]; c > l; l++)n(i[l].query, t, e) && o.push(l);
                return !o[zn] && r && (o = [-1]), o[zn] && !a(o, this._currentMediaIndices) && (s = d(o, function (t) {
                    return h(-1 === t ? r[Pi] : i[t][Pi])
                })), this._currentMediaIndices = o, s
            }
        }, e
    }), e("echarts/model/Series", [gr, vr, "../util/format", "../util/model", "./Component"], function (t) {
        var e = t(vr), i = t("../util/format"), n = t("../util/model"), r = t("./Component"), a = i[De], o = i[ke], s = r[On]({
            type: "series.__base__",
            seriesIndex: 0,
            coordinateSystem: null,
            defaultOption: null,
            legendDataProvider: null,
            init: function (t, e, i) {
                this[bn] = this.componentIndex, this[P](t, i), this._dataBeforeProcessed = this.getInitialData(t, i), this._data = this._dataBeforeProcessed.cloneShallow()
            },
            mergeDefaultAndTheme: function (t, i) {
                e.merge(t, i.getTheme().get(this.subType)), e.merge(t, this.getDefaultOption()), n[ki](t.label, n.LABEL_OPTIONS), this.fillDataTextStyle(t.data)
            },
            mergeOption: function (t, i) {
                t = e.merge(this[Pi], t, !0), this.fillDataTextStyle(t.data);
                var n = this.getInitialData(t, i);
                n && (this._data = n, this._dataBeforeProcessed = n.cloneShallow())
            },
            fillDataTextStyle: function (t) {
                if (t)for (var e = 0; e < t[zn]; e++)t[e] && t[e].label && n[ki](t[e].label, n.LABEL_OPTIONS)
            },
            getInitialData: function () {
            },
            getData: function (t) {
                return null == t ? this._data : this._data.getLinkedData(t)
            },
            setData: function (t) {
                this._data = t
            },
            getRawData: function () {
                return this._dataBeforeProcessed
            },
            coordDimToDataDim: function (t) {
                return [t]
            },
            dataDimToCoordDim: function (t) {
                return t
            },
            getBaseAxis: function () {
                var t = this[Ni];
                return t && t[Me] && t[Me]()
            },
            formatTooltip: function (t, i) {
                var n = this._data, r = this[ye](t), s = e[gn](r) ? e.map(r, o).join(", ") : o(r), l = n[xi](t), c = n[Mi](t, "color"), u = '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + c + '"></span>', h = this.name;
                return "\x00-" === h && (h = ""), i ? u + a(this.name) + " : " + s : (h && a(h) + Le) + u + (l ? a(l) + " : " + s : s)
            },
            restoreData: function () {
                this._data = this._dataBeforeProcessed.cloneShallow()
            },
            getAxisTooltipDataIndex: null
        });
        return e.mixin(s, n.dataFormatMixin), s
    }), e("echarts/view/Component", [gr, "zrender/container/Group", "../util/component", "../util/clazz"], function (t) {
        var e = t("zrender/container/Group"), i = t("../util/component"), n = t("../util/clazz"), r = function () {
            this.group = new e, this.uid = i.getUID("viewComponent")
        };
        r[ir] = {
            constructor: r, init: function () {
            }, render: function () {
            }, dispose: function () {
            }
        };
        var a = r[ir];
        return a.updateView = a[Nn] = a.updateVisual = function () {
        }, n.enableClassExtend(r), n.enableClassManagement(r, {registerWhenExtend: !0}), r
    }), e("echarts/chart/graph/GraphView", [gr, "../helper/SymbolDraw", "../helper/LineDraw", "../../component/helper/RoamController", vi, "./adjustEdge", Ri], function (t) {
        var e = t("../helper/SymbolDraw"), i = t("../helper/LineDraw"), n = t("../../component/helper/RoamController"), r = t(vi), a = t("./adjustEdge");
        t(Ri)[hn]({
            type: "graph", init: function (t, r) {
                var a = new e, o = new i, s = this.group, l = new n(r.getZr(), s);
                s.add(a.group), s.add(o.group), this._symbolDraw = a, this._lineDraw = o, this._controller = l, this._firstRender = !0
            }, render: function (t, e, i) {
                var n = t[Ni];
                this[Qn] = t, this._nodeScaleRatio = t.get("nodeScaleRatio");
                var o = this._symbolDraw, s = this._lineDraw, l = this.group;
                if ("view" === n.type) {
                    var c = {position: n[Ui], scale: n.scale};
                    this._firstRender ? l.attr(c) : r[ei](l, c, t)
                }
                a(t[I](), this._getNodeGlobalScale(t));
                var u = t[ur]();
                o[li](u);
                var h = t.getEdgeData();
                s[li](h), this._updateNodeAndLinkScale(), this._updateController(t, i), clearTimeout(this._layoutTimeout);
                var d = t.forceLayout, f = t.get("force.layoutAnimation");
                d && this._startForceLayoutIteration(d, f), u[ne](function (t, e) {
                    var i = u[Ai](e).get(_);
                    i ? t.on("drag", function () {
                        d && (d.warmUp(), !this._layouting && this._startForceLayoutIteration(d, f), d.setFixed(e), u[Ve](e, t[Ui]))
                    }, this).on("dragend", function () {
                        d && d.setUnfixed(e)
                    }, this) : t.off("drag"), t.setDraggable(i && d)
                }, this), this._firstRender = !1
            }, _startForceLayoutIteration: function (t, e) {
                var i = this;
                !function n() {
                    t.step(function (t) {
                        i[Nn](i[Qn]), (i._layouting = !t) && (e ? i._layoutTimeout = setTimeout(n, 16) : n())
                    })
                }()
            }, _updateController: function (t, e) {
                var i = this._controller, n = this.group;
                return i.rectProvider = function () {
                    var t = n[Qi]();
                    return t[J](n[rr]), t
                }, "view" !== t[Ni].type ? void i.disable() : (i[W](t.get("roam")), i[L] = t.get("scaleLimit"), i.zoom = t[Ni].getZoom(), void i.off("pan").off("zoom").on("pan", function (i, n) {
                    e[Rn]({seriesId: t.id, type: "graphRoam", dx: i, dy: n})
                }).on("zoom", function (i, n, r) {
                    e[Rn]({
                        seriesId: t.id,
                        type: "graphRoam",
                        zoom: i,
                        originX: n,
                        originY: r
                    }), this._updateNodeAndLinkScale(), a(t[I](), this._getNodeGlobalScale(t)), this._lineDraw[Nn]()
                }, this))
            }, _updateNodeAndLinkScale: function () {
                var t = this[Qn], e = t[ur](), i = this._getNodeGlobalScale(t), n = [i, i];
                e[ne](function (t) {
                    t.attr("scale", n)
                })
            }, _getNodeGlobalScale: function (t) {
                var e = t[Ni];
                if ("view" !== e.type)return 1;
                var i = this._nodeScaleRatio, n = this.group.scale, r = n && n[0] || 1, a = e.getZoom(), o = (a - 1) * i + 1;
                return o / r
            }, updateLayout: function (t) {
                this._symbolDraw[Nn](), this._lineDraw[Nn](), a(t[I](), this._getNodeGlobalScale(t))
            }, remove: function () {
                this._symbolDraw && this._symbolDraw[En](), this._lineDraw && this._lineDraw[En]()
            }
        })
    }), e("echarts/view/Chart", [gr, "zrender/container/Group", "../util/component", "../util/clazz"], function (t) {
        function e() {
            this.group = new r, this.uid = a.getUID("viewChart")
        }

        function i(t, e) {
            if (t && (t[Pn](e), "group" === t.type))for (var n = 0; n < t.childCount(); n++)i(t[ni](n), e)
        }

        function n(t, e, n) {
            if (null != e[Mn]) {
                var r = t[pi](e[Mn]);
                i(r, n)
            } else if (e.name) {
                var a = t[x](e.name), r = t[pi](a);
                i(r, n)
            } else t[ne](function (t) {
                i(t, n)
            })
        }

        var r = t("zrender/container/Group"), a = t("../util/component"), o = t("../util/clazz");
        e[ir] = {
            type: "chart", init: function () {
            }, render: function () {
            }, highlight: function (t, e, i, r) {
                n(t[ur](), r, Ti)
            }, downplay: function (t, e, i, r) {
                n(t[ur](), r, Li)
            }, remove: function () {
                this.group[rn]()
            }, dispose: function () {
            }
        };
        var s = e[ir];
        return s.updateView = s[Nn] = s.updateVisual = function (t, e, i, n) {
            this[Tn](t, e, i, n)
        }, o.enableClassExtend(e), o.enableClassManagement(e, {registerWhenExtend: !0}), e
    }), e("echarts/util/graphic", [gr, vr, "zrender/tool/path", "zrender/graphic/Path", "zrender/tool/color", or, ar, "zrender/graphic/Gradient", "zrender/container/Group", "zrender/graphic/Image", "zrender/graphic/Text", "zrender/graphic/shape/Circle", "zrender/graphic/shape/Sector", "zrender/graphic/shape/Ring", "zrender/graphic/shape/Polygon", "zrender/graphic/shape/Polyline", "zrender/graphic/shape/Rect", "zrender/graphic/shape/Line", "zrender/graphic/shape/BezierCurve", "zrender/graphic/shape/Arc", "zrender/graphic/CompoundPath", "zrender/graphic/LinearGradient", "zrender/graphic/RadialGradient", X], function (t) {
        function e(t) {
            return null != t && "none" != t
        }

        function i(t) {
            return t instanceof M ? t : _.lift(t, -.1)
        }

        function n(t) {
            if (t.__hoverStlDirty) {
                var n = t.style[Ne], r = t.style.fill, a = t.__hoverStl;
                a.fill = a.fill || (e(r) ? i(r) : null), a[Ne] = a[Ne] || (e(n) ? i(n) : null);
                var o = {};
                for (var s in a)a.hasOwnProperty(s) && (o[s] = t.style[s]);
                t.__normalStl = o, t.__hoverStlDirty = !1
            }
        }

        function r(t) {
            t.__isHover || (n(t), t[qi](t.__hoverStl), t.z2 += 1, t.__isHover = !0)
        }

        function a(t) {
            if (t.__isHover) {
                var e = t.__normalStl;
                e && t[qi](e), t.z2 -= 1, t.__isHover = !1
            }
        }

        function o(t) {
            "group" === t.type ? t[yn](function (t) {
                "group" !== t.type && r(t)
            }) : r(t)
        }

        function s(t) {
            "group" === t.type ? t[yn](function (t) {
                "group" !== t.type && a(t)
            }) : a(t)
        }

        function l(t, e) {
            t.__hoverStl = t[$e] || e || {}, t.__hoverStlDirty = !0, t.__isHover && n(t)
        }

        function c() {
            !this.__isEmphasis && o(this)
        }

        function u() {
            !this.__isEmphasis && s(this)
        }

        function h() {
            this.__isEmphasis = !0, o(this)
        }

        function d() {
            this.__isEmphasis = !1, s(this)
        }

        function f(t, e, i, n, r, a) {
            typeof r === fn && (a = r, r = null);
            var o = t ? "Update" : "", s = n && n[N]("animationDuration" + o), l = n && n[N]("animationEasing" + o), c = n && n[N]("animationDelay" + o);
            typeof c === fn && (c = c(r)), n && n[N](Je) ? e.animateTo(i, s, c || 0, l, a) : (e.attr(i), a && a())
        }

        var p = t(vr), v = t("zrender/tool/path"), g = Math.round, x = t("zrender/graphic/Path"), _ = t("zrender/tool/color"), w = t(or), b = t(ar), M = t("zrender/graphic/Gradient"), S = {};
        return S.Group = t("zrender/container/Group"), S.Image = t("zrender/graphic/Image"), S.Text = t("zrender/graphic/Text"), S[y] = t("zrender/graphic/shape/Circle"), S[ui] = t("zrender/graphic/shape/Sector"), S.Ring = t("zrender/graphic/shape/Ring"), S[R] = t("zrender/graphic/shape/Polygon"), S[ci] = t("zrender/graphic/shape/Polyline"), S.Rect = t("zrender/graphic/shape/Rect"), S.Line = t("zrender/graphic/shape/Line"), S.BezierCurve = t("zrender/graphic/shape/BezierCurve"), S.Arc = t("zrender/graphic/shape/Arc"), S.CompoundPath = t("zrender/graphic/CompoundPath"), S.LinearGradient = t("zrender/graphic/LinearGradient"), S.RadialGradient = t("zrender/graphic/RadialGradient"), S.BoundingRect = t(X), S.extendShape = function (t) {
            return x[On](t)
        }, S.extendPath = function (t, e) {
            return v.extendFromString(t, e)
        }, S.makePath = function (t, e, i, n) {
            var r = v.createFromString(t, e), a = r[Qi]();
            if (i) {
                var o = a.width / a[Fn];
                if (n === ji) {
                    var s, l = i[Fn] * o;
                    l <= i.width ? s = i[Fn] : (l = i.width, s = l / o);
                    var c = i.x + i.width / 2, u = i.y + i[Fn] / 2;
                    i.x = c - l / 2, i.y = u - s / 2, i.width = l, i[Fn] = s
                }
                this.resizePath(r, i)
            }
            return r
        }, S.mergePath = v.mergePath, S.resizePath = function (t, e) {
            if (t[J]) {
                var i = t[Qi](), n = i.calculateTransform(e);
                t[J](n)
            }
        }, S.subPixelOptimizeLine = function (t) {
            var e = S.subPixelOptimize, i = t.shape, n = t.style[m];
            return g(2 * i.x1) === g(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), g(2 * i.y1) === g(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t
        }, S.subPixelOptimizeRect = function (t) {
            var e = S.subPixelOptimize, i = t.shape, n = t.style[m], r = i.x, a = i.y, o = i.width, s = i[Fn];
            return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(r + o, n, !1) - i.x, 0 === o ? 0 : 1), i[Fn] = Math.max(e(a + s, n, !1) - i.y, 0 === s ? 0 : 1), t
        }, S.subPixelOptimize = function (t, e, i) {
            var n = g(2 * t);
            return (n + g(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
        }, S[Ke] = function (t, e) {
            "group" === t.type ? t[yn](function (t) {
                "group" !== t.type && l(t, e)
            }) : l(t, e), t.on(Cn, c).on(An, u), t.on(Ti, h).on(Li, d)
        }, S.setText = function (t, e, i) {
            var n = e[N](Ui) || si, r = n[vn](si) >= 0 ? "white" : i, a = e[Jn](nn);
            p[On](t, {textDistance: e[N]("distance") || 5, textFont: a[tn](), textPosition: n, textFill: a[$i]() || r})
        }, S[ei] = p.curry(f, !0), S[Ze] = p.curry(f, !1), S.getTransform = function (t, e) {
            for (var i = w.identity([]); t && t !== e;)w.mul(i, t.getLocalTransform(), i), t = t[U];
            return i
        }, S[J] = function (t, e, i) {
            return i && (e = w.invert([], e)), b[J]([], t, e)
        }, S.transformDirection = function (t, e, i) {
            var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]), r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]), a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : t === Hn ? r : 0];
            return a = S[J](a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? Hn : "top"
        }, S
    }), e("zrender/tool/color", [gr], function () {
        function t(t) {
            return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
        }

        function e(t) {
            return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t
        }

        function i(t) {
            return 0 > t ? 0 : t > 1 ? 1 : t
        }

        function n(e) {
            return t(e[zn] && "%" === e.charAt(e[zn] - 1) ? parseFloat(e) / 100 * 255 : parseInt(e, 10))
        }

        function r(t) {
            return i(t[zn] && "%" === t.charAt(t[zn] - 1) ? parseFloat(t) / 100 : parseFloat(t))
        }

        function a(t, e, i) {
            return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t
        }

        function o(t, e, i) {
            return t + (e - t) * i
        }

        function s(t) {
            if (t) {
                t += "";
                var e = t[mn](/ /g, "")[nr]();
                if (e in m)return m[e].slice();
                if ("#" !== e.charAt(0)) {
                    var i = e[vn]("("), a = e[vn](")");
                    if (-1 !== i && a + 1 === e[zn]) {
                        var o = e.substr(0, i), s = e.substr(i + 1, a - (i + 1)).split(","), c = 1;
                        switch (o) {
                            case"rgba":
                                if (4 !== s[zn])return;
                                c = r(s.pop());
                            case"rgb":
                                if (3 !== s[zn])return;
                                return [n(s[0]), n(s[1]), n(s[2]), c];
                            case"hsla":
                                if (4 !== s[zn])return;
                                return s[3] = r(s[3]), l(s);
                            case"hsl":
                                if (3 !== s[zn])return;
                                return l(s);
                            default:
                                return
                        }
                    }
                } else {
                    if (4 === e[zn]) {
                        var u = parseInt(e.substr(1), 16);
                        if (!(u >= 0 && 4095 >= u))return;
                        return [(3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1]
                    }
                    if (7 === e[zn]) {
                        var u = parseInt(e.substr(1), 16);
                        if (!(u >= 0 && 16777215 >= u))return;
                        return [(16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1]
                    }
                }
            }
        }

        function l(e) {
            var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = r(e[1]), o = r(e[2]), s = .5 >= o ? o * (n + 1) : o + n - o * n, l = 2 * o - s, c = [t(255 * a(l, s, i + 1 / 3)), t(255 * a(l, s, i)), t(255 * a(l, s, i - 1 / 3))];
            return 4 === e[zn] && (c[3] = e[3]), c
        }

        function c(t) {
            if (t) {
                var e, i, n = t[0] / 255, r = t[1] / 255, a = t[2] / 255, o = Math.min(n, r, a), s = Math.max(n, r, a), l = s - o, c = (s + o) / 2;
                if (0 === l)e = 0, i = 0; else {
                    i = .5 > c ? l / (s + o) : l / (2 - s - o);
                    var u = ((s - n) / 6 + l / 2) / l, h = ((s - r) / 6 + l / 2) / l, d = ((s - a) / 6 + l / 2) / l;
                    n === s ? e = d - h : r === s ? e = 1 / 3 + u - d : a === s && (e = 2 / 3 + h - u), 0 > e && (e += 1), e > 1 && (e -= 1)
                }
                var f = [360 * e, i, c];
                return null != t[3] && f.push(t[3]), f
            }
        }

        function u(t, e) {
            var i = s(t);
            if (i) {
                for (var n = 0; 3 > n; n++)i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0;
                return g(i, 4 === i[zn] ? "rgba" : "rgb")
            }
        }

        function h(t) {
            var e = s(t);
            return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0
        }

        function d(e, i, n) {
            if (i && i[zn] && e >= 0 && 1 >= e) {
                n = n || [0, 0, 0, 0];
                var r = e * (i[zn] - 1), a = Math.floor(r), s = Math.ceil(r), l = i[a], c = i[s], u = r - a;
                return n[0] = t(o(l[0], c[0], u)), n[1] = t(o(l[1], c[1], u)), n[2] = t(o(l[2], c[2], u)), n[3] = t(o(l[3], c[3], u)), n
            }
        }

        function f(e, n, r) {
            if (n && n[zn] && e >= 0 && 1 >= e) {
                var a = e * (n[zn] - 1), l = Math.floor(a), c = Math.ceil(a), u = s(n[l]), h = s(n[c]), d = a - l, f = g([t(o(u[0], h[0], d)), t(o(u[1], h[1], d)), t(o(u[2], h[2], d)), i(o(u[3], h[3], d))], "rgba");
                return r ? {color: f, leftIndex: l, rightIndex: c, value: a} : f
            }
        }

        function p(t, i, n, a) {
            return t = s(t), t ? (t = c(t), null != i && (t[0] = e(i)), null != n && (t[1] = r(n)), null != a && (t[2] = r(a)), g(l(t), "rgba")) : void 0
        }

        function v(t, e) {
            return t = s(t), t && null != e ? (t[3] = i(e), g(t, "rgba")) : void 0
        }

        function g(t, e) {
            return ("rgb" === e || "hsv" === e || "hsl" === e) && (t = t.slice(0, 3)), e + "(" + t.join(",") + ")"
        }

        var m = {
            transparent: [0, 0, 0, 0],
            aliceblue: [240, 248, 255, 1],
            antiquewhite: [250, 235, 215, 1],
            aqua: [0, 255, 255, 1],
            aquamarine: [127, 255, 212, 1],
            azure: [240, 255, 255, 1],
            beige: [245, 245, 220, 1],
            bisque: [255, 228, 196, 1],
            black: [0, 0, 0, 1],
            blanchedalmond: [255, 235, 205, 1],
            blue: [0, 0, 255, 1],
            blueviolet: [138, 43, 226, 1],
            brown: [165, 42, 42, 1],
            burlywood: [222, 184, 135, 1],
            cadetblue: [95, 158, 160, 1],
            chartreuse: [127, 255, 0, 1],
            chocolate: [210, 105, 30, 1],
            coral: [255, 127, 80, 1],
            cornflowerblue: [100, 149, 237, 1],
            cornsilk: [255, 248, 220, 1],
            crimson: [220, 20, 60, 1],
            cyan: [0, 255, 255, 1],
            darkblue: [0, 0, 139, 1],
            darkcyan: [0, 139, 139, 1],
            darkgoldenrod: [184, 134, 11, 1],
            darkgray: [169, 169, 169, 1],
            darkgreen: [0, 100, 0, 1],
            darkgrey: [169, 169, 169, 1],
            darkkhaki: [189, 183, 107, 1],
            darkmagenta: [139, 0, 139, 1],
            darkolivegreen: [85, 107, 47, 1],
            darkorange: [255, 140, 0, 1],
            darkorchid: [153, 50, 204, 1],
            darkred: [139, 0, 0, 1],
            darksalmon: [233, 150, 122, 1],
            darkseagreen: [143, 188, 143, 1],
            darkslateblue: [72, 61, 139, 1],
            darkslategray: [47, 79, 79, 1],
            darkslategrey: [47, 79, 79, 1],
            darkturquoise: [0, 206, 209, 1],
            darkviolet: [148, 0, 211, 1],
            deeppink: [255, 20, 147, 1],
            deepskyblue: [0, 191, 255, 1],
            dimgray: [105, 105, 105, 1],
            dimgrey: [105, 105, 105, 1],
            dodgerblue: [30, 144, 255, 1],
            firebrick: [178, 34, 34, 1],
            floralwhite: [255, 250, 240, 1],
            forestgreen: [34, 139, 34, 1],
            fuchsia: [255, 0, 255, 1],
            gainsboro: [220, 220, 220, 1],
            ghostwhite: [248, 248, 255, 1],
            gold: [255, 215, 0, 1],
            goldenrod: [218, 165, 32, 1],
            gray: [128, 128, 128, 1],
            green: [0, 128, 0, 1],
            greenyellow: [173, 255, 47, 1],
            grey: [128, 128, 128, 1],
            honeydew: [240, 255, 240, 1],
            hotpink: [255, 105, 180, 1],
            indianred: [205, 92, 92, 1],
            indigo: [75, 0, 130, 1],
            ivory: [255, 255, 240, 1],
            khaki: [240, 230, 140, 1],
            lavender: [230, 230, 250, 1],
            lavenderblush: [255, 240, 245, 1],
            lawngreen: [124, 252, 0, 1],
            lemonchiffon: [255, 250, 205, 1],
            lightblue: [173, 216, 230, 1],
            lightcoral: [240, 128, 128, 1],
            lightcyan: [224, 255, 255, 1],
            lightgoldenrodyellow: [250, 250, 210, 1],
            lightgray: [211, 211, 211, 1],
            lightgreen: [144, 238, 144, 1],
            lightgrey: [211, 211, 211, 1],
            lightpink: [255, 182, 193, 1],
            lightsalmon: [255, 160, 122, 1],
            lightseagreen: [32, 178, 170, 1],
            lightskyblue: [135, 206, 250, 1],
            lightslategray: [119, 136, 153, 1],
            lightslategrey: [119, 136, 153, 1],
            lightsteelblue: [176, 196, 222, 1],
            lightyellow: [255, 255, 224, 1],
            lime: [0, 255, 0, 1],
            limegreen: [50, 205, 50, 1],
            linen: [250, 240, 230, 1],
            magenta: [255, 0, 255, 1],
            maroon: [128, 0, 0, 1],
            mediumaquamarine: [102, 205, 170, 1],
            mediumblue: [0, 0, 205, 1],
            mediumorchid: [186, 85, 211, 1],
            mediumpurple: [147, 112, 219, 1],
            mediumseagreen: [60, 179, 113, 1],
            mediumslateblue: [123, 104, 238, 1],
            mediumspringgreen: [0, 250, 154, 1],
            mediumturquoise: [72, 209, 204, 1],
            mediumvioletred: [199, 21, 133, 1],
            midnightblue: [25, 25, 112, 1],
            mintcream: [245, 255, 250, 1],
            mistyrose: [255, 228, 225, 1],
            moccasin: [255, 228, 181, 1],
            navajowhite: [255, 222, 173, 1],
            navy: [0, 0, 128, 1],
            oldlace: [253, 245, 230, 1],
            olive: [128, 128, 0, 1],
            olivedrab: [107, 142, 35, 1],
            orange: [255, 165, 0, 1],
            orangered: [255, 69, 0, 1],
            orchid: [218, 112, 214, 1],
            palegoldenrod: [238, 232, 170, 1],
            palegreen: [152, 251, 152, 1],
            paleturquoise: [175, 238, 238, 1],
            palevioletred: [219, 112, 147, 1],
            papayawhip: [255, 239, 213, 1],
            peachpuff: [255, 218, 185, 1],
            peru: [205, 133, 63, 1],
            pink: [255, 192, 203, 1],
            plum: [221, 160, 221, 1],
            powderblue: [176, 224, 230, 1],
            purple: [128, 0, 128, 1],
            red: [255, 0, 0, 1],
            rosybrown: [188, 143, 143, 1],
            royalblue: [65, 105, 225, 1],
            saddlebrown: [139, 69, 19, 1],
            salmon: [250, 128, 114, 1],
            sandybrown: [244, 164, 96, 1],
            seagreen: [46, 139, 87, 1],
            seashell: [255, 245, 238, 1],
            sienna: [160, 82, 45, 1],
            silver: [192, 192, 192, 1],
            skyblue: [135, 206, 235, 1],
            slateblue: [106, 90, 205, 1],
            slategray: [112, 128, 144, 1],
            slategrey: [112, 128, 144, 1],
            snow: [255, 250, 250, 1],
            springgreen: [0, 255, 127, 1],
            steelblue: [70, 130, 180, 1],
            tan: [210, 180, 140, 1],
            teal: [0, 128, 128, 1],
            thistle: [216, 191, 216, 1],
            tomato: [255, 99, 71, 1],
            turquoise: [64, 224, 208, 1],
            violet: [238, 130, 238, 1],
            wheat: [245, 222, 179, 1],
            white: [255, 255, 255, 1],
            whitesmoke: [245, 245, 245, 1],
            yellow: [255, 255, 0, 1],
            yellowgreen: [154, 205, 50, 1]
        };
        return {
            parse: s,
            lift: u,
            toHex: h,
            fastMapToColor: d,
            mapToColor: f,
            modifyHSL: p,
            modifyAlpha: v,
            stringify: g
        }
    }), e("echarts/chart/graph/edgeVisual", [gr], function () {
        function t(t) {
            return t instanceof Array || (t = [t, t]), t
        }

        return function (e) {
            e[hr]("graph", function (e) {
                var i = e.getEdgeData(), n = t(e.get("edgeSymbol")), r = t(e.get("edgeSymbolSize"));
                i[cr]("fromSymbol", n && n[0]), i[cr]("toSymbol", n && n[1]), i[cr]("fromSymbolSize", r && r[0]), i[cr]("toSymbolSize", r && r[1]), i[cr]("color", e.get("lineStyle.normal.color")), i.each(function (e) {
                    var n = i[Ai](e), r = t(n[N](_e, !0)), a = t(n[N](xe, !0));
                    r[0] && i[wi](e, "fromSymbol", r[0]), r[1] && i[wi](e, "toSymbol", r[1]), a[0] && i[wi](e, "fromSymbolSize", a[0]), a[1] && i[wi](e, "toSymbolSize", a[1])
                })
            })
        }
    }), e("echarts/chart/graph/forceLayout", [gr, "./forceHelper", Be, "./simpleLayoutHelper", "./circularLayoutHelper", ar], function (t) {
        var e = t("./forceHelper"), i = t(Be), n = t("./simpleLayoutHelper"), r = t("./circularLayoutHelper"), a = t(ar);
        return function (t) {
            t[hr]("graph", function (t) {
                var o = t[Ni];
                if (!o || "view" === o.type)if ("force" === t.get(Ce)) {
                    var s = t.preservedPoints || {}, l = t[I](), c = l.data, u = l.edgeData, h = t[Jn]("force"), d = h.get("initLayout");
                    t.preservedPoints ? c.each(function (t) {
                        var e = c.getId(t);
                        c[Ve](t, s[e] || [0 / 0, 0 / 0])
                    }) : d && "none" !== d ? "circular" === d && r(t) : n(t);
                    var f = c[Re]("value"), p = h.get("repulsion"), v = h.get("edgeLength"), g = c[K]("value", function (t, e) {
                        var n = c[fi](e), r = i[ze](t, f, [0, p]) || p / 2;
                        return {w: r, rep: r, p: !n || isNaN(n[0]) || isNaN(n[1]) ? null : n}
                    }), m = u[K]("value", function (t, e) {
                        var i = l.getEdgeByIndex(e);
                        return {
                            n1: g[i.node1[Mn]],
                            n2: g[i.node2[Mn]],
                            d: v,
                            curveness: i[Jn]().get("lineStyle.normal.curveness") || 0
                        }
                    }), o = t[Ni], y = o[Qi](), x = e(g, m, {rect: y, gravity: h.get("gravity")}), _ = x.step;
                    x.step = function (t) {
                        for (var e = 0, i = g[zn]; i > e; e++)g[e].fixed && a.copy(g[e].p, l.getNodeByIndex(e)[H]());
                        _(function (e, i, n) {
                            for (var r = 0, a = e[zn]; a > r; r++)e[r].fixed || l.getNodeByIndex(r)[$](e[r].p), s[c.getId(r)] = e[r].p;
                            for (var r = 0, a = i[zn]; a > r; r++) {
                                var o = i[r], u = o.n1.p, h = o.n2.p, d = [u, h];
                                o.curveness > 0 && d.push([(u[0] + h[0]) / 2 - (u[1] - h[1]) * o.curveness, (u[1] + h[1]) / 2 - (h[0] - u[0]) * o.curveness]), l.getEdgeByIndex(r)[$](d)
                            }
                            t && t(n)
                        })
                    }, t.forceLayout = x, t.preservedPoints = s, x.step()
                } else t.forceLayout = null
            })
        }
    }), e("echarts/model/Component", [gr, "./Model", vr, "../util/component", "../util/clazz", "../util/layout", "./mixin/boxLayout"], function (t) {
        function e(t) {
            var e = [];
            return n.each(l.getClassesByMainType(t), function (t) {
                r.apply(e, t[ir].dependencies || [])
            }), n.map(e, function (t) {
                return o.parseClassType(t).main
            })
        }

        var i = t("./Model"), n = t(vr), r = Array[ir].push, a = t("../util/component"), o = t("../util/clazz"), s = t("../util/layout"), l = i[On]({
            type: "component",
            id: "",
            name: "",
            mainType: "",
            subType: "",
            componentIndex: 0,
            defaultOption: null,
            ecModel: null,
            dependentModels: [],
            uid: null,
            layoutMode: null,
            init: function () {
                this[P](this[Pi], this[j])
            },
            mergeDefaultAndTheme: function (t, e) {
                var i = this.layoutMode, r = i ? s.getLayoutParams(t) : {}, a = e.getTheme();
                n.merge(t, a.get(this[w])), n.merge(t, this.getDefaultOption()), i && s.mergeLayoutParam(t, r, i)
            },
            mergeOption: function (t) {
                n.merge(this[Pi], t, !0);
                var e = this.layoutMode;
                e && s.mergeLayoutParam(this[Pi], t, e)
            },
            optionUpdated: function () {
            },
            getDefaultOption: function () {
                if (!this.hasOwnProperty("__defaultOption")) {
                    for (var t = [], e = this.constructor; e;) {
                        var i = e[ir].defaultOption;
                        i && t.push(i), e = e.superClass
                    }
                    for (var r = {}, a = t[zn] - 1; a >= 0; a--)r = n.merge(r, t[a], !0);
                    this.__defaultOption = r
                }
                return this.__defaultOption
            }
        });
        return o.enableClassExtend(l, function (t, e, i, r) {
            n[On](this, r), this.uid = a.getUID("componentModel")
        }), o.enableClassManagement(l, {registerWhenExtend: !0}), a.enableSubTypeDefaulter(l), a.enableTopologicalTravel(l, e), n.mixin(l, t("./mixin/boxLayout")), l
    }), e("echarts/preprocessor/backwardCompat", [gr, vr, "./helper/compatStyle"], function (t) {
        function e(t, e) {
            e = e.split(",");
            for (var i = t, n = 0; n < e[zn] && (i = i && i[e[n]], null != i); n++);
            return i
        }

        function i(t, e, i, n) {
            e = e.split(",");
            for (var r, a = t, o = 0; o < e[zn] - 1; o++)r = e[o], null == a[r] && (a[r] = {}), a = a[r];
            (n || null == a[e[o]]) && (a[e[o]] = i)
        }

        function n(t) {
            c(o, function (e) {
                e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]])
            })
        }

        var r = t(vr), a = t("./helper/compatStyle"), o = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", Hn]], s = ["grid", "geo", g, "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], l = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", g, "pie", "radar", "sankey", "scatter", "treemap"], c = r.each;
        return function (t) {
            c(t[Dn], function (t) {
                if (r[Bn](t)) {
                    var o = t.type;
                    if (a(t), ("pie" === o || "gauge" === o) && null != t.clockWise && (t[Fe] = t.clockWise), "gauge" === o) {
                        var s = e(t, "pointer.color");
                        null != s && i(t, bi, s)
                    }
                    for (var c = 0; c < l[zn]; c++)if (l[c] === t.type) {
                        n(t);
                        break
                    }
                }
            }), t.dataRange && (t.visualMap = t.dataRange), c(s, function (e) {
                var i = t[e];
                i && (r[gn](i) || (i = [i]), c(i, function (t) {
                    n(t)
                }))
            })
        }
    }), e("echarts/util/number", [gr], function () {
        function t(t) {
            return t[mn](/^\s+/, "")[mn](/\s+$/, "")
        }

        var e = {}, i = 1e-4;
        return e[ze] = function (t, e, i, n) {
            var r = e[1] - e[0], a = i[1] - i[0];
            if (0 === r)return 0 === a ? i[0] : (i[0] + i[1]) / 2;
            if (n)if (r > 0) {
                if (t <= e[0])return i[0];
                if (t >= e[1])return i[1]
            } else {
                if (t >= e[0])return i[0];
                if (t <= e[1])return i[1]
            } else {
                if (t === e[0])return i[0];
                if (t === e[1])return i[1]
            }
            return (t - e[0]) / r * a + i[0]
        }, e[Ee] = function (e, i) {
            switch (e) {
                case ji:
                case Xi:
                    e = "50%";
                    break;
                case"left":
                case"top":
                    e = "0%";
                    break;
                case"right":
                case Hn:
                    e = "100%"
            }
            return typeof e === er ? t(e).match(/%$/) ? parseFloat(e) / 100 * i : parseFloat(e) : null == e ? 0 / 0 : +e
        }, e.round = function (t) {
            return +(+t)[Di](10)
        }, e.asc = function (t) {
            return t.sort(function (t, e) {
                return t - e
            }), t
        }, e.getPrecision = function (t) {
            if (isNaN(t))return 0;
            for (var e = 1, i = 0; Math.round(t * e) / e !== t;)e *= 10, i++;
            return i
        }, e.getPixelPrecision = function (t, e) {
            var i = Math.log, n = Math.LN10, r = Math.floor(i(t[1] - t[0]) / n), a = Math.round(i(Math.abs(e[1] - e[0])) / n);
            return Math.max(-r + a, 0)
        }, e.MAX_SAFE_INTEGER = 9007199254740991, e.remRadian = function (t) {
            var e = 2 * Math.PI;
            return (t % e + e) % e
        }, e.isRadianAroundZero = function (t) {
            return t > -i && i > t
        }, e.parseDate = function (t) {
            return t instanceof Date ? t : new Date(typeof t === er ? t[mn](/-/g, "/") : Math.round(t))
        }, e.quantity = function (t) {
            return Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
        }, e.nice = function (t, i) {
            var n, r = e.quantity(t), a = t / r;
            return n = i ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, n * r
        }, e
    }), e("zrender/zrender", [gr, "./core/guid", "./core/env", "./Handler", "./Storage", "./animation/Animation", "./Painter"], function (t) {
        function e(t) {
            delete c[t]
        }

        var i = t("./core/guid"), n = t("./core/env"), r = t("./Handler"), a = t("./Storage"), o = t("./animation/Animation"), s = !n[Xn], l = {canvas: t("./Painter")}, c = {}, u = {};
        u.version = "3.1.0", u.init = function (t, e) {
            var n = new h(i(), t, e);
            return c[n.id] = n, n
        }, u[kn] = function (t) {
            if (t)t[kn](); else {
                for (var e in c)c[e][kn]();
                c = {}
            }
            return u
        }, u.getInstance = function (t) {
            return c[t]
        }, u.registerPainter = function (t, e) {
            l[t] = e
        };
        var h = function (t, e, i) {
            i = i || {}, this.dom = e, this.id = t;
            var c = this, u = new a, h = i.renderer;
            if (s) {
                if (!l.vml)throw new Error("You need to require 'zrender/vml/vml' to support IE8");
                h = "vml"
            } else h && l[h] || (h = tr);
            var d = new l[h](e, u, i);
            this.storage = u, this.painter = d, n.node || (this.handler = new r(d.getViewportRoot(), u, d)), this[Je] = new o({
                stage: {
                    update: function () {
                        c._needsRefresh && c.refreshImmediately()
                    }
                }
            }), this[Je].start(), this._needsRefresh;
            var f = u.delFromMap, p = u.addToMap;
            u.delFromMap = function (t) {
                var e = u.get(t);
                f.call(u, t), e && e.removeSelfFromZr(c)
            }, u.addToMap = function (t) {
                p.call(u, t), t.addSelfToZr(c)
            }
        };
        return h[ir] = {
            constructor: h, getId: function () {
                return this.id
            }, add: function (t) {
                this.storage.addRoot(t), this._needsRefresh = !0
            }, remove: function (t) {
                this.storage.delRoot(t), this._needsRefresh = !0
            }, configLayer: function (t, e) {
                this.painter.configLayer(t, e), this._needsRefresh = !0
            }, refreshImmediately: function () {
                this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1
            }, refresh: function () {
                this._needsRefresh = !0
            }, resize: function () {
                this.painter[$n](), this.handler && this.handler[$n]()
            }, clearAnimation: function () {
                this[Je].clear()
            }, getWidth: function () {
                return this.painter[Kn]()
            }, getHeight: function () {
                return this.painter[Yn]()
            }, pathToImage: function (t, e, n) {
                var r = i();
                return this.painter.pathToImage(r, t, e, n)
            }, setDefaultCursorStyle: function (t) {
                this.handler.setDefaultCursorStyle(t)
            }, on: function (t, e, i) {
                this.handler && this.handler.on(t, e, i)
            }, off: function (t, e) {
                this.handler && this.handler.off(t, e)
            }, trigger: function (t, e) {
                this.handler && this.handler[Pn](t, e)
            }, clear: function () {
                this.storage.delRoot(), this.painter.clear()
            }, dispose: function () {
                this[Je].stop(), this.clear(), this.storage[kn](), this.painter[kn](), this.handler && this.handler[kn](), this[Je] = this.storage = this.painter = this.handler = null, e(this.id)
            }
        }, u
    }), e(sr, [], function () {
        function t(t) {
            var e = {}, i = {}, n = t.match(/Web[kK]it[\/]{0,1}([\d.]+)/), r = t.match(/(Android);?[\s\/]+([\d.]+)?/), a = t.match(/(iPad).*OS\s([\d_]+)/), o = t.match(/(iPod)(.*OS\s([\d_]+))?/), s = !a && t.match(/(iPhone\sOS)\s([\d_]+)/), l = t.match(/(webOS|hpwOS)[\s\/]([\d.]+)/), c = l && t.match(/TouchPad/), u = t.match(/Kindle\/([\d.]+)/), h = t.match(/Silk\/([\d._]+)/), d = t.match(/(BlackBerry).*Version\/([\d.]+)/), f = t.match(/(BB10).*Version\/([\d.]+)/), p = t.match(/(RIM\sTablet\sOS)\s([\d.]+)/), v = t.match(/PlayBook/), g = t.match(/Chrome\/([\d.]+)/) || t.match(/CriOS\/([\d.]+)/), m = t.match(/Firefox\/([\d.]+)/), y = n && t.match(/Mobile\//) && !g, x = t.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !g, _ = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/), w = t.match(/Edge\/([\d.]+)/);
            return (i.webkit = !!n) && (i.version = n[1]), r && (e.android = !0, e.version = r[2]), s && !o && (e.ios = e.iphone = !0, e.version = s[2][mn](/_/g, ".")), a && (e.ios = e.ipad = !0, e.version = a[2][mn](/_/g, ".")), o && (e.ios = e.ipod = !0, e.version = o[3] ? o[3][mn](/_/g, ".") : null), l && (e.webos = !0, e.version = l[2]), c && (e.touchpad = !0), d && (e.blackberry = !0, e.version = d[2]), f && (e.bb10 = !0, e.version = f[2]), p && (e.rimtabletos = !0, e.version = p[2]), v && (i.playbook = !0), u && (e.kindle = !0, e.version = u[1]), h && (i.silk = !0, i.version = h[1]), !h && e.android && t.match(/Kindle Fire/) && (i.silk = !0), g && (i.chrome = !0, i.version = g[1]), m && (i.firefox = !0, i.version = m[1]), _ && (i.ie = !0, i.version = _[1]), y && (t.match(/Safari/) || e.ios) && (i.safari = !0), x && (i.webview = !0), _ && (i.ie = !0, i.version = _[1]), w && (i.edge = !0, i.version = w[1]), e.tablet = !!(a || v || r && !t.match(/Mobile/) || m && t.match(/Tablet/) || _ && !t.match(/Phone/) && t.match(/Touch/)), e.phone = !(e.tablet || e.ipod || !(r || s || l || d || f || g && t.match(/Android/) || g && t.match(/CriOS\/([\d.]+)/) || m && t.match(/Mobile/) || _ && t.match(/Touch/))), {
                browser: i,
                os: e,
                node: !1,
                canvasSupported: document[Fi](tr)[Zi] ? !0 : !1,
                touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge,
                pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 10)
            }
        }

        var e = {};
        return e = typeof navigator === v ? {
            browser: {},
            os: {},
            node: !0,
            canvasSupported: !0
        } : t(navigator.userAgent)
    }), e("zrender/mixin/Eventful", [gr, p], function (t) {
        var e = Array[ir].slice, i = t(p), n = i[vn], r = function () {
            this._$handlers = {}
        };
        return r[ir] = {
            constructor: r, one: function (t, e, i) {
                var r = this._$handlers;
                return e && t ? (r[t] || (r[t] = []), n(r[t], t) >= 0 ? this : (r[t].push({
                    h: e,
                    one: !0,
                    ctx: i || this
                }), this)) : this
            }, on: function (t, e, i) {
                var n = this._$handlers;
                return e && t ? (n[t] || (n[t] = []), n[t].push({h: e, one: !1, ctx: i || this}), this) : this
            }, isSilent: function (t) {
                var e = this._$handlers;
                return e[t] && e[t][zn]
            }, off: function (t, e) {
                var i = this._$handlers;
                if (!t)return this._$handlers = {}, this;
                if (e) {
                    if (i[t]) {
                        for (var n = [], r = 0, a = i[t][zn]; a > r; r++)i[t][r].h != e && n.push(i[t][r]);
                        i[t] = n
                    }
                    i[t] && 0 === i[t][zn] && delete i[t]
                } else delete i[t];
                return this
            }, trigger: function (t) {
                if (this._$handlers[t]) {
                    var i = arguments, n = i[zn];
                    n > 3 && (i = e.call(i, 1));
                    for (var r = this._$handlers[t], a = r[zn], o = 0; a > o;) {
                        switch (n) {
                            case 1:
                                r[o].h.call(r[o].ctx);
                                break;
                            case 2:
                                r[o].h.call(r[o].ctx, i[1]);
                                break;
                            case 3:
                                r[o].h.call(r[o].ctx, i[1], i[2]);
                                break;
                            default:
                                r[o].h.apply(r[o].ctx, i)
                        }
                        r[o].one ? (r[Ln](o, 1), a--) : o++
                    }
                }
                return this
            }, triggerWithContext: function (t) {
                if (this._$handlers[t]) {
                    var i = arguments, n = i[zn];
                    n > 4 && (i = e.call(i, 1, i[zn] - 1));
                    for (var r = i[i[zn] - 1], a = this._$handlers[t], o = a[zn], s = 0; o > s;) {
                        switch (n) {
                            case 1:
                                a[s].h.call(r);
                                break;
                            case 2:
                                a[s].h.call(r, i[1]);
                                break;
                            case 3:
                                a[s].h.call(r, i[1], i[2]);
                                break;
                            default:
                                a[s].h.apply(r, i)
                        }
                        a[s].one ? (a[Ln](s, 1), o--) : s++
                    }
                }
                return this
            }
        }, r
    }), e("echarts/chart/line/LineSeries", [gr, "../helper/createListFromArray", Pe], function (t) {
        var e = t("../helper/createListFromArray"), i = t(Pe);
        return i[On]({
            type: "series.line",
            dependencies: ["grid", "polar"],
            getInitialData: function (t, i) {
                return e(t.data, this, i)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                polarIndex: 0,
                clipOverflow: !0,
                label: {normal: {position: "top"}},
                lineStyle: {normal: {width: 2, type: "solid"}},
                smooth: !1,
                smoothMonotone: null,
                symbol: "emptyCircle",
                symbolSize: 4,
                symbolRotate: null,
                showSymbol: !0,
                showAllSymbol: !1,
                connectNulls: !1,
                sampling: "none",
                animationEasing: "linear"
            }
        })
    }), e("echarts/loading/default", [gr, "../util/graphic", vr], function (t) {
        var e = t("../util/graphic"), i = t(vr), n = Math.PI;
        return function (t, r) {
            r = r || {}, i[Vn](r, {
                text: "loading",
                color: "#c23531",
                textColor: "#000",
                maskColor: "rgba(255, 255, 255, 0.8)",
                zlevel: 0
            });
            var a = new e.Rect({
                style: {fill: r.maskColor},
                zlevel: r[xn],
                z: 1e4
            }), o = new e.Arc({
                shape: {startAngle: -n / 2, endAngle: -n / 2 + .1, r: 10},
                style: {stroke: r.color, lineCap: "round", lineWidth: 5},
                zlevel: r[xn],
                z: 10001
            }), s = new e.Rect({
                style: {
                    fill: "none",
                    text: r.text,
                    textPosition: "right",
                    textDistance: 10,
                    textFill: r.textColor
                }, zlevel: r[xn], z: 10001
            });
            o.animateShape(!0).when(1e3, {endAngle: 3 * n / 2}).start("circularInOut"), o.animateShape(!0).when(1e3, {startAngle: 3 * n / 2}).delay(300).start("circularInOut");
            var l = new e.Group;
            return l.add(o), l.add(s), l.add(a), l[$n] = function () {
                var e = t[Kn]() / 2, i = t[Yn]() / 2;
                o[ii]({cx: e, cy: i});
                var n = o.shape.r;
                s[ii]({x: e - n, y: i - n, width: 2 * n, height: 2 * n}), a[ii]({
                    x: 0,
                    y: 0,
                    width: t[Kn](),
                    height: t[Yn]()
                })
            }, l[$n](), l
        }
    }), e("echarts/util/format", [gr, vr, "./number"], function (t) {
        function e(t) {
            return isNaN(t) ? "-" : (t = (t + "").split("."), t[0][mn](/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t[zn] > 1 ? "." + t[1] : ""))
        }

        function i(t) {
            return t[nr]()[mn](/-(.)/g, function (t, e) {
                return e.toUpperCase()
            })
        }

        function n(t) {
            var e = t[zn];
            return typeof t === sn ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
        }

        function r(t) {
            return String(t)[mn](/&/g, "&amp;")[mn](/</g, "&lt;")[mn](/>/g, "&gt;")[mn](/"/g, "&quot;")[mn](/'/g, "&#39;")
        }

        function a(t, e) {
            return "{" + t + (null == e ? "" : e) + "}"
        }

        function o(t, e) {
            c[gn](e) || (e = [e]);
            var i = e[zn];
            if (!i)return "";
            for (var n = e[0].$vars, r = 0; r < n[zn]; r++) {
                var o = h[r];
                t = t[mn](a(o), a(o, 0))
            }
            for (var s = 0; i > s; s++)for (var l = 0; l < n[zn]; l++)t = t[mn](a(h[l], s), e[s][n[l]]);
            return t
        }

        function s(t, e) {
            ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
            var i = u.parseDate(e), n = i.getFullYear(), r = i.getMonth() + 1, a = i.getDate(), o = i.getHours(), s = i.getMinutes(), c = i.getSeconds();
            return t = t[mn]("MM", l(r))[nr]()[mn]("yyyy", n)[mn]("yy", n % 100)[mn]("dd", l(a))[mn]("d", a)[mn]("hh", l(o))[mn]("h", o)[mn]("mm", l(s))[mn]("m", s)[mn]("ss", l(c))[mn]("s", c)
        }

        function l(t) {
            return 10 > t ? "0" + t : t
        }

        var c = t(vr), u = t("./number"), h = ["a", "b", "c", "d", "e", "f", "g"];
        return {normalizeCssArray: n, addCommas: e, toCamelCase: i, encodeHTML: r, formatTpl: o, formatTime: s}
    }), e(or, [], function () {
        var t = typeof Float32Array === v ? Array : Float32Array, e = {
            create: function () {
                var i = new t(6);
                return e.identity(i), i
            }, identity: function (t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
            }, copy: function (t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
            }, mul: function (t, e, i) {
                var n = e[0] * i[0] + e[2] * i[1], r = e[1] * i[0] + e[3] * i[1], a = e[0] * i[2] + e[2] * i[3], o = e[1] * i[2] + e[3] * i[3], s = e[0] * i[4] + e[2] * i[5] + e[4], l = e[1] * i[4] + e[3] * i[5] + e[5];
                return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t
            }, translate: function (t, e, i) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t
            }, rotate: function (t, e, i) {
                var n = e[0], r = e[2], a = e[4], o = e[1], s = e[3], l = e[5], c = Math.sin(i), u = Math.cos(i);
                return t[0] = n * u + o * c, t[1] = -n * c + o * u, t[2] = r * u + s * c, t[3] = -r * c + u * s, t[4] = u * a + c * l, t[5] = u * l - c * a, t
            }, scale: function (t, e, i) {
                var n = i[0], r = i[1];
                return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t
            }, invert: function (t, e) {
                var i = e[0], n = e[2], r = e[4], a = e[1], o = e[3], s = e[5], l = i * o - a * n;
                return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null
            }
        };
        return e
    }), e("echarts/chart/effectScatter/EffectScatterView", [gr, "../helper/SymbolDraw", "../helper/EffectSymbol", Ri], function (t) {
        var e = t("../helper/SymbolDraw"), i = t("../helper/EffectSymbol");
        t(Ri)[hn]({
            type: "effectScatter", init: function () {
                this._symbolDraw = new e(i)
            }, render: function (t) {
                var e = t[ur](), i = this._symbolDraw;
                i[li](e), this.group.add(i.group)
            }, updateLayout: function () {
                this._symbolDraw[Nn]()
            }, remove: function (t, e) {
                this._symbolDraw && this._symbolDraw[En](e)
            }
        })
    }),e("echarts/chart/map/MapSeries", [gr, Bi, Pe, vr, Oi, Ie, "../../component/helper/selectableMixin", "../../coord/geo/geoCreator"], function (t) {
        var e = t(Bi), i = t(Pe), n = t(vr), r = t(Oi), a = t(Ie), o = a[De], s = a[ke], l = t("../../component/helper/selectableMixin"), c = t("../../coord/geo/geoCreator"), u = i[On]({
            type: "series.map",
            needsDrawMap: !1,
            seriesGroup: [],
            init: function (t) {
                t = this._fillOption(t, t.map), this[Pi] = t, u[Vi](this, "init", arguments), this.updateSelectedMap(t.data)
            },
            getInitialData: function (t) {
                var i = r(["value"], t.data || []), n = new e(i, this);
                return n[Ii](t.data), n
            },
            mergeOption: function (t) {
                t.data && (t = this._fillOption(t, this[Pi].map)), u.superCall(this, zi, t), this.updateSelectedMap(this[Pi].data)
            },
            _fillOption: function (t, e) {
                return t = n[On]({}, t), t.data = c.getFilledRegions(t.data, e), t
            },
            getRawValue: function (t) {
                return this._data.get("value", t)
            },
            getRegionModel: function (t) {
                var e = this[ur]();
                return e[Ai](e[x](t))
            },
            formatTooltip: function (t) {
                for (var e = this._data, i = s(this[ye](t)), n = e[xi](t), r = this.seriesGroup, a = [], l = 0; l < r[zn]; l++)isNaN(r[l][ye](t)) || a.push(o(r[l].name));
                return a.join(", ") + Le + n + " : " + i
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "geo",
                map: "china",
                left: "center",
                top: "center",
                showLegendSymbol: !0,
                dataRangeHoverLink: !0,
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {
                    normal: {show: !1, textStyle: {color: "#000"}},
                    emphasis: {show: !0, textStyle: {color: "rgb(100,0,0)"}}
                },
                itemStyle: {
                    normal: {borderWidth: .5, borderColor: "#444", areaColor: "#eee"},
                    emphasis: {areaColor: "rgba(255,215, 0, 0.8)"}
                }
            },
            setZoom: function (t) {
                this[Pi].zoom = t
            },
            setCenter: function (t) {
                this[Pi][ji] = t
            }
        });
        return n.mixin(u, l), u
    }),e(ar, [], function () {
        var t = typeof Float32Array === v ? Array : Float32Array, e = {
            create: function (e, i) {
                var n = new t(2);
                return n[0] = e || 0, n[1] = i || 0, n
            }, copy: function (t, e) {
                return t[0] = e[0], t[1] = e[1], t
            }, clone: function (e) {
                var i = new t(2);
                return i[0] = e[0], i[1] = e[1], i
            }, set: function (t, e, i) {
                return t[0] = e, t[1] = i, t
            }, add: function (t, e, i) {
                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
            }, scaleAndAdd: function (t, e, i, n) {
                return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t
            }, sub: function (t, e, i) {
                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
            }, len: function (t) {
                return Math.sqrt(this.lenSquare(t))
            }, lenSquare: function (t) {
                return t[0] * t[0] + t[1] * t[1]
            }, mul: function (t, e, i) {
                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
            }, div: function (t, e, i) {
                return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
            }, dot: function (t, e) {
                return t[0] * e[0] + t[1] * e[1]
            }, scale: function (t, e, i) {
                return t[0] = e[0] * i, t[1] = e[1] * i, t
            }, normalize: function (t, i) {
                var n = e.len(i);
                return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = i[0] / n, t[1] = i[1] / n), t
            }, distance: function (t, e) {
                return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
            }, distanceSquare: function (t, e) {
                return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
            }, negate: function (t, e) {
                return t[0] = -e[0], t[1] = -e[1], t
            }, lerp: function (t, e, i, n) {
                return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t
            }, applyTransform: function (t, e, i) {
                var n = e[0], r = e[1];
                return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t
            }, min: function (t, e, i) {
                return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
            }, max: function (t, e, i) {
                return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
            }
        };
        return e[zn] = e.len, e.lengthSquare = e.lenSquare, e.dist = e.distance, e.distSquare = e.distanceSquare, e
    }),e("echarts/action/geoRoam", [gr, vr, "./roamHelper", pr], function (t) {
        var e = t(vr), i = t("./roamHelper"), n = t(pr);
        n[pn]({type: "geoRoam", event: "geoRoam", update: "updateLayout"}, function (t, n) {
            var r = t.componentType || Dn;
            n[qn]({mainType: r, query: t}, function (n) {
                var a = n[Ni];
                if ("geo" === a.type) {
                    var o = i.updateCenterAndZoom(a, t, n.get("scaleLimit"));
                    n.setCenter && n.setCenter(o[ji]), n.setZoom && n.setZoom(o.zoom), r === Dn && e.each(n.seriesGroup, function (t) {
                        t.setCenter(o[ji]), t.setZoom(o.zoom)
                    })
                }
            })
        })
    }),e("echarts/chart/map/MapView", [gr, vi, "../../component/helper/MapDraw", Ri], function (t) {
        var e = t(vi), i = t("../../component/helper/MapDraw");
        t(Ri)[hn]({
            type: "map", render: function (t, e, n, r) {
                if (!r || "mapToggleSelect" !== r.type || r.from !== this.uid) {
                    var a = this.group;
                    if (a[rn](), r && "geoRoam" === r.type && r.component === Dn && r.name === t.name) {
                        var o = this._mapDraw;
                        o && a.add(o.group)
                    } else if (t.needsDrawMap) {
                        var o = this._mapDraw || new i(n, !0);
                        a.add(o.group), o.draw(t, e, n, this, r), this._mapDraw = o
                    } else this._mapDraw && this._mapDraw[En](), this._mapDraw = null;
                    t.get("showLegendSymbol") && e[ve]("legend") && this._renderSymbols(t, e, n)
                }
            }, remove: function () {
                this._mapDraw && this._mapDraw[En](), this._mapDraw = null, this.group[rn]()
            }, _renderSymbols: function (t) {
                var i = t[ur](), n = this.group;
                i.each("value", function (t, r) {
                    if (!isNaN(t)) {
                        var a = i[fi](r);
                        if (a && a.point) {
                            var o = a.point, s = a.offset, l = new e[y]({
                                style: {fill: i[G]("color")},
                                shape: {cx: o[0] + 9 * s, cy: o[1], r: 3},
                                silent: !0,
                                z2: 10
                            });
                            if (!s) {
                                var c = i[xi](r), u = i[Ai](r), h = u[Jn](Xe), d = u[Jn](je), f = h[Jn](nn), p = d[Jn](nn), v = i[pi](r);
                                l[qi]({textPosition: "bottom"});
                                var g = function () {
                                    l[qi]({text: d.get("show") ? c : "", textFill: p[$i](), textFont: p[tn]()})
                                }, m = function () {
                                    l[qi]({text: h.get("show") ? c : "", textFill: f[$i](), textFont: f[tn]()})
                                };
                                v.on(Cn, g).on(An, m).on(Ti, g).on(Li, m), m()
                            }
                            n.add(l)
                        }
                    }
                })
            }
        })
    }),e("echarts/coord/geo/geoCreator", [gr, "./Geo", me, vr, Ri], function (t) {
        function e(t, e) {
            var i = this[Qi](), n = t[Ji]();
            n.aspect = i.width / i[Fn] * .75;
            var r = a[Ki](n, {width: e[Kn](), height: e[Yn]()});
            this.setViewRect(r.x, r.y, r.width, r[Fn]), this.setCenter(t.get(ji)), this.setZoom(t.get("zoom"))
        }

        function i(t, e) {
            o.each(e.get("geoCoord"), function (e, i) {
                t.addGeoCoord(i, e)
            })
        }

        function n(t) {
            console.error("Map " + t + " not exists")
        }

        var r = t("./Geo"), a = t(me), o = t(vr), s = {}, l = {
            dimensions: r[ir][Te], create: function (t, a) {
                var l = [];
                t[qn]("geo", function (t, o) {
                    var c = t.get("map"), u = s[c];
                    u || n(c);
                    var h = new r(c + o, c, u && u.geoJson, u && u.specialAreas, t.get("nameMap"));
                    h[L] = t.get("scaleLimit"), l.push(h), i(h, t), t[Ni] = h, h.model = t, h[$n] = e, h[$n](t, a)
                }), t[In](function (t) {
                    var e = t.get(Ni);
                    if ("geo" === e) {
                        var i = t.get("geoIndex") || 0;
                        t[Ni] = l[i]
                    }
                });
                var c = {};
                return t[hr]("map", function (t) {
                    var e = t.get("map");
                    c[e] = c[e] || [], c[e].push(t)
                }), o.each(c, function (t, c) {
                    var u = s[c];
                    u || n(name);
                    var h = o.map(t, function (t) {
                        return t.get("nameMap")
                    }), d = new r(c, c, u && u.geoJson, u && u.specialAreas, o.mergeAll(h));
                    d[L] = o[oi].apply(null, o.map(t, function (t) {
                        return t.get("scaleLimit")
                    })), l.push(d), d[$n] = e, d[$n](t[0], a), o.each(t, function (t) {
                        t[Ni] = d, i(d, t)
                    })
                }), l
            }, registerMap: function (t, e, i) {
                e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), typeof e === er && (e = typeof JSON !== v && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")()), s[t] = {
                    geoJson: e,
                    specialAreas: i
                }
            }, getMap: function (t) {
                return s[t]
            }, getFilledRegions: function (t, e) {
                for (var i = (t || []).slice(), n = l.getMap(e), r = n && n.geoJson, a = {}, o = r.features, s = 0; s < i[zn]; s++)a[i[s].name] = i[s];
                for (var s = 0; s < o[zn]; s++) {
                    var c = o[s].properties.name;
                    a[c] || i.push({name: c})
                }
                return i
            }
        }, c = t(Ri);
        return c.registerMap = l.registerMap, c.getMap = l.getMap, c.loadMap = function () {
        }, c.registerCoordinateSystem("geo", l), l
    }),e("echarts/chart/map/mapSymbolLayout", [gr, vr], function (t) {
        var e = t(vr);
        return function (t) {
            var i = {};
            t[hr]("map", function (n) {
                var r = n.get("map");
                if (!i[r]) {
                    var a = {};
                    e.each(n.seriesGroup, function (e) {
                        var i = e[Ni], n = e[ur]();
                        e.get("showLegendSymbol") && t[ve]("legend") && n.each("value", function (t, e) {
                            var r = n[xi](e), o = i.getRegion(r);
                            if (o && !isNaN(t)) {
                                var s = a[r] || 0, l = i[Se](o[ji]);
                                a[r] = s + 1, n[Ve](e, {point: l, offset: s})
                            }
                        })
                    });
                    var o = n[ur]();
                    o.each(function (t) {
                        var e = o[xi](t), i = o[fi](t) || {};
                        i.showLabel = !a[e], o[Ve](t, i)
                    }), i[r] = !0
                }
            })
        }
    }),e("echarts/chart/map/mapVisual", [gr], function () {
        return function (t) {
            t[hr]("map", function (t) {
                var e = t.get("color"), i = t[Jn](ie), n = i.get("areaColor"), r = i.get("color") || e[t[bn] % e[zn]];
                t[ur]()[cr]({areaColor: n, color: r})
            })
        }
    }),e("echarts/chart/map/mapDataStatistic", [gr, vr], function (t) {
        function e(t, e) {
            for (var i = {}, n = ["value"], r = 0; r < t[zn]; r++)t[r].each(n, function (e, n) {
                var a = t[r][xi](n);
                i[a] = i[a] || [], isNaN(e) || i[a].push(e)
            });
            return t[0].map(n, function (n, r) {
                for (var a = t[0][xi](r), o = 0, s = 1 / 0, l = -1 / 0, c = i[a][zn], u = 0; c > u; u++)s = Math.min(s, i[a][u]), l = Math.max(l, i[a][u]), o += i[a][u];
                var h;
                return h = "min" === e ? s : "max" === e ? l : "average" === e ? o / c : o, 0 === c ? 0 / 0 : h
            })
        }

        var i = t(vr);
        return function (t) {
            var n = {};
            t[hr]("map", function (t) {
                var e = t.get("map");
                n[e] = n[e] || [], n[e].push(t)
            }), i.each(n, function (t) {
                var n = e(i.map(t, function (t) {
                    return t[ur]()
                }), t[0].get("mapValueCalculation"));
                t[0].seriesGroup = [], t[0].setData(n);
                for (var r = 0; r < t[zn]; r++)t[r].seriesGroup = t, t[r].needsDrawMap = 0 === r
            })
        }
    }),e("echarts/chart/line/LineView", [gr, vr, "../helper/SymbolDraw", "../helper/Symbol", "./lineAnimationDiff", vi, "./poly", "../../view/Chart"], function (t) {
        function e(t, e) {
            if (t[zn] === e[zn]) {
                for (var i = 0; i < t[zn]; i++) {
                    var n = t[i], r = e[i];
                    if (n[0] !== r[0] || n[1] !== r[1])return
                }
                return !0
            }
        }

        function i(t) {
            return typeof t === sn ? t : t ? .3 : 0
        }

        function n(t) {
            var e = t.getGlobalExtent();
            if (t.onBand) {
                var i = t.getBandWidth() / 2 - 1, n = e[1] > e[0] ? 1 : -1;
                e[0] += n * i, e[1] -= n * i
            }
            return e
        }

        function r(t) {
            return t >= 0 ? 1 : -1
        }

        function a(t, e) {
            var i = t[Me](), n = t[ee](i), a = i.onZero ? 0 : n.scale[we]()[0], o = n.dim, s = "x" === o || o === Oe ? 1 : 0;
            return e[K]([o], function (n, l) {
                for (var c, u = e.stackedOn; u && r(u.get(o, l)) === r(n);) {
                    c = u;
                    break
                }
                var h = [];
                return h[s] = e.get(i.dim, l), h[1 - s] = c ? c.get(o, l, !0) : a, t[Se](h)
            }, !0)
        }

        function o(t, e) {
            return null != e[Mn] ? e[Mn] : null != e.name ? t[x](e.name) : void 0
        }

        function s(t, e, i) {
            var r = n(t[he]("x")), a = n(t[he]("y")), o = t[Me]().isHorizontal(), s = Math.min(r[0], r[1]), l = Math.min(a[0], a[1]), c = Math.max(r[0], r[1]) - s, u = Math.max(a[0], a[1]) - l, h = i.get("lineStyle.normal.width") || 2, d = i.get("clipOverflow") ? h / 2 : Math.max(c, u);
            o ? (l -= d, u += 2 * d) : (s -= d, c += 2 * d);
            var f = new p.Rect({shape: {x: s, y: l, width: c, height: u}});
            return e && (f.shape[o ? "width" : Fn] = 0, p[Ze](f, {shape: {width: c, height: u}}, i)), f
        }

        function l(t, e, i) {
            var n = t.getAngleAxis(), r = t.getRadiusAxis(), a = r[we](), o = n[we](), s = Math.PI / 180, l = new p[ui]({
                shape: {
                    cx: t.cx,
                    cy: t.cy,
                    r0: a[0],
                    r: a[1],
                    startAngle: -o[0] * s,
                    endAngle: -o[1] * s,
                    clockwise: n[fe]
                }
            });
            return e && (l.shape.endAngle = -o[0] * s, p[Ze](l, {shape: {endAngle: -o[1] * s}}, i)), l
        }

        function c(t, e, i) {
            return "polar" === t.type ? l(t, e, i) : s(t, e, i)
        }

        var u = t(vr), h = t("../helper/SymbolDraw"), d = t("../helper/Symbol"), f = t("./lineAnimationDiff"), p = t(vi), v = t("./poly"), g = t("../../view/Chart");
        return g[On]({
            type: "line", init: function () {
                var t = new p.Group, e = new h;
                this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t
            }, render: function (t, n, r) {
                var o = t[Ni], s = this.group, l = t[ur](), h = t[Jn]("lineStyle.normal"), d = t[Jn]("areaStyle.normal"), f = l[K](l[fi], !0), p = "polar" === o.type, v = this._coordSys, g = this._symbolDraw, m = this._polyline, y = this._polygon, x = this._lineGroup, _ = t.get(Je), w = !d.isEmpty(), b = a(o, l), M = t.get("showSymbol"), S = M && !p && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, o), A = this._data;
                A && A[ne](function (t, e) {
                    t.__temp && (s[En](t), A[He](e, null))
                }), M || g[En](), s.add(x), m && v.type === o.type ? (w && !y ? y = this._newPolygon(f, b, o, _) : y && !w && (x[En](y), y = this._polygon = null), x.setClipPath(c(o, !1, t)), M && g[li](l, S), l[ne](function (t) {
                    t[Un](!0)
                }), e(this._stackedOnPoints, b) && e(this._points, f) || (_ ? this._updateAnimation(l, b, o, r) : (m[ii]({points: f}), y && y[ii]({
                    points: f,
                    stackedOnPoints: b
                })))) : (M && g[li](l, S), m = this._newPolyline(f, o, _), w && (y = this._newPolygon(f, b, o, _)), x.setClipPath(c(o, !0, t))), m[ti](u[Vn](h[Ue](), {
                    fill: "none",
                    stroke: l[G]("color"),
                    lineJoin: "bevel"
                }));
                var C = t.get("smooth");
                if (C = i(t.get("smooth")), m[ii]({
                        smooth: C,
                        smoothMonotone: t.get("smoothMonotone"),
                        connectNulls: t.get("connectNulls")
                    }), y) {
                    var T = l.stackedOn, L = 0;
                    if (y[ti](u[Vn](d[z](), {fill: l[G]("color"), opacity: .7, lineJoin: "bevel"})), T) {
                        var k = T[ri];
                        L = i(k.get("smooth"))
                    }
                    y[ii]({
                        smooth: C,
                        stackedOnSmooth: L,
                        smoothMonotone: t.get("smoothMonotone"),
                        connectNulls: t.get("connectNulls")
                    })
                }
                this._data = l, this._coordSys = o, this._stackedOnPoints = b, this._points = f
            }, highlight: function (t, e, i, n) {
                var r = t[ur](), a = o(r, n);
                if (null != a && a >= 0) {
                    var s = r[pi](a);
                    if (!s) {
                        var l = r[fi](a);
                        s = new d(r, a, i), s[Ui] = l, s.setZ(t.get(xn), t.get("z")), s[Wn] = isNaN(l[0]) || isNaN(l[1]), s.__temp = !0, r[He](a, s), s.stopSymbolAnimation(!0), this.group.add(s)
                    }
                    s.highlight()
                } else g[ir].highlight.call(this, t, e, i, n)
            }, downplay: function (t, e, i, n) {
                var r = t[ur](), a = o(r, n);
                if (null != a && a >= 0) {
                    var s = r[pi](a);
                    s && (s.__temp ? (r[He](a, null), this.group[En](s)) : s.downplay())
                } else g[ir].downplay.call(this, t, e, i, n)
            }, _newPolyline: function (t) {
                var e = this._polyline;
                return e && this._lineGroup[En](e), e = new v[ci]({
                    shape: {points: t},
                    silent: !0,
                    z2: 10
                }), this._lineGroup.add(e), this._polyline = e, e
            }, _newPolygon: function (t, e) {
                var i = this._polygon;
                return i && this._lineGroup[En](i), i = new v[R]({
                    shape: {points: t, stackedOnPoints: e},
                    silent: !0
                }), this._lineGroup.add(i), this._polygon = i, i
            }, _getSymbolIgnoreFunc: function (t, e) {
                var i = e.getAxesByScale(se)[0];
                return i && i.isLabelIgnored ? u.bind(i.isLabelIgnored, i) : void 0
            }, _updateAnimation: function (t, e, i) {
                var n = this._polyline, r = this._polygon, a = t[ri], o = f(this._data, t, this._stackedOnPoints, e, this._coordSys, i);
                n.shape[V] = o.current, p[ei](n, {shape: {points: o.next}}, a), r && (r[ii]({
                    points: o.current,
                    stackedOnPoints: o.stackedOnCurrent
                }), p[ei](r, {shape: {points: o.next, stackedOnPoints: o.stackedOnNext}}, a));
                for (var s = [], l = o.status, c = 0; c < l[zn]; c++) {
                    var u = l[c].cmd;
                    if ("=" === u) {
                        var h = t[pi](l[c].idx1);
                        h && s.push({el: h, ptIdx: c})
                    }
                }
                n.animators && n.animators[zn] && n.animators[0].during(function () {
                    for (var t = 0; t < s[zn]; t++) {
                        var e = s[t].el;
                        e.attr(Ui, n.shape[V][s[t].ptIdx])
                    }
                })
            }, remove: function () {
                var t = this.group, e = this._data;
                this._lineGroup[rn](), this._symbolDraw[En](!0), e && e[ne](function (i, n) {
                    i.__temp && (t[En](i), e[He](n, null))
                }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
            }
        })
    }),e("echarts/processor/dataSample", [], function () {
        var t = {
            average: function (t) {
                for (var e = 0, i = 0, n = 0; n < t[zn]; n++)isNaN(t[n]) || (e += t[n], i++);
                return 0 === i ? 0 / 0 : e / i
            }, sum: function (t) {
                for (var e = 0, i = 0; i < t[zn]; i++)e += t[i] || 0;
                return e
            }, max: function (t) {
                for (var e = -1 / 0, i = 0; i < t[zn]; i++)t[i] > e && (e = t[i]);
                return e
            }, min: function (t) {
                for (var e = 1 / 0, i = 0; i < t[zn]; i++)t[i] < e && (e = t[i]);
                return e
            }, nearest: function (t) {
                return t[0]
            }
        }, e = function (t) {
            return Math.round(t[zn] / 2)
        };
        return function (i, n) {
            n[hr](i, function (i) {
                var n = i[ur](), r = i.get("sampling"), a = i[Ni];
                if (a.type === ce && r) {
                    var o = a[Me](), s = a[ee](o), l = o[we](), c = l[1] - l[0], u = Math.round(n.count() / c);
                    if (u > 1) {
                        var h;
                        typeof r === er ? h = t[r] : typeof r === fn && (h = r), h && (n = n.downSample(s.dim, 1 / u, h, e), i.setData(n))
                    }
                }
            }, this)
        }
    }),e("echarts/chart/effectScatter/EffectScatterSeries", [gr, "../helper/createListFromArray", Pe], function (t) {
        var e = t("../helper/createListFromArray"), i = t(Pe);
        return i[On]({
            type: "series.effectScatter",
            dependencies: ["grid", "polar"],
            getInitialData: function (t, i) {
                var n = e(t.data, this, i);
                return n
            },
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                effectType: "ripple",
                showEffectOn: "render",
                rippleEffect: {period: 4, scale: 2.5, brushType: "fill"},
                xAxisIndex: 0,
                yAxisIndex: 0,
                polarIndex: 0,
                geoIndex: 0,
                symbolSize: 10
            }
        })
    }),e("echarts/chart/map/backwardCompat", [gr, vr], function (t) {
        function e(t) {
            var e = {};
            return i.each(n, function (i) {
                null != t[i] && (e[i] = t[i])
            }), e
        }

        var i = t(vr), n = ["x", "y", "x2", "y2", "width", Fn, "map", "roam", ji, "zoom", "scaleLimit", "label", ln], r = {};
        return function (t) {
            var n = [];
            i.each(t[Dn], function (t) {
                "map" === t.type && n.push(t), i[On](r, t.geoCoord)
            });
            var a = {};
            i.each(n, function (n) {
                if (n.map = n.map || n.mapType, i[Vn](n, n.mapLocation), n.markPoint) {
                    var o = n.markPoint;
                    if (o.data = i.map(o.data, function (t) {
                            if (!i[gn](t.value)) {
                                var e;
                                t.geoCoord ? e = t.geoCoord : t.name && (e = r[t.name]);
                                var n = e ? [e[0], e[1]] : [0 / 0, 0 / 0];
                                null != t.value && n.push(t.value), t.value = n
                            }
                            return t
                        }), !n.data || !n.data[zn]) {
                        t.geo ? i[gn](t.geo) || (t.geo = [t.geo]) : t.geo = [];
                        var s = a[n.map];
                        s || (s = a[n.map] = e(n), t.geo.push(s));
                        var l = n.markPoint;
                        l.type = t.effect && t.effect.show ? "effectScatter" : "scatter", l[Ni] = "geo", l.geoIndex = i[vn](t.geo, s), l.name = n.name, t[Dn][Ln](i[vn](t[Dn], n), 1, l)
                    }
                }
            })
        }
    }),e("echarts/chart/boxplot/BoxplotSeries", [gr, vr, Pe, "../helper/whiskerBoxCommon"], function (t) {
        var e = t(vr), i = t(Pe), n = t("../helper/whiskerBoxCommon"), r = i[On]({
            type: "series.boxplot",
            dependencies: ["xAxis", "yAxis", "grid"],
            valueDimensions: ["min", "Q1", "median", "Q3", "max"],
            dimensions: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                layout: null,
                boxWidth: [7, 50],
                itemStyle: {
                    normal: {color: "#fff", borderWidth: 1},
                    emphasis: {
                        borderWidth: 2,
                        shadowBlur: 5,
                        shadowOffsetX: 2,
                        shadowOffsetY: 2,
                        shadowColor: "rgba(0,0,0,0.4)"
                    }
                },
                animationEasing: "elasticOut",
                animationDuration: 800
            }
        });
        return e.mixin(r, n.seriesModelMixin, !0), r
    }),e("echarts/chart/parallel/ParallelSeries", [gr, Bi, vr, Pe], function (t) {
        function e(t, e, i) {
            var r = t.get("data"), a = +e[mn]("dim", "");
            r && r[zn] && n.each(i, function (t) {
                if (t) {
                    var e = n[vn](r, t[a]);
                    t[a] = e >= 0 ? e : 0 / 0
                }
            })
        }

        var i = t(Bi), n = t(vr), r = t(Pe);
        return r[On]({
            type: "series.parallel",
            dependencies: [g],
            getInitialData: function (t, r) {
                var a = r[ve](g, this.get("parallelIndex")), o = a[Te], s = a.parallelAxisIndex, l = t.data, c = n.map(o, function (t, i) {
                    var n = r[ve]("parallelAxis", s[i]);
                    return n.get("type") === be ? (e(n, t, l), {name: t, type: "ordinal"}) : t
                }), u = new i(c, this);
                return u[Ii](l), u
            },
            getRawIndicesByActiveState: function (t) {
                var e = this[Ni], i = this[ur](), n = [];
                return e.eachActiveState(i, function (e, r) {
                    t === e && n.push(i[Si](r))
                }), n
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "parallel",
                parallelIndex: 0,
                label: {normal: {show: !1}, emphasis: {show: !1}},
                inactiveOpacity: .05,
                activeOpacity: 1,
                lineStyle: {normal: {width: 2, opacity: .45, type: "solid"}},
                animationEasing: "linear"
            }
        })
    }),e("echarts/chart/parallel/ParallelView", [gr, vi, vr, "../../view/Chart"], function (t) {
        function e(t, e, i) {
            var n = t.model, r = t[Ci](), o = new a.Rect({
                shape: {
                    x: r.x,
                    y: r.y,
                    width: r.width,
                    height: r[Fn]
                }
            }), s = n.get(Ce) === Ae ? "width" : Fn;
            return o[ii](s, 0), a[Ze](o, {shape: {width: r.width, height: r[Fn]}}, e, i), o
        }

        function i(t, e, i, n) {
            for (var a = 0, o = e[zn] - 1; o > a; a++) {
                var s = e[a], l = e[a + 1], c = t[a], u = t[a + 1];
                n(r(c, i[he](s).type) || r(u, i[he](l).type) ? null : [i[Se](c, s), i[Se](u, l)], a)
            }
        }

        function n(t) {
            return new a[ci]({shape: {points: t}, silent: !0})
        }

        function r(t, e) {
            return e === be ? null == t : null == t || isNaN(t)
        }

        var a = t(vi), o = t(vr), s = t("../../view/Chart")[On]({
            type: "parallel", init: function () {
                this._dataGroup = new a.Group, this.group.add(this._dataGroup), this._data
            }, render: function (t) {
                function r(t) {
                    var e = u.getValues(f, t), r = new a.Group;
                    c.add(r), i(e, f, d, function (t) {
                        t && r.add(n(t))
                    }), u[He](t, r)
                }

                function s(e, r) {
                    var o = u.getValues(f, e), s = h[pi](r), l = [], c = 0;
                    i(o, f, d, function (i) {
                        var r = s[ni](c++);
                        i && !r ? l.push(n(i)) : i && a[ei](r, {shape: {points: i}}, t, e)
                    });
                    for (var p = s.childCount() - 1; p >= c; p--)s[En](s[ni](p));
                    for (var p = 0, v = l[zn]; v > p; p++)s.add(l[p]);
                    u[He](e, s)
                }

                function l(t) {
                    var e = h[pi](t);
                    c[En](e)
                }

                var c = this._dataGroup, u = t[ur](), h = this._data, d = t[Ni], f = d[Te];
                u.diff(h).add(r)[Gn](s)[En](l)[qe](), u[ne](function (t, e) {
                    var i = u[Ai](e), n = i[Jn]("lineStyle.normal");
                    t[We](function (t) {
                        t[ti](o[On](n[Ue](), {fill: null, stroke: u[Mi](e, "color"), opacity: u[Mi](e, Hi)}))
                    })
                }), this._data || c.setClipPath(e(d, t, function () {
                    c.removeClipPath()
                })), this._data = u
            }, remove: function () {
                this._dataGroup && this._dataGroup[rn](), this._data = null
            }
        });
        return s
    }),e("echarts/chart/boxplot/BoxplotView", [gr, vr, "../../view/Chart", vi, "../helper/whiskerBoxCommon"], function (t) {
        function e(t, e, i) {
            var n = e[Ai](i), a = n[Jn](s), o = e[Mi](i, "color"), c = a[Wi]([Ge]), u = t[ni](t.whiskerIndex);
            u.style.set(c), u.style[Ne] = o, u.dirty();
            var h = t[ni](t.bodyIndex);
            h.style.set(c), h.style[Ne] = o, h.dirty();
            var d = n[Jn](l)[Wi]();
            r[Ke](t, d)
        }

        var i = t(vr), n = t("../../view/Chart"), r = t(vi), a = t("../helper/whiskerBoxCommon"), o = n[On]({
            type: "boxplot",
            getStyleUpdater: function () {
                return e
            }
        });
        i.mixin(o, a.viewMixin, !0);
        var s = [ln, Li], l = [ln, Ti];
        return o
    }),e("echarts/util/layout", [gr, vr, X, "./number", "./format"], function (t) {
        function e(t, e, i, n, r) {
            var a = 0, o = 0;
            null == n && (n = 1 / 0), null == r && (r = 1 / 0);
            var s = 0;
            e[We](function (l, c) {
                var u, h, d = l[Ui], f = l[Qi](), p = e[ni](c + 1), v = p && p[Qi]();
                if (t === Ae) {
                    var g = f.width + (v ? -v.x + f.x : 0);
                    u = a + g, u > n || l.newline ? (a = 0, u = g, o += s + i, s = f[Fn]) : s = Math.max(s, f[Fn])
                } else {
                    var m = f[Fn] + (v ? -v.y + f.y : 0);
                    h = o + m, h > r || l.newline ? (a += s + i, o = 0, h = m, s = f.width) : s = Math.max(s, f.width)
                }
                l.newline || (d[0] = a, d[1] = o, t === Ae ? a = u + i : o = h + i)
            })
        }

        var i = t(vr), n = t(X), r = t("./number"), a = t("./format"), o = r[Ee], s = i.each, l = {}, c = ["left", "right", "top", Hn, "width", Fn];
        return l.box = e, l.vbox = i.curry(e, f), l.hbox = i.curry(e, Ae), l.getAvailableSize = function (t, e, i) {
            var n = e.width, r = e[Fn], s = o(t.x, n), l = o(t.y, r), c = o(t.x2, n), u = o(t.y2, r);
            return (isNaN(s) || isNaN(parseFloat(t.x))) && (s = 0), (isNaN(c) || isNaN(parseFloat(t.x2))) && (c = n), (isNaN(l) || isNaN(parseFloat(t.y))) && (l = 0), (isNaN(u) || isNaN(parseFloat(t.y2))) && (u = r), i = a.normalizeCssArray(i || 0), {
                width: Math.max(c - s - i[1] - i[3], 0),
                height: Math.max(u - l - i[0] - i[2], 0)
            }
        }, l[Ki] = function (t, e, i) {
            i = a.normalizeCssArray(i || 0);
            var r = e.width, s = e[Fn], l = o(t.left, r), c = o(t.top, s), u = o(t.right, r), h = o(t[Hn], s), d = o(t.width, r), f = o(t[Fn], s), p = i[2] + i[0], v = i[1] + i[3], g = t.aspect;
            switch (isNaN(d) && (d = r - u - v - l), isNaN(f) && (f = s - h - p - c), isNaN(d) && isNaN(f) && (g > r / s ? d = .8 * r : f = .8 * s), null != g && (isNaN(d) && (d = g * f), isNaN(f) && (f = d / g)), isNaN(l) && (l = r - u - d - v), isNaN(c) && (c = s - h - f - p), t.left || t.right) {
                case ji:
                    l = r / 2 - d / 2 - i[3];
                    break;
                case"right":
                    l = r - d - v
            }
            switch (t.top || t[Hn]) {
                case Xi:
                case ji:
                    c = s / 2 - f / 2 - i[0];
                    break;
                case Hn:
                    c = s - f - p
            }
            l = l || 0, c = c || 0, isNaN(d) && (d = r - l - (u || 0)), isNaN(f) && (f = s - c - (h || 0));
            var m = new n(l + i[3], c + i[0], d, f);
            return m.margin = i, m
        }, l.positionGroup = function (t, e, n, r) {
            var a = t[Qi]();
            e = i[On](i.clone(e), {width: a.width, height: a[Fn]}), e = l[Ki](e, n, r), t[Ui] = [e.x - a.x, e.y - a.y]
        }, l.mergeLayoutParam = function (t, e, n) {
            function r(i) {
                var r = {}, l = 0, c = {}, u = 0, h = n.ignoreSize ? 1 : 2;
                if (s(i, function (e) {
                        c[e] = t[e]
                    }), s(i, function (t) {
                        a(e, t) && (r[t] = c[t] = e[t]), o(r, t) && l++, o(c, t) && u++
                    }), u !== h && l) {
                    if (l >= h)return r;
                    for (var d = 0; d < i[zn]; d++) {
                        var f = i[d];
                        if (!a(r, f) && a(t, f)) {
                            r[f] = t[f];
                            break
                        }
                    }
                    return r
                }
                return c
            }

            function a(t, e) {
                return t.hasOwnProperty(e)
            }

            function o(t, e) {
                return null != t[e] && "auto" !== t[e]
            }

            function l(t, e, i) {
                s(t, function (t) {
                    e[t] = i[t]
                })
            }

            !i[Bn](n) && (n = {});
            var c = ["width", "left", "right"], u = [Fn, "top", Hn], h = r(c), d = r(u);
            l(c, t, h), l(u, t, d)
        }, l.getLayoutParams = function (t) {
            return l.copyLayoutParams({}, t)
        }, l.copyLayoutParams = function (t, e) {
            return e && t && s(c, function (i) {
                e.hasOwnProperty(i) && (t[i] = e[i])
            }), t
        }, l
    }),e("echarts/chart/boxplot/boxplotVisual", [gr], function () {
        var t = [ln, Li, Ge];
        return function (e) {
            var i = e.get("color");
            e.eachRawSeriesByType("boxplot", function (n) {
                var r = i[n[bn] % i[zn]], a = n[ur]();
                a[cr]({legendSymbol: "roundRect", color: n.get(t) || r}), e.isSeriesFiltered(n) || a.each(function (e) {
                    var i = a[Ai](e);
                    a[wi](e, {color: i.get(t, !0)})
                })
            })
        }
    }),e("echarts/coord/polar/polarCreator", [gr, "./Polar", Be, "../../coord/axisHelper", "./PolarModel", ge], function (t) {
        function e(t, e) {
            var i = t.get(ji), n = t.get(Oe), r = e[Kn](), o = e[Yn](), s = a[Ee];
            this.cx = s(i[0], r), this.cy = s(i[1], o);
            var l = this.getRadiusAxis(), c = Math.min(r, o) / 2;
            l[de](0, s(n, c))
        }

        function i(t) {
            var e = this, i = e.getAngleAxis(), n = e.getRadiusAxis();
            if (i.scale[de](1 / 0, -1 / 0), n.scale[de](1 / 0, -1 / 0), t[In](function (t) {
                    if (t[Ni] === e) {
                        var r = t[ur]();
                        n.scale.unionExtent(r[Re](Oe, n.type !== be)), i.scale.unionExtent(r[Re]("angle", i.type !== be))
                    }
                }), s(i, i.model), s(n, n.model), i.type === be && !i.onBand) {
                var r = i[we](), a = 360 / i.scale.count();
                i[fe] ? r[1] += a : r[1] -= a, i[de](r[0], r[1])
            }
        }

        function n(t, e) {
            if (t.type = e.get("type"), t.scale = o.createScaleByModel(e), t.onBand = e.get(ue) && t.type === be, "angleAxis" === e[w]) {
                var i = e.get(di);
                t[fe] = e.get(fe) ^ e.get(Fe), t[de](i, i + (t[fe] ? -360 : 360))
            }
            e.axis = t, t.model = e
        }

        var r = t("./Polar"), a = t(Be), o = t("../../coord/axisHelper"), s = o.niceScaleExtent;
        t("./PolarModel");
        var l = {
            dimensions: r[ir][Te], create: function (t, a) {
                var o = [];
                return t[qn]("polar", function (t, s) {
                    var l = new r(s);
                    l[$n] = e, l[Gn] = i;
                    var c = l.getRadiusAxis(), u = l.getAngleAxis(), h = t.findAxisModel("radiusAxis"), d = t.findAxisModel("angleAxis");
                    n(c, h), n(u, d), l[$n](t, a), o.push(l), t[Ni] = l
                }), t[In](function (t) {
                    "polar" === t.get(Ni) && (t[Ni] = o[t.get(Y)])
                }), o
            }
        };
        t(ge)[dn]("polar", l)
    }),e("echarts/component/radiusAxis", [gr, "../coord/polar/polarCreator", "./axis/RadiusAxisView"], function (t) {
        t("../coord/polar/polarCreator"), t("./axis/RadiusAxisView")
    }),e("echarts/component/tooltip/TooltipModel", [gr, Ri], function (t) {
        t(Ri)[un]({
            type: "tooltip",
            defaultOption: {
                zlevel: 0,
                z: 8,
                show: !0,
                showContent: !0,
                trigger: "item",
                triggerOn: "mousemove",
                alwaysShowContent: !1,
                showDelay: 0,
                hideDelay: 100,
                transitionDuration: .4,
                enterable: !1,
                backgroundColor: "rgba(50,50,50,0.7)",
                borderColor: "#333",
                borderRadius: 4,
                borderWidth: 0,
                padding: 5,
                extraCssText: "",
                axisPointer: {
                    type: "line",
                    axis: "auto",
                    animation: !0,
                    animationDurationUpdate: 200,
                    animationEasingUpdate: "exponentialOut",
                    lineStyle: {color: "#555", width: 1, type: "solid"},
                    crossStyle: {color: "#555", width: 1, type: "dashed", textStyle: {}},
                    shadowStyle: {color: "rgba(150,150,150,0.3)"}
                },
                textStyle: {color: "#fff", fontSize: 14}
            }
        })
    }),e("echarts/chart/boxplot/boxplotLayout", [gr, vr, Be], function (t) {
        function e(t) {
            var e = [], i = [];
            return t[hr]("boxplot", function (t) {
                var n = t[Me](), a = r[vn](i, n);
                0 > a && (a = i[zn], i[a] = n, e[a] = {axis: n, seriesModels: []}), e[a].seriesModels.push(t)
            }), e
        }

        function i(t) {
            var e, i, n = t.axis, a = t.seriesModels, l = a[zn], c = t.boxWidthList = [], u = t.boxOffsetList = [], h = [];
            if (n.type === be)i = n.getBandWidth(); else {
                var d = 0;
                s(a, function (t) {
                    d = Math.max(d, t[ur]().count())
                }), e = n[we](), Math.abs(e[1] - e[0]) / d
            }
            s(a, function (t) {
                var e = t.get("boxWidth");
                r[gn](e) || (e = [e, e]), h.push([o(e[0], i) || 0, o(e[1], i) || 0])
            });
            var f = .8 * i - 2, p = f / l * .3, v = (f - p * (l - 1)) / l, g = v / 2 - f / 2;
            s(a, function (t, e) {
                u.push(g), g += p + v, c.push(Math.min(Math.max(v, h[e][0]), h[e][1]))
            })
        }

        function n(t, e, i) {
            var n = t[Ni], r = t[ur](), a = t[Te], o = t.get(Ce), s = i / 2;
            r.each(a, function () {
                function t(t) {
                    var i = [];
                    i[f] = h, i[p] = t;
                    var r;
                    return isNaN(h) || isNaN(t) ? r = [0 / 0, 0 / 0] : (r = n[Se](i), r[f] += e), r
                }

                function i(t, e) {
                    var i = t.slice(), n = t.slice();
                    i[f] += s, n[f] -= s, e ? x.push(i, n) : x.push(n, i)
                }

                function l(t) {
                    var e = [t.slice(), t.slice()];
                    e[0][f] -= s, e[1][f] += s, y.push(e)
                }

                var c = arguments, u = a[zn], h = c[0], d = c[u], f = o === Ae ? 0 : 1, p = 1 - f, v = t(c[3]), g = t(c[1]), m = t(c[5]), y = [[g, t(c[2])], [m, t(c[4])]];
                l(g), l(m), l(v);
                var x = [];
                i(y[0][1], 0), i(y[1][1], 1), r[Ve](d, {
                    chartLayout: o,
                    initBaseline: v[p],
                    median: v,
                    bodyEnds: x,
                    whiskerEnds: y
                })
            })
        }

        var r = t(vr), a = t(Be), o = a[Ee], s = r.each;
        return function (t) {
            var r = e(t);
            s(r, function (t) {
                var e = t.seriesModels;
                e[zn] && (i(t), s(e, function (e, i) {
                    n(e, t.boxOffsetList[i], t.boxWidthList[i])
                }))
            })
        }
    }),e("echarts/component/parallel", [gr, "../coord/parallel/parallelCreator", "../coord/parallel/ParallelModel", "./parallelAxis", pr, "../coord/parallel/parallelPreprocessor"], function (t) {
        t("../coord/parallel/parallelCreator"), t("../coord/parallel/ParallelModel"), t("./parallelAxis");
        var e = t(pr);
        e[cn]({type: "parallel"}), e.registerPreprocessor(t("../coord/parallel/parallelPreprocessor"))
    }),e("echarts/chart/funnel/FunnelView", [gr, vi, vr, "../../view/Chart"], function (t) {
        function e(t, e) {
            function i() {
                o[Wn] = o.hoverIgnore, s[Wn] = s.hoverIgnore
            }

            function r() {
                o[Wn] = o.normalIgnore, s[Wn] = s.normalIgnore
            }

            n.Group.call(this);
            var a = new n[R], o = new n[ci], s = new n.Text;
            this.add(a), this.add(o), this.add(s), this[li](t, e, !0), this.on(Ti, i).on(Li, r).on(Cn, i).on(An, r)
        }

        function i(t, e, i, n) {
            var a = n[Jn](nn), o = n.get(Ui), s = o === si || "inner" === o || o === ji;
            return {
                fill: a[$i]() || (s ? "#fff" : t[Mi](e, "color")),
                textFont: a[tn](),
                text: r[oi](t[ri][ai](e, i), t[xi](e))
            }
        }

        var n = t(vi), r = t(vr), a = e[ir], o = [ln, Li, Hi];
        a[li] = function (t, e, i) {
            var a = this[ni](0), s = t[ri], l = t[Ai](e), c = t[fi](e), u = t[Ai](e).get(o);
            u = null == u ? 1 : u, a[ti]({}), i ? (a[ii]({points: c[V]}), a[qi]({opacity: 0}), n[Ze](a, {style: {opacity: u}}, s, e)) : n[ei](a, {
                style: {opacity: u},
                shape: {points: c[V]}
            }, s, e);
            var h = l[Jn](ln), d = t[Mi](e, "color");
            a[qi](r[Vn]({fill: d}, h[Jn](Li)[Wi]([Hi]))), a[$e] = h[Jn](Ti)[Wi](), this._updateLabel(t, e), n[Ke](this)
        }, a._updateLabel = function (t, e) {
            var r = this[ni](1), a = this[ni](2), o = t[ri], s = t[Ai](e), l = t[fi](e), c = l.label, u = t[Mi](e, "color");
            n[ei](r, {shape: {points: c.linePoints || c.linePoints}}, o, e), n[ei](a, {
                style: {
                    x: c.x,
                    y: c.y
                }
            }, o, e), a.attr({
                style: {textAlign: c[en], textVerticalAlign: c.verticalAlign, textFont: c.font},
                rotation: c[Ye],
                origin: [c.x, c.y],
                z2: 10
            });
            var h = s[Jn](Xe), d = s[Jn](je), f = s[Jn]("labelLine.normal"), p = s[Jn]("labelLine.emphasis");
            a[qi](i(t, e, Li, h)), a[Wn] = a.normalIgnore = !h.get("show"), a.hoverIgnore = !d.get("show"), r[Wn] = r.normalIgnore = !f.get("show"), r.hoverIgnore = !p.get("show"), r[qi]({stroke: u}), r[qi](f[Jn](lr)[Ue]()), a[$e] = i(t, e, Ti, d), r[$e] = p[Jn](lr)[Ue]()
        }, r[on](e, n.Group);
        var s = t("../../view/Chart")[On]({
            type: "funnel", render: function (t) {
                var i = t[ur](), n = this._data, r = this.group;
                i.diff(n).add(function (t) {
                    var n = new e(i, t);
                    i[He](t, n), r.add(n)
                })[Gn](function (t, e) {
                    var a = n[pi](e);
                    a[li](i, t), r.add(a), i[He](t, a)
                })[En](function (t) {
                    var e = n[pi](t);
                    r[En](e)
                })[qe](), this._data = i
            }, remove: function () {
                this.group[rn](), this._data = null
            }
        });
        return s
    }),e("echarts/chart/funnel/funnelLayout", [gr, me, Be], function (t) {
        function e(t, e) {
            return r[Ki](t[Ji](), {width: e[Kn](), height: e[Yn]()})
        }

        function i(t, e) {
            for (var i = t[K]("value", function (t) {
                return t
            }), n = [], r = "ascending" === e, a = 0, o = t.count(); o > a; a++)n[a] = a;
            return n.sort(function (t, e) {
                return r ? i[t] - i[e] : i[e] - i[t]
            }), n
        }

        function n(t) {
            t.each(function (e) {
                var i, n, r, a, o = t[Ai](e), s = o[Jn](Xe), l = s.get(Ui), c = o[Jn]("labelLine.normal"), u = t[fi](e), h = u[V], d = "inner" === l || l === si || l === ji;
                if (d)n = (h[0][0] + h[1][0] + h[2][0] + h[3][0]) / 4, r = (h[0][1] + h[1][1] + h[2][1] + h[3][1]) / 4, i = ji, a = [[n, r], [n, r]]; else {
                    var f, p, v, g = c.get(zn);
                    "left" === l ? (f = (h[3][0] + h[0][0]) / 2, p = (h[3][1] + h[0][1]) / 2, v = f - g, n = v - 5, i = "right") : (f = (h[1][0] + h[2][0]) / 2, p = (h[1][1] + h[2][1]) / 2, v = f + g, n = v + 5, i = "left");
                    var m = p;
                    a = [[f, p], [v, m]], r = m
                }
                u.label = {linePoints: a, x: n, y: r, verticalAlign: "middle", textAlign: i, inside: d}
            })
        }

        var r = t(me), a = t(Be), o = a[Ee];
        return function (t, r) {
            t[hr]("funnel", function (t) {
                var s = t[ur](), l = t.get("sort"), c = e(t, r), u = i(s, l), h = [o(t.get("minSize"), c.width), o(t.get("maxSize"), c.width)], d = s[Re]("value"), f = t.get("min"), p = t.get("max");
                null == f && (f = Math.min(d[0], 0)), null == p && (p = d[1]);
                var v = t.get("funnelAlign"), g = t.get("gap"), m = (c[Fn] - g * (s.count() - 1)) / s.count(), y = c.y, x = function (t, e) {
                    var i, n = s.get("value", t) || 0, r = a[ze](n, [f, p], h, !0);
                    switch (v) {
                        case"left":
                            i = c.x;
                            break;
                        case ji:
                            i = c.x + (c.width - r) / 2;
                            break;
                        case"right":
                            i = c.x + c.width - r
                    }
                    return [[i, e], [i + r, e]]
                };
                "ascending" === l && (m = -m, g = -g, y += c[Fn], u = u[k]());
                for (var _ = 0; _ < u[zn]; _++) {
                    var w = u[_], b = u[_ + 1], M = x(w, y), S = x(b, y + m);
                    y += m + g, s[Ve](w, {points: M[Gi](S.slice()[k]())})
                }
                n(s)
            })
        }
    }),e("echarts/chart/parallel/parallelVisual", [gr], function () {
        return function (t) {
            t[hr](g, function (e) {
                var i = e[Jn](ie), n = t.get("color"), r = i.get("color") || n[e[bn] % n[zn]], a = e.get("inactiveOpacity"), o = e.get("activeOpacity"), s = e[Jn]("lineStyle.normal")[Ue](), l = e[Ni], c = e[ur](), u = {
                    normal: s[Hi],
                    active: o,
                    inactive: a
                };
                l.eachActiveState(c, function (t, e) {
                    c[wi](e, Hi, u[t])
                }), c[cr]("color", r)
            })
        }
    }),e("echarts/component/angleAxis", [gr, "../coord/polar/polarCreator", "./axis/AngleAxisView"], function (t) {
        t("../coord/polar/polarCreator"), t("./axis/AngleAxisView")
    }),e("echarts/component/marker/MarkPointModel", [gr, Ei, vr, Ri], function (t) {
        function e(t) {
            i[ki](t.label, i.LABEL_OPTIONS)
        }

        var i = t(Ei), n = t(vr), r = t(Ri)[un]({
            type: "markPoint",
            dependencies: [Dn, "grid", "polar"],
            init: function (t, e, i, n) {
                this[P](t, i), this[zi](t, i, n.createdBySelf, !0)
            },
            mergeOption: function (t, i, a, o) {
                a || i[In](function (t) {
                    var a = t.get("markPoint"), s = t.markPointModel;
                    if (!a || !a.data)return void(t.markPointModel = null);
                    if (s)s[zi](a, i, !0); else {
                        o && e(a), n.each(a.data, e);
                        var l = {mainType: "markPoint", seriesIndex: t[bn], name: t.name, createdBySelf: !0};
                        s = new r(a, this, i, l)
                    }
                    t.markPointModel = s
                }, this)
            },
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: "pin",
                symbolSize: 50,
                tooltip: {trigger: "item"},
                label: {normal: {show: !0, position: "inside"}, emphasis: {show: !0}},
                itemStyle: {normal: {borderWidth: 2}}
            }
        });
        return r
    }),e("echarts/component/marker/MarkPointView", [gr, "../../chart/helper/SymbolDraw", vr, Ie, Ei, Be, Bi, "./markerHelper", Ri], function (t) {
        function e(t, e, i) {
            var n = e[Ni];
            t.each(function (r) {
                var a, o = t[Ai](r), l = o[N]("x"), c = o[N]("y");
                if (null != l && null != c)a = [s[Ee](l, i[Kn]()), s[Ee](c, i[Yn]())]; else if (e.getMarkerPosition)a = e.getMarkerPosition(t.getValues(t[Te], r)); else if (n) {
                    var u = t.get(n[Te][0], r), h = t.get(n[Te][1], r);
                    a = n[Se]([u, h])
                }
                t[Ve](r, a)
            })
        }

        function i(t, e, i) {
            var n;
            n = t ? r.map(t && t[Te], function (t) {
                var i = e[ur]().getDimensionInfo(e[le](t)[0]) || {};
                return i.name = t, i
            }) : [{name: "value", type: "float"}];
            var a = new u(n, i), o = r.map(i.get("data"), r.curry(h.dataTransform, e));
            return t && (o = r[fr](o, r.curry(h.dataFilter, t))), a[Ii](o, null, t ? h.dimValueGetter : function (t) {
                return t.value
            }), a
        }

        var n = t("../../chart/helper/SymbolDraw"), r = t(vr), a = t(Ie), o = t(Ei), s = t(Be), l = a[ke], c = a[De], u = t(Bi), h = t("./markerHelper"), d = {
            formatTooltip: function (t) {
                var e = this[ur](), i = this[ye](t), n = r[gn](i) ? r.map(i, l).join(", ") : l(i), a = e[xi](t);
                return this.name + Le + ((a ? c(a) + " : " : "") + n)
            }, getData: function () {
                return this._data
            }, setData: function (t) {
                this._data = t
            }
        };
        r[Vn](d, o.dataFormatMixin), t(Ri)[cn]({
            type: "markPoint", init: function () {
                this._symbolDrawMap = {}
            }, render: function (t, e, i) {
                var n = this._symbolDrawMap;
                for (var r in n)n[r].__keep = !1;
                e[In](function (t) {
                    var e = t.markPointModel;
                    e && this._renderSeriesMP(t, e, i)
                }, this);
                for (var r in n)n[r].__keep || (n[r][En](), this.group[En](n[r].group))
            }, updateLayout: function (t, i, n) {
                i[In](function (t) {
                    var i = t.markPointModel;
                    i && (e(i[ur](), t, n), this._symbolDrawMap[t.name][Nn](i))
                }, this)
            }, _renderSeriesMP: function (t, a, o) {
                var s = t[Ni], l = t.name, c = t[ur](), u = this._symbolDrawMap, h = u[l];
                h || (h = u[l] = new n);
                var f = i(s, t, a);
                r.mixin(a, d), a.setData(f), e(a[ur](), t, o), f.each(function (t) {
                    var e = f[Ai](t), i = e[N](xe);
                    typeof i === fn && (i = i(a[ye](t), a[wn](t))), f[wi](t, {
                        symbolSize: i,
                        color: e.get(bi) || c[G]("color"),
                        symbol: e[N](_e)
                    })
                }), h[li](f), this.group.add(h.group), f[ne](function (t) {
                    t[yn](function (t) {
                        t.dataModel = a
                    })
                }), h.__keep = !0
            }
        })
    }),e("echarts/component/tooltip/TooltipView", [gr, "./TooltipContent", vi, vr, Ie, Be, sr, Ri], function (t) {
        function e(t, e) {
            if (!t || !e)return !1;
            var i = g.round;
            return i(t[0]) === i(e[0]) && i(t[1]) === i(e[1])
        }

        function i(t, e, i, n) {
            return {x1: t, y1: e, x2: i, y2: n}
        }

        function n(t, e, i, n) {
            return {x: t, y: e, width: i, height: n}
        }

        function r(t, e, i, n, r, a) {
            return {cx: t, cy: e, r0: i, r: n, startAngle: r, endAngle: a, clockwise: !0}
        }

        function a(t, e, i, n, r) {
            var a = i.clientWidth, o = i.clientHeight, s = 20;
            return t + a + s > n ? t -= a + s : t += s, e + o + s > r ? e -= o + s : e += s, [t, e]
        }

        function o(t, e, i) {
            var n = i.clientWidth, r = i.clientHeight, a = 5, o = 0, s = 0, l = e.width, c = e[Fn];
            switch (t) {
                case si:
                    o = e.x + l / 2 - n / 2, s = e.y + c / 2 - r / 2;
                    break;
                case"top":
                    o = e.x + l / 2 - n / 2, s = e.y - r - a;
                    break;
                case Hn:
                    o = e.x + l / 2 - n / 2, s = e.y + c + a;
                    break;
                case"left":
                    o = e.x - n - a, s = e.y + c / 2 - r / 2;
                    break;
                case"right":
                    o = e.x + l + a, s = e.y + c / 2 - r / 2
            }
            return [o, s]
        }

        function s(t, e, i, n, r, s, l) {
            var c = l[Kn](), u = l[Yn](), h = s && s[Qi]().clone();
            if (s && h[J](s[rr]), typeof t === fn && (t = t([e, i], r, n.el, h)), p[gn](t))e = m(t[0], c), i = m(t[1], u); else if (typeof t === er && s) {
                var f = o(t, h, n.el);
                e = f[0], i = f[1]
            } else {
                var f = a(e, i, n.el, c, u);
                e = f[0], i = f[1]
            }
            n[d](e, i)
        }

        function l(t) {
            var e = t[Ni], i = t.get("tooltip.trigger", !0);
            return !(!e || e.type !== ce && "polar" !== e.type && "single" !== e.type || "item" === i)
        }

        var c = t("./TooltipContent"), f = t(vi), p = t(vr), v = t(Ie), g = t(Be), m = g[Ee], _ = t(sr);
        t(Ri)[cn]({
            type: "tooltip", _axisPointers: {}, init: function (t, e) {
                if (!_.node) {
                    var i = new c(e.getDom(), e);
                    this._tooltipContent = i, e.on("showTip", this._manuallyShowTip, this), e.on("hideTip", this._manuallyHideTip, this)
                }
            }, render: function (t, e, i) {
                if (!_.node) {
                    this.group[rn](), this._axisPointers = {}, this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastHover = {};
                    var n = this._tooltipContent;
                    n[Gn](), n.enterable = t.get("enterable"), this._alwaysShowContent = t.get("alwaysShowContent"), this._seriesGroupByAxis = this._prepareAxisTriggerData(t, e);
                    var r = this._crossText;
                    if (r && this.group.add(r), null != this._lastX && null != this._lastY) {
                        var a = this;
                        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () {
                            a._manuallyShowTip({x: a._lastX, y: a._lastY})
                        })
                    }
                    var o = this._api.getZr();
                    o.off("click", this._tryShow), o.off(h, this._mousemove), o.off(An, this._hide), o.off("globalout", this._hide), "click" === t.get("triggerOn") ? o.on("click", this._tryShow, this) : (o.on(h, this._mousemove, this), o.on(An, this._hide, this), o.on("globalout", this._hide, this))
                }
            }, _mousemove: function (t) {
                var e = this._tooltipModel.get("showDelay"), i = this;
                clearTimeout(this._showTimeout), e > 0 ? this._showTimeout = setTimeout(function () {
                    i._tryShow(t)
                }, e) : this._tryShow(t)
            }, _manuallyShowTip: function (t) {
                if (t.from !== this.uid) {
                    var e = this._ecModel, i = t[bn], n = t[Mn], r = e.getSeriesByIndex(i), a = this._api;
                    if (null == t.x || null == t.y) {
                        if (r || e[In](function (t) {
                                l(t) && !r && (r = t)
                            }), r) {
                            var o = r[ur]();
                            null == n && (n = o[x](t.name));
                            var s, c, u = o[pi](n), h = r[Ni];
                            if (h && h[Se]) {
                                var d = h[Se](o.getValues(p.map(h[Te], function (t) {
                                    return r[le](t)[0]
                                }), n, !0));
                                s = d && d[0], c = d && d[1]
                            } else if (u) {
                                var f = u[Qi]().clone();
                                f[J](u[rr]), s = f.x + f.width / 2, c = f.y + f[Fn] / 2
                            }
                            null != s && null != c && this._tryShow({offsetX: s, offsetY: c, target: u, event: {}})
                        }
                    } else {
                        var u = a.getZr().handler.findHover(t.x, t.y);
                        this._tryShow({offsetX: t.x, offsetY: t.y, target: u, event: {}})
                    }
                }
            }, _manuallyHideTip: function (t) {
                t.from !== this.uid && this._hide()
            }, _prepareAxisTriggerData: function (t, e) {
                var i = {};
                return e[In](function (t) {
                    if (l(t)) {
                        var e, n, r = t[Ni];
                        r.type === ce ? (e = r[Me](), n = e.dim + e.index) : "single" === r.type ? (e = r[he](), n = e.dim + e.type) : (e = r[Me](), n = e.dim + r.name), i[n] = i[n] || {
                                coordSys: [],
                                series: []
                            }, i[n].coordSys.push(r), i[n][Dn].push(t)
                    }
                }, this), i
            }, _tryShow: function (t) {
                var e = t[Sn], i = this._tooltipModel, n = i.get(Pn), r = this._ecModel, a = this._api;
                if (i)if (this._lastX = t[F], this._lastY = t[Z], e && null != e[Mn]) {
                    var o = e.dataModel || r.getSeriesByIndex(e[bn]), s = e[Mn], l = o[ur]()[Ai](s);
                    "axis" === (l.get("tooltip.trigger") || n) ? this._showAxisTooltip(i, r, t) : (this._ticket = "", this._hideAxisPointer(), this._resetLastHover(), this._showItemTooltipContent(o, s, e[_n], t)), a[Rn]({
                        type: "showTip",
                        from: this.uid,
                        dataIndex: e[Mn],
                        seriesIndex: e[bn]
                    })
                } else"item" === n ? this._hide() : this._showAxisTooltip(i, r, t), "cross" === i.get("axisPointer.type") && a[Rn]({
                    type: "showTip",
                    from: this.uid,
                    x: t[F],
                    y: t[Z]
                })
            }, _showAxisTooltip: function (t, i, n) {
                var r = t[Jn]("axisPointer"), a = r.get("type");
                if ("cross" === a) {
                    var o = n[Sn];
                    if (o && null != o[Mn]) {
                        var s = i.getSeriesByIndex(o[bn]), l = o[Mn];
                        this._showItemTooltipContent(s, l, o[_n], n)
                    }
                }
                this._showAxisPointer();
                var c = !0;
                p.each(this._seriesGroupByAxis, function (t) {
                    var i = t.coordSys, o = i[0], s = [n[F], n[Z]];
                    if (!o.containPoint(s))return void this._hideAxisPointer(o.name);
                    c = !1;
                    var l = o[Te], u = o.pointToData(s, !0);
                    s = o[Se](u);
                    var h = o[Me](), d = r.get("axis");
                    "auto" === d && (d = h.dim);
                    var f = !1, v = this._lastHover;
                    if ("cross" === a)e(v.data, u) && (f = !0), v.data = u; else {
                        var g = p[vn](l, d);
                        v.data === u[g] && (f = !0), v.data = u[g]
                    }
                    o.type !== ce || f ? "polar" !== o.type || f ? "single" !== o.type || f || this._showSinglePointer(r, o, d, s) : this._showPolarPointer(r, o, d, s) : this._showCartesianPointer(r, o, d, s), "cross" !== a && this._dispatchAndShowSeriesTooltipContent(o, t[Dn], s, u, f)
                }, this), this._tooltipModel.get("show") || this._hideAxisPointer(), c && this._hide()
            }, _showCartesianPointer: function (t, e, r, a) {
                function o(n, r, a) {
                    var o = "x" === n ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]), s = l._getPointerElement(e, t, n, o);
                    u ? f[ei](s, {shape: o}, t) : s.attr({shape: o})
                }

                function s(i, r, a) {
                    var o = e[he](i), s = o.getBandWidth(), c = a[1] - a[0], h = "x" === i ? n(r[0] - s / 2, a[0], s, c) : n(a[0], r[1] - s / 2, c, s), d = l._getPointerElement(e, t, i, h);
                    u ? f[ei](d, {shape: h}, t) : d.attr({shape: h})
                }

                var l = this, c = t.get("type"), u = "cross" !== c;
                if ("cross" === c)o("x", a, e[he]("y").getGlobalExtent()), o("y", a, e[he]("x").getGlobalExtent()), this._updateCrossText(e, a, t); else {
                    var h = e[he]("x" === r ? "y" : "x"), d = h.getGlobalExtent();
                    e.type === ce && ("line" === c ? o : s)(r, a, d)
                }
            }, _showSinglePointer: function (t, e, n, r) {
                function a(n, r, a) {
                    var s = e[he](), c = s[u], h = c === Ae ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]), d = o._getPointerElement(e, t, n, h);
                    l ? f[ei](d, {shape: h}, t) : d.attr({shape: h})
                }

                var o = this, s = t.get("type"), l = "cross" !== s, c = e[Ci](), h = [c.y, c.y + c[Fn]];
                a(n, r, h)
            }, _showPolarPointer: function (t, e, n, a) {
                function o(n, r, a) {
                    var o, s = e.pointToCoord(r);
                    if ("angle" === n) {
                        var c = e.coordToPoint([a[0], s[1]]), u = e.coordToPoint([a[1], s[1]]);
                        o = i(c[0], c[1], u[0], u[1])
                    } else o = {cx: e.cx, cy: e.cy, r: s[0]};
                    var h = l._getPointerElement(e, t, n, o);
                    d ? f[ei](h, {shape: o}, t) : h.attr({shape: o})
                }

                function s(i, n, a) {
                    var o, s = e[he](i), c = s.getBandWidth(), u = e.pointToCoord(n), h = Math.PI / 180;
                    o = "angle" === i ? r(e.cx, e.cy, a[0], a[1], (-u[1] - c / 2) * h, (-u[1] + c / 2) * h) : r(e.cx, e.cy, u[0] - c / 2, u[0] + c / 2, 0, 2 * Math.PI);
                    var p = l._getPointerElement(e, t, i, o);
                    d ? f[ei](p, {shape: o}, t) : p.attr({shape: o})
                }

                var l = this, c = t.get("type"), u = e.getAngleAxis(), h = e.getRadiusAxis(), d = "cross" !== c;
                if ("cross" === c)o("angle", a, h[we]()), o(Oe, a, u[we]()), this._updateCrossText(e, a, t); else {
                    var p = e[he](n === Oe ? "angle" : Oe), v = p[we]();
                    ("line" === c ? o : s)(n, a, v)
                }
            }, _updateCrossText: function (t, e, i) {
                var n = i[Jn]("crossStyle"), r = n[Jn](nn), a = this._tooltipModel, o = this._crossText;
                o || (o = this._crossText = new f.Text({
                    style: {
                        textAlign: "left",
                        textVerticalAlign: "bottom"
                    }
                }), this.group.add(o));
                var s = t.pointToData(e), l = t[Te];
                s = p.map(s, function (e, i) {
                    var n = t[he](l[i]);
                    return e = n.type === be || "time" === n.type ? n.scale[ae](e) : v[ke](e[Di](n.getPixelPrecision()))
                }), o[qi]({
                    fill: r[$i]() || n.get("color"),
                    textFont: r[tn](),
                    text: s.join(", "),
                    x: e[0] + 5,
                    y: e[1] - 5
                }), o.z = a.get("z"), o[xn] = a.get(xn)
            }, _getPointerElement: function (t, e, i, n) {
                var r = this._tooltipModel, a = r.get("z"), o = r.get(xn), s = this._axisPointers, l = t.name;
                if (s[l] = s[l] || {}, s[l][i])return s[l][i];
                var c = e.get("type"), u = e[Jn](c + "Style"), h = "shadow" === c, d = u[h ? z : Ue](), p = "polar" === t.type ? h ? ui : i === Oe ? y : "Line" : h ? "Rect" : "Line";
                h ? d[Ne] = null : d.fill = null;
                var v = s[l][i] = new f[p]({style: d, z: a, zlevel: o, silent: !0, shape: n});
                return this.group.add(v), v
            }, _dispatchAndShowSeriesTooltipContent: function (t, e, i, n, r) {
                var a = this._tooltipModel, o = this._tooltipContent, l = t[Me](), c = p.map(e, function (t) {
                    return {
                        seriesIndex: t[bn],
                        dataIndex: t.getAxisTooltipDataIndex ? t.getAxisTooltipDataIndex(t[le](l.dim), n, l) : t[ur]().indexOfNearest(t[le](l.dim)[0], n["x" === l.dim || l.dim === Oe ? 0 : 1])
                    }
                }), u = this._lastHover, h = this._api;
                if (u.payloadBatch && !r && h[Rn]({
                        type: "downplay",
                        batch: u.payloadBatch
                    }), r || (h[Rn]({type: "highlight", batch: c}), u.payloadBatch = c), h[Rn]({
                        type: "showTip",
                        dataIndex: c[0][Mn],
                        seriesIndex: c[0][bn],
                        from: this.uid
                    }), l && a.get("showContent") && a.get("show")) {
                    var d, f = a.get(M), g = a.get(Ui), m = p.map(e, function (t, e) {
                        return t[wn](c[e][Mn])
                    });
                    o.show(a);
                    var y = c[0][Mn];
                    if (!r) {
                        if (this._ticket = "", f) {
                            if (typeof f === er)d = v.formatTpl(f, m); else if (typeof f === fn) {
                                var x = this, _ = "axis_" + t.name + "_" + y, w = function (t, e) {
                                    t === x._ticket && (o.setContent(e), s(g, i[0], i[1], o, m, null, h))
                                };
                                x._ticket = _, d = f(m, _, w)
                            }
                        } else {
                            var b = e[0][ur]()[xi](y);
                            d = (b ? b + Le : "") + p.map(e, function (t, e) {
                                    return t.formatTooltip(c[e][Mn], !0)
                                }).join(Le)
                        }
                        o.setContent(d)
                    }
                    s(g, i[0], i[1], o, m, null, h)
                }
            }, _showItemTooltipContent: function (t, e, i, n) {
                var r = this._api, a = t[ur](i), o = a[Ai](e), l = this._tooltipModel, c = this._tooltipContent, u = o[Jn]("tooltip");
                if (u.parentModel ? u.parentModel.parentModel = l : u.parentModel = this._tooltipModel, u.get("showContent") && u.get("show")) {
                    var h, d = u.get(M), f = u.get(Ui), p = t[wn](e, i);
                    if (d) {
                        if (typeof d === er)h = v.formatTpl(d, p); else if (typeof d === fn) {
                            var g = this, m = "item_" + t.name + "_" + e, y = function (t, e) {
                                t === g._ticket && (c.setContent(e), s(f, n[F], n[Z], c, p, n[Sn], r))
                            };
                            g._ticket = m, h = d(p, m, y)
                        }
                    } else h = t.formatTooltip(e, !1, i);
                    c.show(u), c.setContent(h), s(f, n[F], n[Z], c, p, n[Sn], r)
                }
            }, _showAxisPointer: function (t) {
                if (t) {
                    var e = this._axisPointers[t];
                    e && p.each(e, function (t) {
                        t.show()
                    })
                } else this.group[We](function (t) {
                    t.show()
                }), this.group.show()
            }, _resetLastHover: function () {
                var t = this._lastHover;
                t.payloadBatch && this._api[Rn]({type: "downplay", batch: t.payloadBatch}), this._lastHover = {}
            }, _hideAxisPointer: function (t) {
                if (t) {
                    var e = this._axisPointers[t];
                    e && p.each(e, function (t) {
                        t.hide()
                    })
                } else this.group.hide()
            }, _hide: function () {
                clearTimeout(this._showTimeout), this._hideAxisPointer(), this._resetLastHover(), this._alwaysShowContent || this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")), this._api[Rn]({
                    type: "hideTip",
                    from: this.uid
                }), this._lastX = this._lastY = null
            }, dispose: function (t, e) {
                if (!_.node) {
                    var i = e.getZr();
                    this._tooltipContent.hide(), i.off("click", this._tryShow), i.off(h, this._mousemove), i.off(An, this._hide), i.off("globalout", this._hide), e.off("showTip", this._manuallyShowTip), e.off("hideTip", this._manuallyHideTip)
                }
            }
        })
    }),e("echarts/component/timeline/typeDefaulter", [gr, c], function (t) {
        t(c).registerSubTypeDefaulter("timeline", function () {
            return "slider"
        })
    }),e("echarts/component/timeline/timelineAction", [gr, Ri], function (t) {
        var e = t(Ri);
        e[pn]({type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate"}, function (t, e) {
            var i = e[ve]("timeline");
            i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)), e.resetOption("timeline")
        }), e[pn]({type: "timelinePlayChange", event: "timelinePlayChanged", update: "update"}, function (t, e) {
            var i = e[ve]("timeline");
            i && null != t.playState && i.setPlayState(t.playState)
        })
    }),e("echarts/component/timeline/SliderTimelineModel", [gr, "./TimelineModel", vr, Ei], function (t) {
        var e = t("./TimelineModel"), i = t(vr), n = t(Ei), r = e[On]({
            type: "timeline.slider",
            defaultOption: {
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                orient: "horizontal",
                inverse: !1,
                tooltip: {trigger: "item"},
                symbol: "emptyCircle",
                symbolSize: 10,
                lineStyle: {show: !0, width: 2, color: "#304654"},
                label: {
                    position: "auto",
                    normal: {show: !0, interval: "auto", rotate: 0, textStyle: {color: "#304654"}},
                    emphasis: {show: !0, textStyle: {color: "#c23531"}}
                },
                itemStyle: {normal: {color: "#304654", borderWidth: 1}, emphasis: {color: "#c23531"}},
                checkpointStyle: {
                    symbol: "circle",
                    symbolSize: 13,
                    color: "#c23531",
                    borderWidth: 5,
                    borderColor: "rgba(194,53,49, 0.5)",
                    animation: !0,
                    animationDuration: 300,
                    animationEasing: "quinticInOut"
                },
                controlStyle: {
                    show: !0,
                    showPlayBtn: !0,
                    showPrevBtn: !0,
                    showNextBtn: !0,
                    itemSize: 22,
                    itemGap: 12,
                    position: "left",
                    playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
                    stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
                    nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
                    prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
                    normal: {color: "#304654", borderColor: "#304654", borderWidth: 1},
                    emphasis: {color: "#c23531", borderColor: "#c23531", borderWidth: 2}
                },
                data: []
            }
        });
        return i.mixin(r, n.dataFormatMixin), r
    }),e("echarts/chart/funnel/FunnelSeries", [gr, Bi, Ei, Oi, Ri], function (t) {
        var e = t(Bi), i = t(Ei), n = t(Oi), r = t(Ri).extendSeriesModel({
            type: "series.funnel",
            init: function (t) {
                r[Vi](this, "init", arguments), this.legendDataProvider = function () {
                    return this._dataBeforeProcessed
                }, this._defaultLabelLine(t)
            },
            getInitialData: function (t) {
                var i = n(["value"], t.data), r = new e(i, this);
                return r[Ii](t.data), r
            },
            _defaultLabelLine: function (t) {
                i[ki](t.labelLine, ["show"]);
                var e = t.labelLine[Li], n = t.labelLine[Ti];
                e.show = e.show && t.label[Li].show, n.show = n.show && t.label[Ti].show
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                left: 80,
                top: 60,
                right: 80,
                bottom: 60,
                minSize: "0%",
                maxSize: "100%",
                sort: "descending",
                gap: 0,
                funnelAlign: "center",
                label: {normal: {show: !0, position: "outer"}, emphasis: {show: !0}},
                labelLine: {normal: {show: !0, length: 20, lineStyle: {width: 1, type: "solid"}}, emphasis: {}},
                itemStyle: {normal: {borderColor: "#fff", borderWidth: 1}, emphasis: {}}
            }
        });
        return r
    }),e("echarts/component/marker/MarkLineModel", [gr, Ei, vr, Ri], function (t) {
        function e(t) {
            i[ki](t.label, i.LABEL_OPTIONS)
        }

        var i = t(Ei), n = t(vr), r = t(Ri)[un]({
            type: "markLine",
            dependencies: [Dn, "grid", "polar", "geo"],
            init: function (t, e, i, n) {
                this[P](t, i), this[zi](t, i, n.createdBySelf, !0)
            },
            mergeOption: function (t, i, a, o) {
                a || i[In](function (t) {
                    var a = t.get("markLine"), s = t.markLineModel;
                    if (!a || !a.data)return void(t.markLineModel = null);
                    if (s)s[zi](a, i, !0); else {
                        o && e(a), n.each(a.data, function (t) {
                            t instanceof Array ? (e(t[0]), e(t[1])) : e(t)
                        });
                        var l = {mainType: "markLine", seriesIndex: t[bn], name: t.name, createdBySelf: !0};
                        s = new r(a, this, i, l)
                    }
                    t.markLineModel = s
                }, this)
            },
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: [dr, "arrow"],
                symbolSize: [8, 16],
                precision: 2,
                tooltip: {trigger: "item"},
                label: {normal: {show: !0, position: "end"}, emphasis: {show: !0}},
                lineStyle: {normal: {type: "dashed"}, emphasis: {width: 3}},
                animationEasing: "linear"
            }
        });
        return r
    }),e("echarts/component/dataZoom/DataZoomView", [gr, "../../view/Component"], function (t) {
        var e = t("../../view/Component");
        return e[On]({
            type: "dataZoom", render: function (t, e, i) {
                this.dataZoomModel = t, this[j] = e, this.api = i
            }, getTargetInfo: function () {
                function t(t, e, i, n) {
                    for (var r, a = 0; a < i[zn]; a++)if (i[a].model === t) {
                        r = i[a];
                        break
                    }
                    r || i.push(r = {model: t, axisModels: [], coordIndex: n}), r.axisModels.push(e)
                }

                var e = this.dataZoomModel, i = this[j], n = [], r = [], a = [];
                return e.eachTargetAxis(function (e, o) {
                    var s = i[ve](e.axis, o);
                    if (s) {
                        a.push(s);
                        var l = s.get("gridIndex"), c = s.get(Y);
                        if (null != l) {
                            var u = i[ve]("grid", l);
                            t(u, s, n, l)
                        } else if (null != c) {
                            var u = i[ve]("polar", c);
                            t(u, s, r, c)
                        }
                    }
                }, this), {cartesians: n, polars: r, axisModels: a}
            }
        })
    }),e("echarts/component/marker/MarkLineView", [gr, vr, Bi, Ie, Ei, Be, "./markerHelper", "../../chart/helper/LineDraw", Ri], function (t) {
        function e(t) {
            return !isNaN(t) && !isFinite(t)
        }

        function i(t, i, n, r) {
            var a = 1 - t, o = r[Te][t];
            return e(i[a]) && e(n[a]) && i[t] === n[t] && r[he](o).containData(i[t])
        }

        function n(t, e) {
            if (t.type === ce) {
                var n = e[0].coord, r = e[1].coord;
                if (n && r && (i(1, n, r, t) || i(0, n, r, t)))return !0
            }
            return f.dataFilter(t, e[0]) && f.dataFilter(t, e[1])
        }

        function r(t, i, n, r, a, o, s) {
            var l, c = o[Ni], h = t[Ai](i), d = h.get("x"), f = h.get("y");
            if (null != d && null != f)l = [u[Ee](d, s[Kn]()), u[Ee](f, s[Yn]())]; else {
                if (o.getMarkerPosition)l = o.getMarkerPosition(t.getValues(t[Te], i)); else {
                    var p = c[Te], v = t.get(p[0], i), g = t.get(p[1], i);
                    l = c[Se]([v, g])
                }
                if (c.type === ce) {
                    var m = c[he]("x"), y = c[he]("y"), p = c[Te];
                    e(t.get(p[0], i)) ? l[0] = m.toGlobalCoord(m[we]()[n ? 0 : 1]) : e(t.get(p[1], i)) && (l[1] = y.toGlobalCoord(y[we]()[n ? 0 : 1]))
                }
            }
            t[Ve](i, l)
        }

        function a(t, e, i) {
            var r;
            r = t ? o.map(t && t[Te], function (t) {
                var i = e[ur]().getDimensionInfo(e[le](t)[0]) || {};
                return i.name = t, i
            }) : [{name: "value", type: "float"}];
            var a = new s(r, i), l = new s(r, i), c = new s([], i), u = o.map(i.get("data"), o.curry(v, e, t, i));
            t && (u = o[fr](u, o.curry(n, t)));
            var h = t ? f.dimValueGetter : function (t) {
                return t.value
            };
            return a[Ii](o.map(u, function (t) {
                return t[0]
            }), null, h), l[Ii](o.map(u, function (t) {
                return t[1]
            }), null, h), c[Ii](o.map(u, function (t) {
                return t[2]
            })), {from: a, to: l, line: c}
        }

        var o = t(vr), s = t(Bi), l = t(Ie), c = t(Ei), u = t(Be), h = l[ke], d = l[De], f = t("./markerHelper"), p = t("../../chart/helper/LineDraw"), v = function (t, e, i, n) {
            var r = t[ur](), a = n.type;
            if (!o[gn](n) && ("min" === a || "max" === a || "average" === a || null != n.xAxis || null != n.yAxis)) {
                var s, l, c;
                if (null != n.yAxis || null != n.xAxis)l = null != n.yAxis ? "y" : "x", s = e[he](l), c = o[oi](n.yAxis, n.xAxis); else {
                    var u = f.getAxisInfo(n, r, e, t);
                    l = u.valueDataDim, s = u.valueAxis, c = f.numCalculate(r, l, a)
                }
                var h = "x" === l ? 0 : 1, d = 1 - h, p = o.clone(n), v = {};
                p.type = null, p.coord = [], v.coord = [], p.coord[d] = -1 / 0, v.coord[d] = 1 / 0;
                var g = i.get("precision");
                g >= 0 && (c = +c[Di](g)), p.coord[h] = v.coord[h] = c, n = [p, v, {
                    type: a,
                    valueIndex: n.valueIndex,
                    value: c
                }]
            }
            return n = [f.dataTransform(t, n[0]), f.dataTransform(t, n[1]), o[On]({}, n[2])], n[2].type = n[2].type || "", o.merge(n[2], n[0]), o.merge(n[2], n[1]), n
        }, g = {
            formatTooltip: function (t) {
                var e = this._data, i = this[ye](t), n = o[gn](i) ? o.map(i, h).join(", ") : h(i), r = e[xi](t);
                return this.name + Le + ((r ? d(r) + " : " : "") + n)
            }, getData: function () {
                return this._data
            }, setData: function (t) {
                this._data = t
            }
        };
        o[Vn](g, c.dataFormatMixin), t(Ri)[cn]({
            type: "markLine", init: function () {
                this._markLineMap = {}
            }, render: function (t, e, i) {
                var n = this._markLineMap;
                for (var r in n)n[r].__keep = !1;
                e[In](function (t) {
                    var n = t.markLineModel;
                    n && this._renderSeriesML(t, n, e, i)
                }, this);
                for (var r in n)n[r].__keep || this.group[En](n[r].group)
            }, updateLayout: function (t, e, i) {
                e[In](function (t) {
                    var e = t.markLineModel;
                    if (e) {
                        var n = e[ur](), a = e.__from, o = e.__to;
                        a.each(function (e) {
                            var s = n[Ai](e), l = s.get("type"), c = s.get("valueIndex");
                            r(a, e, !0, l, c, t, i), r(o, e, !1, l, c, t, i)
                        }), n.each(function (t) {
                            n[Ve](t, [a[fi](t), o[fi](t)])
                        }), this._markLineMap[t.name][Nn]()
                    }
                }, this)
            }, _renderSeriesML: function (t, e, i, n) {
                function s(e, i, a, o, s) {
                    var l = e[Ai](i);
                    r(e, i, a, o, s, t, n), e[wi](i, {
                        symbolSize: l.get(xe) || _[a ? 0 : 1],
                        symbol: l.get(_e, !0) || x[a ? 0 : 1],
                        color: l.get(bi) || u[G]("color")
                    })
                }

                var l = t[Ni], c = t.name, u = t[ur](), h = this._markLineMap, d = h[c];
                d || (d = h[c] = new p), this.group.add(d.group);
                var f = a(l, t, e), v = f.from, m = f.to, y = f.line;
                e.__from = v, e.__to = m, o[On](e, g), e.setData(y);
                var x = e.get(_e), _ = e.get(xe);
                o[gn](x) || (x = [x, x]), typeof _ === sn && (_ = [_, _]), f.from.each(function (t) {
                    var e = y[Ai](t), i = e.get("type"), n = e.get("valueIndex");
                    s(v, t, !0, i, n), s(m, t, !1, i, n)
                }), y.each(function (t) {
                    var e = y[Ai](t).get("lineStyle.normal.color");
                    y[wi](t, {color: e || v[Mi](t, "color")}), y[Ve](t, [v[fi](t), m[fi](t)]), y[wi](t, {
                        fromSymbolSize: v[Mi](t, xe),
                        fromSymbol: v[Mi](t, _e),
                        toSymbolSize: m[Mi](t, xe),
                        toSymbol: m[Mi](t, _e)
                    })
                }), d[li](y), f.line[ne](function (t) {
                    t[yn](function (t) {
                        t.dataModel = e
                    })
                }), d.__keep = !0
            }
        })
    }),e("echarts/component/dataZoom/SliderZoomModel", [gr, "./DataZoomModel"], function (t) {
        var e = t("./DataZoomModel"), i = e[On]({
            type: "dataZoom.slider",
            layoutMode: "box",
            defaultOption: {
                show: !0,
                right: "ph",
                top: "ph",
                width: "ph",
                height: "ph",
                left: null,
                bottom: null,
                backgroundColor: "rgba(47,69,84,0)",
                dataBackgroundColor: "#ddd",
                fillerColor: "rgba(47,69,84,0.15)",
                handleColor: "rgba(148,164,165,0.95)",
                handleSize: 10,
                labelPrecision: null,
                labelFormatter: null,
                showDetail: !0,
                showDataShadow: "auto",
                realtime: !0,
                zoomLock: !1,
                textStyle: {color: "#333"}
            },
            mergeOption: function () {
                i[Vi](this, zi, arguments)
            }
        });
        return i
    }),e("echarts/component/dataZoom/InsideZoomModel", [gr, "./DataZoomModel"], function (t) {
        return t("./DataZoomModel")[On]({type: "dataZoom.inside", defaultOption: {zoomLock: !1}})
    }),e("echarts/component/dataZoom/SliderZoomView", [gr, vr, vi, "../../util/throttle", "./DataZoomView", Be, me, "../helper/sliderMove"], function (t) {
        function e(t) {
            return "x" === t ? "y" : "x"
        }

        var i = t(vr), n = t(vi), r = t("../../util/throttle"), a = t("./DataZoomView"), o = n.Rect, s = t(Be), l = s[ze], c = t(me), h = t("../helper/sliderMove"), d = s.asc, p = i.bind, v = Math.round, g = Math.max, m = i.each, y = 7, x = 1, _ = 30, w = Ae, b = f, M = 5, S = ["line", "bar", "candlestick", "scatter"], A = a[On]({
            type: "dataZoom.slider",
            init: function (t, e) {
                this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._halfHandleSize, this._location, this._dragging, this._dataShadowInfo, this.api = e
            },
            render: function (t, e, i, n) {
                return A[Vi](this, Tn, arguments), r.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get(u), this._halfHandleSize = v(t.get("handleSize") / 2), this.dataZoomModel.get("show") === !1 ? void this.group[rn]() : (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(), void this._updateView())
            },
            remove: function () {
                A[Vi](this, En, arguments), r.clear(this, "_dispatchZoomAction")
            },
            dispose: function () {
                A[Vi](this, kn, arguments), r.clear(this, "_dispatchZoomAction")
            },
            _buildView: function () {
                var t = this.group;
                t[rn](), this._resetLocation(), this._resetInterval();
                var e = this._displayables.barGroup = new n.Group;
                this._renderBackground(), this._renderDataShadow(), this._renderHandle(), t.add(e), this._positionGroup()
            },
            _resetLocation: function () {
                var t = this.dataZoomModel, e = this.api, n = this._findCoordRect(), r = {
                    width: e[Kn](),
                    height: e[Yn]()
                }, a = this._orient === w ? {
                    right: r.width - n.x - n.width,
                    top: r[Fn] - _ - y,
                    width: n.width,
                    height: _
                } : {right: y, top: n.y, width: _, height: n[Fn]}, o = c.getLayoutParams(t[Pi]);
                i.each(["right", "top", "width", Fn], function (t) {
                    "ph" === o[t] && (o[t] = a[t])
                });
                var s = c[Ki](o, r, t[Yi]);
                this._location = {x: s.x, y: s.y}, this._size = [s.width, s[Fn]], this._orient === b && this._size[k]()
            },
            _positionGroup: function () {
                var t = this.group, e = this._location, i = this._orient, n = this.dataZoomModel.getFirstTargetAxisModel(), r = n && n.get(fe), a = this._displayables.barGroup, o = (this._dataShadowInfo || {}).otherAxisInverse;
                a.attr(i !== w || r ? i === w && r ? {scale: o ? [-1, 1] : [-1, -1]} : i !== b || r ? {
                    scale: o ? [-1, -1] : [-1, 1],
                    rotation: Math.PI / 2
                } : {scale: o ? [1, -1] : [1, 1], rotation: Math.PI / 2} : {scale: o ? [1, 1] : [1, -1]});
                var s = t[Qi]([a]);
                t[Ui][0] = e.x - s.x, t[Ui][1] = e.y - s.y
            },
            _getViewExtent: function () {
                var t = this._halfHandleSize, e = g(this._size[0], 4 * t), i = [t, e - t];
                return i
            },
            _renderBackground: function () {
                var t = this.dataZoomModel, e = this._size;
                this._displayables.barGroup.add(new o({
                    silent: !0,
                    shape: {x: 0, y: 0, width: e[0], height: e[1]},
                    style: {fill: t.get(jn)}
                }))
            },
            _renderDataShadow: function () {
                var t = this._dataShadowInfo = this._prepareDataShadowInfo();
                if (t) {
                    var e = this._size, i = t[Dn], r = i.getRawData(), a = i.getShadowDim ? i.getShadowDim() : t.otherDim, o = r[Re](a), s = .3 * (o[1] - o[0]);
                    o = [o[0] - s, o[1] + s];
                    var c = [0, e[1]], u = [0, e[0]], h = [[e[0], 0], [0, 0]], d = u[1] / (r.count() - 1), f = 0, p = Math.round(r.count() / e[0]);
                    r.each([a], function (t, e) {
                        if (p > 0 && e % p)return void(f += d);
                        var i = null == t || isNaN(t) || "" === t ? null : l(t, o, c, !0);
                        null != i && h.push([f, i]), f += d
                    }), this._displayables.barGroup.add(new n[ci]({
                        shape: {points: h},
                        style: {fill: this.dataZoomModel.get("dataBackgroundColor"), lineWidth: 0},
                        silent: !0,
                        z2: -20
                    }))
                }
            },
            _prepareDataShadowInfo: function () {
                var t = this.dataZoomModel, n = t.get("showDataShadow");
                if (n !== !1) {
                    var r, a = this[j];
                    return t.eachTargetAxis(function (o, s) {
                        var l = t.getAxisProxy(o.name, s).getTargetSeriesModels();
                        i.each(l, function (t) {
                            if (!(r || n !== !0 && i[vn](S, t.get("type")) < 0)) {
                                var l = e(o.name), c = a[ve](o.axis, s).axis;
                                r = {
                                    thisAxis: c,
                                    series: t,
                                    thisDim: o.name,
                                    otherDim: l,
                                    otherAxisInverse: t[Ni][ee](c)[fe]
                                }
                            }
                        }, this)
                    }, this), r
                }
            },
            _renderHandle: function () {
                var t = this._displayables, e = t.handles = [], i = t.handleLabels = [], r = this._displayables.barGroup, a = this._size;
                r.add(t.filler = new o({
                    draggable: !0,
                    cursor: "move",
                    drift: p(this._onDragMove, this, "all"),
                    ondragend: p(this._onDragEnd, this),
                    onmouseover: p(this._showDataInfo, this, !0),
                    onmouseout: p(this._showDataInfo, this, !1),
                    style: {fill: this.dataZoomModel.get("fillerColor"), textPosition: "inside"}
                })), r.add(new o(n.subPixelOptimizeRect({
                    silent: !0,
                    shape: {x: 0, y: 0, width: a[0], height: a[1]},
                    style: {stroke: this.dataZoomModel.get("dataBackgroundColor"), lineWidth: x, fill: "rgba(0,0,0,0)"}
                }))), m([0, 1], function (t) {
                    r.add(e[t] = new o({
                        style: {fill: this.dataZoomModel.get("handleColor")},
                        cursor: "move",
                        draggable: !0,
                        drift: p(this._onDragMove, this, t),
                        ondragend: p(this._onDragEnd, this),
                        onmouseover: p(this._showDataInfo, this, !0),
                        onmouseout: p(this._showDataInfo, this, !1)
                    }));
                    var a = this.dataZoomModel.textStyleModel;
                    this.group.add(i[t] = new n.Text({
                        silent: !0,
                        invisible: !0,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textVerticalAlign: "middle",
                            textAlign: "center",
                            fill: a[$i](),
                            textFont: a[tn]()
                        }
                    }))
                }, this)
            },
            _resetInterval: function () {
                var t = this._range = this.dataZoomModel.getPercentRange(), e = this._getViewExtent();
                this._handleEnds = [l(t[0], [0, 100], e, !0), l(t[1], [0, 100], e, !0)]
            },
            _updateInterval: function (t, e) {
                var i = this._handleEnds, n = this._getViewExtent();
                h(e, i, n, "all" === t || this.dataZoomModel.get("zoomLock") ? "rigid" : "cross", t), this._range = d([l(i[0], n, [0, 100], !0), l(i[1], n, [0, 100], !0)])
            },
            _updateView: function () {
                var t = this._displayables, e = this._handleEnds, i = d(e.slice()), n = this._size, r = this._halfHandleSize;
                m([0, 1], function (i) {
                    var a = t.handles[i];
                    a[ii]({x: e[i] - r, y: -1, width: 2 * r, height: n[1] + 2, r: 1})
                }, this), t.filler[ii]({
                    x: i[0],
                    y: 0,
                    width: i[1] - i[0],
                    height: this._size[1]
                }), this._updateDataInfo()
            },
            _updateDataInfo: function () {
                function t(t) {
                    var e = n.getTransform(i.handles[t], this.group), s = n.transformDirection(0 === t ? "right" : "left", e), l = this._halfHandleSize + M, u = n[J]([c[t] + (0 === t ? -l : l), this._size[1] / 2], e);
                    r[t][qi]({
                        x: u[0],
                        y: u[1],
                        textVerticalAlign: a === w ? Xi : s,
                        textAlign: a === w ? s : ji,
                        text: o[t]
                    })
                }

                var e = this.dataZoomModel, i = this._displayables, r = i.handleLabels, a = this._orient, o = ["", ""];
                if (e.get("showDetail")) {
                    var s, l;
                    e.eachTargetAxis(function (t, i) {
                        s || (s = e.getAxisProxy(t.name, i).getDataValueWindow(), l = this[j][ve](t.axis, i).axis)
                    }, this), s && (o = [this._formatLabel(s[0], l), this._formatLabel(s[1], l)])
                }
                var c = d(this._handleEnds.slice());
                t.call(this, 0), t.call(this, 1)
            },
            _formatLabel: function (t, e) {
                var n = this.dataZoomModel, r = n.get("labelFormatter");
                if (i.isFunction(r))return r(t);
                var a = n.get("labelPrecision");
                return (null == a || "auto" === a) && (a = e.getPixelPrecision()), t = null == t && isNaN(t) ? "" : e.type === be || "time" === e.type ? e.scale[ae](Math.round(t)) : t[Di](Math.min(a, 20)), i[an](r) && (t = r[mn]("{value}", t)), t
            },
            _showDataInfo: function (t) {
                t = this._dragging || t;
                var e = this._displayables.handleLabels;
                e[0].attr(q, !t), e[1].attr(q, !t)
            },
            _onDragMove: function (t, e, i) {
                this._dragging = !0;
                var n = this._applyBarTransform([e, i], !0);
                this._updateInterval(t, n[0]), this._updateView(), this.dataZoomModel.get("realtime") && this._dispatchZoomAction()
            },
            _onDragEnd: function () {
                this._dragging = !1, this._showDataInfo(!1), this._dispatchZoomAction()
            },
            _dispatchZoomAction: function () {
                var t = this._range;
                this.api[Rn]({
                    type: "dataZoom",
                    from: this.uid,
                    dataZoomId: this.dataZoomModel.id,
                    start: t[0],
                    end: t[1]
                })
            },
            _applyBarTransform: function (t, e) {
                var i = this._displayables.barGroup.getLocalTransform();
                return n[J](t, i, e)
            },
            _findCoordRect: function () {
                var t, e = this.getTargetInfo();
                if (e.cartesians[zn])t = e.cartesians[0].model[Ni][Ci](); else {
                    var i = this.api[Kn](), n = this.api[Yn]();
                    t = {x: .2 * i, y: .2 * n, width: .6 * i, height: .6 * n}
                }
                return t
            }
        });
        return A
    }),e("echarts/component/dataZoom/InsideZoomView", [gr, "./DataZoomView", vr, "../helper/sliderMove", "./roams"], function (t) {
        function e(t, e, i, r) {
            e = e.slice();
            var a = r.axisModels[0];
            if (a) {
                var o = n(t, a, i), l = o.signal * (e[1] - e[0]) * o.pixel / o.pixelLength;
                return s(l, e, [0, 100], "rigid"), e
            }
        }

        function i(t, e, i, a, o) {
            i = i.slice();
            var s = o.axisModels[0];
            if (s) {
                var l = n(e, s, a), c = l.pixel - l.pixelStart, u = c / l.pixelLength * (i[1] - i[0]) + i[0];
                return t = Math.max(t, 0), i[0] = (i[0] - u) * t + u, i[1] = (i[1] - u) * t + u, r(i)
            }
        }

        function n(t, e, i) {
            var n = e.axis, r = i.rectProvider(), a = {};
            return "x" === n.dim ? (a.pixel = t[0], a.pixelLength = r.width, a.pixelStart = r.x, a.signal = n[fe] ? 1 : -1) : (a.pixel = t[1], a.pixelLength = r[Fn], a.pixelStart = r.y, a.signal = n[fe] ? -1 : 1), a
        }

        function r(t) {
            var e = [0, 100];
            return !(t[0] <= e[1]) && (t[0] = e[1]), !(t[1] <= e[1]) && (t[1] = e[1]), !(t[0] >= e[0]) && (t[0] = e[0]), !(t[1] >= e[0]) && (t[1] = e[0]), t
        }

        var a = t("./DataZoomView"), o = t(vr), s = t("../helper/sliderMove"), l = t("./roams"), c = o.bind, u = a[On]({
            type: "dataZoom.inside", init: function () {
                this._range
            }, render: function (t, e, i, n) {
                u[Vi](this, Tn, arguments), l.shouldRecordRange(n, t.id) && (this._range = t.getPercentRange());
                var r = this.getTargetInfo().cartesians, a = o.map(r, function (t) {
                    return l.generateCoordId(t.model)
                });
                o.each(r, function (e) {
                    var n = e.model;
                    l[dn](i, {
                        coordId: l.generateCoordId(n),
                        allCoordIds: a,
                        coordinateSystem: n[Ni],
                        dataZoomId: t.id,
                        throttleRage: t.get("throttle", !0),
                        panGetRange: c(this._onPan, this, e),
                        zoomGetRange: c(this._onZoom, this, e)
                    })
                }, this)
            }, remove: function () {
                l.unregister(this.api, this.dataZoomModel.id), u[Vi](this, En, arguments), this._range = null
            }, dispose: function () {
                l.unregister(this.api, this.dataZoomModel.id), u[Vi](this, kn, arguments), this._range = null
            }, _onPan: function (t, i, n, r) {
                return this._range = e([n, r], this._range, i, t)
            }, _onZoom: function (t, e, n, r, a) {
                var o = this.dataZoomModel;
                return o[Pi].zoomLock ? this._range : this._range = i(1 / n, [r, a], this._range, e, t, o)
            }
        });
        return u
    }),e("echarts/component/timeline/preprocessor", [gr, vr], function (t) {
        function e(t) {
            var e = t.type, a = {number: "value", time: "time"};
            if (a[e] && (t.axisType = a[e], delete t.type), i(t), n(t, "controlPosition")) {
                var o = t.controlStyle || (t.controlStyle = {});
                n(o, Ui) || (o[Ui] = t.controlPosition), "none" !== o[Ui] || n(o, "show") || (o.show = !1, delete o[Ui]), delete t.controlPosition
            }
            r.each(t.data || [], function (t) {
                r[Bn](t) && !r[gn](t) && (!n(t, "value") && n(t, "name") && (t.value = t.name), i(t))
            })
        }

        function i(t) {
            var e = t[ln] || (t[ln] = {}), i = e[Ti] || (e[Ti] = {}), a = t.label || t.label || {}, o = a[Li] || (a[Li] = {}), s = {
                normal: 1,
                emphasis: 1
            };
            r.each(a, function (t, e) {
                s[e] || n(o, e) || (o[e] = t)
            }), i.label && !n(a, Ti) && (a[Ti] = i.label, delete i.label)
        }

        function n(t, e) {
            return t.hasOwnProperty(e)
        }

        var r = t(vr);
        return function (t) {
            var i = t && t.timeline;
            r[gn](i) || (i = i ? [i] : []), r.each(i, function (t) {
                t && e(t)
            })
        }
    }),e("echarts/component/visualMapContinuous", [gr, pr, "./visualMap/preprocessor", "./visualMap/typeDefaulter", "./visualMap/visualCoding", "./visualMap/ContinuousModel", "./visualMap/ContinuousView", "./visualMap/visualMapAction"], function (t) {
        t(pr).registerPreprocessor(t("./visualMap/preprocessor")), t("./visualMap/typeDefaulter"), t("./visualMap/visualCoding"), t("./visualMap/ContinuousModel"), t("./visualMap/ContinuousView"), t("./visualMap/visualMapAction")
    }),e("echarts/component/visualMapPiecewise", [gr, pr, "./visualMap/preprocessor", "./visualMap/typeDefaulter", "./visualMap/visualCoding", "./visualMap/PiecewiseModel", "./visualMap/PiecewiseView", "./visualMap/visualMapAction"], function (t) {
        t(pr).registerPreprocessor(t("./visualMap/preprocessor")), t("./visualMap/typeDefaulter"), t("./visualMap/visualCoding"), t("./visualMap/PiecewiseModel"), t("./visualMap/PiecewiseView"), t("./visualMap/visualMapAction")
    }),e("echarts/component/toolbox/ToolboxModel", [gr, "./featureManager", vr, Ri], function (t) {
        var e = t("./featureManager"), i = t(vr), n = t(Ri)[un]({
            type: "toolbox",
            layoutMode: {type: "box", ignoreSize: !0},
            mergeDefaultAndTheme: function () {
                n[Vi](this, P, arguments), i.each(this[Pi].feature, function (t, n) {
                    var r = e.get(n);
                    r && i.merge(t, r.defaultOption)
                })
            },
            defaultOption: {
                show: !0,
                z: 6,
                zlevel: 0,
                orient: "horizontal",
                left: "right",
                top: "top",
                backgroundColor: "transparent",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemSize: 15,
                itemGap: 8,
                showTitle: !0,
                iconStyle: {normal: {borderColor: "#666", color: "none"}, emphasis: {borderColor: "#3E98C5"}}
            }
        });
        return n
    }),e("echarts/component/dataZoom/typeDefaulter", [gr, c], function (t) {
        t(c).registerSubTypeDefaulter("dataZoom", function () {
            return "slider"
        })
    }),e("echarts/component/timeline/SliderTimelineView", [gr, vr, vi, me, "./TimelineView", "./TimelineAxis", E, "../../coord/axisHelper", X, or, Be, Ie], function (t) {
        function e(t, e) {
            return s[Ki](t[Ji](), {width: e[Kn](), height: e[Yn]()}, t.get(Yi))
        }

        function i(t, e, i, n) {
            var r = o.makePath(t.get(e)[mn](/^path:\/\//, ""), a.clone(n || {}), new v(i[0], i[1], i[2], i[3]), ji);
            return r
        }

        function n(t, e, i, n, r, o) {
            var s = t.get(_e), l = e.get("color"), c = t.get(xe), u = c / 2, h = e[Wi](["color", _e, xe]);
            return r ? (r[qi](h), r.setColor(l), i.add(r), o && o.onUpdate(r)) : (r = d[O](s, -u, -u, c, c, l), i.add(r), o && o.onCreate(r)), n = a.merge({
                rectHover: !0,
                style: h,
                z2: 100
            }, n, !0), r.attr(n), r
        }

        function r(t, e, i, n, r) {
            if (!t.dragging) {
                var a = n[Jn]("checkpointStyle"), o = i[te](n[ur]().get(["value"], e));
                r || !a.get(Je, !0) ? t.attr({position: [o, 0]}) : (t[Un](!0), t.animateTo({position: [o, 0]}, a.get("animationDuration", !0), a.get("animationEasing", !0)))
            }
        }

        var a = t(vr), o = t(vi), s = t(me), c = t("./TimelineView"), h = t("./TimelineAxis"), d = t(E), p = t("../../coord/axisHelper"), v = t(X), g = t(or), m = t(Be), y = t(Ie), x = y[De], w = a.bind, b = a.each, S = Math.PI;
        return c[On]({
            type: "timeline.slider", init: function (t, e) {
                this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, this._labelGroup
            }, render: function (t, e, i) {
                if (this.model = t, this.api = i, this[j] = e, this.group[rn](), t.get("show", !0)) {
                    var n = this._layout(t, i), r = this._createGroup("mainGroup"), a = this._createGroup("labelGroup"), o = this._axis = this._createAxis(n, t);
                    t.formatTooltip = function (t) {
                        return x(o.scale[ae](t))
                    }, b(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function (e) {
                        this["_render" + e](n, r, o, t)
                    }, this), this._renderAxisLabel(n, a, o, t), this._position(n, t)
                }
                this._doPlayStop()
            }, remove: function () {
                this._clearTimer(), this.group[rn]()
            }, dispose: function () {
                this._clearTimer()
            }, _layout: function (t, i) {
                var n = t.get("label.normal.position"), r = t.get(u), a = e(t, i);
                null == n || "auto" === n ? n = r === Ae ? a.y + a[Fn] / 2 < i[Yn]() / 2 ? "-" : "+" : a.x + a.width / 2 < i[Kn]() / 2 ? "+" : "-" : isNaN(n) && (n = {
                    horizontal: {
                        top: "-",
                        bottom: "+"
                    }, vertical: {left: "-", right: "+"}
                }[r][n]);
                var o = {
                    horizontal: "center",
                    vertical: n >= 0 || "+" === n ? "left" : "right"
                }, s = {horizontal: n >= 0 || "+" === n ? "top" : Hn, vertical: "middle"}, l = {
                    horizontal: 0,
                    vertical: S / 2
                }, c = r === f ? a[Fn] : a.width, h = t[Jn]("controlStyle"), d = h.get("show"), p = d ? h.get("itemSize") : 0, v = d ? h.get("itemGap") : 0, g = p + v, m = t.get("label.normal.rotate") || 0;
                m = m * S / 180;
                var y, x, _, w, b = h.get(Ui, !0), d = h.get("show", !0), M = d && h.get("showPlayBtn", !0), A = d && h.get("showPrevBtn", !0), C = d && h.get("showNextBtn", !0), T = 0, L = c;
                return "left" === b || b === Hn ? (M && (y = [0, 0], T += g), A && (x = [T, 0], T += g), C && (_ = [L - p, 0], L -= g)) : (M && (y = [L - p, 0], L -= g), A && (x = [0, 0], T += g), C && (_ = [L - p, 0], L -= g)), w = [T, L], t.get(fe) && w[k](), {
                    viewRect: a,
                    mainLength: c,
                    orient: r,
                    rotation: l[r],
                    labelRotation: m,
                    labelPosOpt: n,
                    labelAlign: o[r],
                    labelBaseline: s[r],
                    playPosition: y,
                    prevBtnPosition: x,
                    nextBtnPosition: _,
                    axisExtent: w,
                    controlSize: p,
                    controlGap: v
                }
            }, _position: function (t) {
                function e(t) {
                    var e = t[Ui];
                    t.origin = [d[0][0] - e[0], d[1][0] - e[1]]
                }

                function i(t) {
                    return [[t.x, t.x + t.width], [t.y, t.y + t[Fn]]]
                }

                function n(t, e, i, n, r) {
                    t[n] += i[n][r] - e[n][r]
                }

                var r = this._mainGroup, a = this._labelGroup, o = t.viewRect;
                if (t[u] === f) {
                    var s = g[Zn](), c = o.x, h = o.y + o[Fn];
                    g.translate(s, s, [-c, -h]), g[l](s, s, -S / 2), g.translate(s, s, [c, h]), o = o.clone(), o[J](s)
                }
                var d = i(o), p = i(r[Qi]()), v = i(a[Qi]()), m = r[Ui], y = a[Ui];
                y[0] = m[0] = d[0][0];
                var x = t.labelPosOpt;
                if (isNaN(x)) {
                    var _ = "+" === x ? 0 : 1;
                    n(m, p, d, 1, _), n(y, v, d, 1, 1 - _)
                } else {
                    var _ = x >= 0 ? 0 : 1;
                    n(m, p, d, 1, _), y[1] = m[1] + x
                }
                r[Ui] = m, a[Ui] = y, r[Ye] = a[Ye] = t[Ye], e(r), e(a)
            }, _createAxis: function (t, e) {
                var i = e[ur](), n = e.get("axisType"), r = p.createScaleByModel(e, n), a = i[Re]("value");
                r[de](a[0], a[1]), this._customizeScale(r, i), r.niceTicks();
                var o = new h("value", r, t.axisExtent, n);
                return o.model = e, o
            }, _customizeScale: function (t, e) {
                t[oe] = function () {
                    return e[K](["value"], function (t) {
                        return t
                    })
                }, t.getTicksLabels = function () {
                    return a.map(this[oe](), t[ae], t)
                }
            }, _createGroup: function (t) {
                var e = this["_" + t] = new o.Group;
                return this.group.add(e), e
            }, _renderAxisLine: function (t, e, i, n) {
                var r = i[we]();
                n.get("lineStyle.show") && e.add(new o.Line({
                    shape: {x1: r[0], y1: 0, x2: r[1], y2: 0},
                    style: a[On]({lineCap: "round"}, n[Jn](lr)[Ue]()),
                    silent: !0,
                    z2: 1
                }))
            }, _renderAxisTick: function (t, e, i, r) {
                var a = r[ur](), s = i.scale[oe]();
                b(s, function (t, s) {
                    var l = i[te](t), c = a[Ai](s), u = c[Jn](ie), h = c[Jn]("itemStyle.emphasis"), d = {
                        position: [l, 0],
                        onclick: w(this._changeTimeline, this, s)
                    }, f = n(c, u, e, d);
                    o[Ke](f, h[Wi]()), c.get("tooltip") ? (f[Mn] = s, f.dataModel = r) : f[Mn] = f.dataModel = null
                }, this)
            }, _renderAxisLabel: function (t, e, i, n) {
                var r = n[Jn](Xe);
                if (r.get("show")) {
                    var a = n[ur](), s = i.scale[oe](), l = p[pe](i, r.get(M)), c = i.getLabelInterval();
                    b(s, function (n, r) {
                        if (!i.isLabelIgnored(r, c)) {
                            var s = a[Ai](r), u = s[Jn]("label.normal.textStyle"), h = s[Jn]("label.emphasis.textStyle"), d = i[te](n), f = new o.Text({
                                style: {
                                    text: l[r],
                                    textAlign: t.labelAlign,
                                    textVerticalAlign: t.labelBaseline,
                                    textFont: u[tn](),
                                    fill: u[$i]()
                                },
                                position: [d, 0],
                                rotation: t.labelRotation - t[Ye],
                                onclick: w(this._changeTimeline, this, r),
                                silent: !1
                            });
                            e.add(f), o[Ke](f, h[Wi]())
                        }
                    }, this)
                }
            }, _renderControl: function (t, e, n, r) {
                function a(t, n, a, d) {
                    if (t) {
                        var f = {
                            position: t,
                            origin: [s / 2, 0],
                            rotation: d ? -l : 0,
                            rectHover: !0,
                            style: c,
                            onclick: a
                        }, p = i(r, n, h, f);
                        e.add(p), o[Ke](p, u)
                    }
                }

                var s = t.controlSize, l = t[Ye], c = r[Jn]("controlStyle.normal")[Wi](), u = r[Jn]("controlStyle.emphasis")[Wi](), h = [0, -s / 2, s, s], d = r.getPlayState(), f = r.get(fe, !0);
                a(t.nextBtnPosition, "controlStyle.nextIcon", w(this._changeTimeline, this, f ? "-" : "+")), a(t.prevBtnPosition, "controlStyle.prevIcon", w(this._changeTimeline, this, f ? "+" : "-")), a(t.playPosition, "controlStyle." + (d ? "stopIcon" : "playIcon"), w(this._handlePlayClick, this, !d), !0)
            }, _renderCurrentPointer: function (t, e, i, a) {
                var o = a[ur](), s = a.getCurrentIndex(), l = o[Ai](s)[Jn]("checkpointStyle"), c = this, u = {
                    onCreate: function (t) {
                        t[_] = !0, t.drift = w(c._handlePointerDrag, c), t.ondragend = w(c._handlePointerDragend, c), r(t, s, i, a, !0)
                    }, onUpdate: function (t) {
                        r(t, s, i, a)
                    }
                };
                this._currentPointer = n(l, l, this._mainGroup, {}, this._currentPointer, u)
            }, _handlePlayClick: function (t) {
                this._clearTimer(), this.api[Rn]({type: "timelinePlayChange", playState: t, from: this.uid})
            }, _handlePointerDrag: function (t, e, i) {
                this._clearTimer(), this._pointerChangeTimeline([i[F], i[Z]])
            }, _handlePointerDragend: function (t) {
                this._pointerChangeTimeline([t[F], t[Z]], !0)
            }, _pointerChangeTimeline: function (t, e) {
                var i = this._toAxisCoord(t)[0], n = this._axis, r = m.asc(n[we]().slice());
                i > r[1] && (i = r[1]), i < r[0] && (i = r[0]), this._currentPointer[Ui][0] = i, this._currentPointer.dirty();
                var a = this._findNearestTick(i), o = this.model;
                (e || a !== o.getCurrentIndex() && o.get("realtime")) && this._changeTimeline(a)
            }, _doPlayStop: function () {
                function t() {
                    var t = this.model;
                    this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1))
                }

                this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(w(t, this), this.model.get("playInterval")))
            }, _toAxisCoord: function (t) {
                var e = this._mainGroup.getLocalTransform();
                return o[J](t, e, !0)
            }, _findNearestTick: function (t) {
                var e, i = this.model[ur](), n = 1 / 0, r = this._axis;
                return i.each(["value"], function (i, a) {
                    var o = r[te](i), s = Math.abs(o - t);
                    n > s && (n = s, e = a)
                }), e
            }, _clearTimer: function () {
                this._timer && (clearTimeout(this._timer), this._timer = null)
            }, _changeTimeline: function (t) {
                var e = this.model.getCurrentIndex();
                "+" === t ? t = e + 1 : "-" === t && (t = e - 1), this.api[Rn]({
                    type: "timelineChange",
                    currentIndex: t,
                    from: this.uid
                })
            }
        })
    }),e("echarts/component/toolbox/feature/SaveAsImage", [gr, sr, "../featureManager"], function (t) {
        function e(t) {
            this.model = t
        }

        var i = t(sr);
        e.defaultOption = {
            show: !0,
            icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
            title: "",
            type: "png",
            name: "",
            excludeComponents: ["toolbox"],
            pixelRatio: 1,
            lang: [""]
        }, e[ir].unusable = !i[Xn];
        var n = e[ir];
        return n.onclick = function (t, e) {
            var i = this.model, n = i.get("name") || t.get("title.0.text") || "echarts", r = document[Fi]("a"), a = i.get("type", !0) || "png";
            r.download = n + "." + a, r[Sn] = "_blank";
            var o = e.getConnectedDataURL({
                type: a,
                backgroundColor: i.get(jn, !0) || t.get(jn) || "#fff",
                excludeComponents: i.get("excludeComponents"),
                pixelRatio: i.get("pixelRatio")
            });
            if (r.href = o, typeof MouseEvent === fn) {
                var s = new MouseEvent("click", {view: window, bubbles: !0, cancelable: !1});
                r.dispatchEvent(s)
            } else {
                var l = i.get("lang"), c = '<body style="margin:0;"><img src="' + o + '" style="max-width:100%;" title="' + (l && l[0] || "") + '" /></body>', u = window.open();
                u.document.write(c)
            }
        }, t("../featureManager")[dn]("saveAsImage", e), e
    }),e("echarts/component/toolbox/feature/DataView", [gr, vr, "zrender/core/event", "../featureManager", "../../../echarts"], function (t) {
        function e(t) {
            var e = {}, i = [], n = [];
            return t.eachRawSeries(function (t) {
                var r = t[Ni];
                if (!r || r.type !== ce && "polar" !== r.type)i.push(t); else {
                    var a = r[Me]();
                    if (a.type === be) {
                        var o = a.dim + "_" + a.index;
                        e[o] || (e[o] = {categoryAxis: a, valueAxis: r[ee](a), series: []}, n.push({
                            axisDim: a.dim,
                            axisIndex: a.index
                        })), e[o][Dn].push(t)
                    } else i.push(t)
                }
            }), {seriesGroupByCategoryAxis: e, other: i, meta: n}
        }

        function i(t) {
            var e = [];
            return d.each(t, function (t) {
                var i = t.categoryAxis, n = t.valueAxis, r = n.dim, a = [" "][Gi](d.map(t[Dn], function (t) {
                    return t.name
                })), o = [i.model.getCategories()];
                d.each(t[Dn], function (t) {
                    o.push(t.getRawData()[K](r, function (t) {
                        return t
                    }))
                });
                for (var s = [a.join(v)], l = 0; l < o[0][zn]; l++) {
                    for (var c = [], u = 0; u < o[zn]; u++)c.push(o[u][l]);
                    s.push(c.join(v))
                }
                e.push(s.join("\n"))
            }), e.join("\n\n" + p + "\n\n")
        }

        function n(t) {
            return d.map(t, function (t) {
                var e = t.getRawData(), i = [t.name], n = [];
                return e.each(e[Te], function () {
                    for (var t = arguments[zn], r = arguments[t - 1], a = e[xi](r), o = 0; t - 1 > o; o++)n[o] = arguments[o];
                    i.push((a ? a + v : "") + n.join(v))
                }), i.join("\n")
            }).join("\n\n" + p + "\n\n")
        }

        function r(t) {
            var r = e(t);
            return {
                value: d[fr]([i(r.seriesGroupByCategoryAxis), n(r.other)], function (t) {
                    return t[mn](/[\n\t\s]/g, "")
                }).join("\n\n" + p + "\n\n"), meta: r.meta
            }
        }

        function a(t) {
            return t[mn](/^\s\s*/, "")[mn](/\s\s*$/, "")
        }

        function o(t) {
            var e = t.slice(0, t[vn]("\n"));
            return e[vn](v) >= 0 ? !0 : void 0
        }

        function s(t) {
            for (var e = t.split(/\n+/g), i = a(e.shift()).split(g), n = [], r = d.map(i, function (t) {
                return {name: t, data: []}
            }), o = 0; o < e[zn]; o++) {
                var s = a(e[o]).split(g);
                n.push(s.shift());
                for (var l = 0; l < s[zn]; l++)r[l] && (r[l].data[o] = s[l])
            }
            return {series: r, categories: n}
        }

        function l(t) {
            for (var e = t.split(/\n+/g), i = a(e.shift()), n = [], r = 0; r < e[zn]; r++) {
                var o, s = a(e[r]).split(g), l = "", c = !1;
                isNaN(s[0]) ? (c = !0, l = s[0], s = s.slice(1), n[r] = {
                    name: l,
                    value: []
                }, o = n[r].value) : o = n[r] = [];
                for (var u = 0; u < s[zn]; u++)o.push(+s[u]);
                1 === o[zn] && (c ? n[r].value = o[0] : n[r] = o[0])
            }
            return {name: i, data: n}
        }

        function c(t, e) {
            var i = t.split(new RegExp("\n*" + p + "\n*", "g")), n = {series: []};
            return d.each(i, function (t, i) {
                if (o(t)) {
                    var r = s(t), a = e[i], c = a.axisDim + "Axis";
                    a && (n[c] = n[c] || [], n[c][a.axisIndex] = {data: r[D]}, n[Dn] = n[Dn][Gi](r[Dn]))
                } else {
                    var r = l(t);
                    n[Dn].push(r)
                }
            }), n
        }

        function u(t) {
            this._dom = null, this.model = t
        }

        function h(t, e) {
            return d.map(t, function (t, i) {
                var n = e && e[i];
                return d[Bn](n) && !d[gn](n) ? (d[Bn](t) && !d[gn](t) && (t = t.value), d[Vn]({value: t}, n)) : t
            })
        }

        var d = t(vr), f = t("zrender/core/event"), p = new Array(60).join("-"), v = "	", g = new RegExp("[" + v + "]+", "g");
        return u.defaultOption = {
            show: !0,
            readOnly: !1,
            optionToContent: null,
            contentToOption: null,
            icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
            title: "",
            lang: ["", "", ""],
            backgroundColor: "#fff",
            textColor: "#000",
            textareaColor: "#fff",
            textareaBorderColor: "#333",
            buttonColor: "#c23531",
            buttonTextColor: "#fff"
        }, u[ir].onclick = function (t, e) {
            function i() {
                n.removeChild(o), S._dom = null
            }

            var n = e.getDom(), a = this.model;
            this._dom && n.removeChild(this._dom);
            var o = document[Fi]("div");
            o.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", o.style[jn] = a.get(jn) || "#fff";
            var s = document[Fi]("h4"), l = a.get("lang") || [];
            s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin: 10px 20px;", s.style.color = a.get("textColor");
            var u = document[Fi]("div"), h = document[Fi]("textarea");
            u.style.cssText = "display:block;width:100%;overflow:hidden;";
            var p = a.get("optionToContent"), g = a.get("contentToOption"), m = r(t);
            if (typeof p === fn) {
                var y = p(e.getOption());
                typeof y === er ? u.innerHTML = y : d.isDom(y) && u.appendChild(y)
            } else u.appendChild(h), h.readOnly = a.get("readOnly"), h.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", h.style.color = a.get("textColor"), h.style[Ge] = a.get("textareaBorderColor"), h.style[jn] = a.get("textareaColor"), h.value = m.value;
            var x = m.meta, _ = document[Fi]("div");
            _.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
            var w = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", b = document[Fi]("div"), M = document[Fi]("div");
            w += ";background-color:" + a.get("buttonColor"), w += ";color:" + a.get("buttonTextColor");
            var S = this;
            f.addEventListener(b, "click", i), f.addEventListener(M, "click", function () {
                var t;
                try {
                    t = typeof g === fn ? g(u, e.getOption()) : c(h.value, x)
                } catch (n) {
                    throw i(), new Error("Data view format error " + n)
                }
                t && e[Rn]({type: "changeDataView", newOption: t}), i()
            }), b.innerHTML = l[1], M.innerHTML = l[2], M.style.cssText = w, b.style.cssText = w, !a.get("readOnly") && _.appendChild(M), _.appendChild(b), f.addEventListener(h, "keydown", function (t) {
                if (9 === (t.keyCode || t.which)) {
                    var e = this.value, i = this.selectionStart, n = this.selectionEnd;
                    this.value = e.substring(0, i) + v + e.substring(n), this.selectionStart = this.selectionEnd = i + 1, f.stop(t)
                }
            }), o.appendChild(s), o.appendChild(u), o.appendChild(_), u.style[Fn] = n.clientHeight - 80 + "px", n.appendChild(o), this._dom = o
        }, u[ir][En] = function (t, e) {
            this._dom && e.getDom().removeChild(this._dom)
        }, u[ir][kn] = function (t, e) {
            this[En](t, e)
        }, t("../featureManager")[dn]("dataView", u), t("../../../echarts")[pn]({
            type: "changeDataView",
            event: "dataViewChanged",
            update: "prepareAndUpdate"
        }, function (t, e) {
            var i = [];
            d.each(t.newOption[Dn], function (t) {
                var n = e.getSeriesByName(t.name)[0];
                if (n) {
                    var r = n.get("data");
                    i.push({name: t.name, data: h(t.data, r)})
                } else i.push(d[On]({type: "scatter"}, t))
            }), e[zi](d[Vn]({series: i}, t.newOption))
        }), u
    }),e("echarts/component/toolbox/feature/DataZoom", [gr, vr, "../../../util/number", "../../helper/SelectController", X, "zrender/container/Group", "../../dataZoom/history", "../../helper/interactionMutex", "../../dataZoomSelect", "../featureManager", "../../../echarts"], function (t) {
        function e(t) {
            this.model = t, this._controllerGroup, this._controller, this._isZoomActive
        }

        function i(t, e) {
            var i = [{axisModel: t[he]("x").model, axisIndex: 0}, {axisModel: t[he]("y").model, axisIndex: 0}];
            return i.grid = t, e[qn]({mainType: "dataZoom", subType: "select"}, function (t) {
                n("xAxis", i[0].axisModel, t, e) && (i[0].dataZoomModel = t), n("yAxis", i[1].axisModel, t, e) && (i[1].dataZoomModel = t)
            }), i
        }

        function n(t, e, i, n) {
            var r = i.get(t + "Index");
            return null != r && n[ve](t, r) === e
        }

        function r(t, e) {
            var i = e.grid, n = new u(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
            if (n.intersect(i[Ci]())) {
                var r = i.getCartesian(e[0].axisIndex, e[1].axisIndex), a = r.pointToData([t[0][0], t[1][0]], !0), o = r.pointToData([t[0][1], t[1][1]], !0);
                return [v([a[0], o[0]]), v([a[1], o[1]])]
            }
        }

        function a(t, e, i) {
            var n = e[i], r = n.dataZoomModel;
            return r ? {dataZoomId: r.id, startValue: t[i][0], endValue: t[i][1]} : void 0
        }

        function o(t, e) {
            t.setIconStatus("back", d.count(e) > 1 ? Ti : Li)
        }

        var s = t(vr), l = t("../../../util/number"), c = t("../../helper/SelectController"), u = t(X), h = t("zrender/container/Group"), d = t("../../dataZoom/history"), f = t("../../helper/interactionMutex"), p = s.each, v = l.asc;
        t("../../dataZoomSelect");
        var g = "\x00_ec_\x00toolbox-dataZoom_";
        e.defaultOption = {
            show: !0,
            icon: {
                zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
                back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
            },
            title: {zoom: "", back: ""}
        };
        var m = e[ir];
        m[Tn] = function (t, e) {
            o(t, e)
        }, m.onclick = function (t, e, i) {
            var n = this._controllerGroup;
            this._controllerGroup || (n = this._controllerGroup = new h, e.getZr().add(n)), y[i].call(this, n, this.model, t, e)
        }, m[En] = function (t, e) {
            this._disposeController(), f.release("globalPan", e.getZr())
        }, m[kn] = function (t, e) {
            var i = e.getZr();
            f.release("globalPan", i), this._disposeController(), this._controllerGroup && i[En](this._controllerGroup)
        };
        var y = {
            zoom: function (t, e, i, n) {
                var r = this._isZoomActive = !this._isZoomActive, a = n.getZr();
                f[r ? "take" : "release"]("globalPan", a), e.setIconStatus("zoom", r ? Ti : Li), r ? (a.setDefaultCursorStyle("crosshair"), this._createController(t, e, i, n)) : (a.setDefaultCursorStyle("default"), this._disposeController())
            }, back: function (t, e, i, n) {
                this._dispatchAction(d.pop(i), n)
            }
        };
        return m._createController = function (t, e, i, n) {
            var r = this._controller = new c("rect", n.getZr(), {
                lineWidth: 3,
                stroke: "#333",
                fill: "rgba(0,0,0,0.2)"
            });
            r.on("selectEnd", s.bind(this._onSelected, this, r, e, i, n)), r[W](t, !1)
        }, m._disposeController = function () {
            var t = this._controller;
            t && (t.off(Qe), t[kn]())
        }, m._onSelected = function (t, e, n, o, s) {
            if (s[zn]) {
                var l = s[0];
                t[Gn]();
                var c = {};
                n[qn]("grid", function (t) {
                    var e = t[Ni], o = i(e, n), s = r(l, o);
                    if (s) {
                        var u = a(s, o, 0, "x"), h = a(s, o, 1, "y");
                        u && (c[u.dataZoomId] = u), h && (c[h.dataZoomId] = h)
                    }
                }, this), d.push(n, c), this._dispatchAction(c, o)
            }
        }, m._dispatchAction = function (t, e) {
            var i = [];
            p(t, function (t) {
                i.push(t)
            }), i[zn] && e[Rn]({type: "dataZoom", from: this.uid, batch: s.clone(i, !0)})
        }, t("../featureManager")[dn]("dataZoom", e), t("../../../echarts").registerPreprocessor(function (t) {
            function e(t, e) {
                if (e) {
                    var r = t + "Index", a = e[r];
                    null == a || s[gn](a) || (a = a === !1 ? [] : [a]), i(t, function (e, i) {
                        if (null == a || -1 !== s[vn](a, i)) {
                            var o = {type: "select", $fromToolbox: !0, id: g + t + i};
                            o[r] = i, n.push(o)
                        }
                    })
                }
            }

            function i(e, i) {
                var n = t[e];
                s[gn](n) || (n = n ? [n] : []), p(n, i)
            }

            if (t) {
                var n = t.dataZoom || (t.dataZoom = []);
                s[gn](n) || (t.dataZoom = n = [n]);
                var r = t.toolbox;
                if (r && (s[gn](r) && (r = r[0]), r && r.feature)) {
                    var a = r.feature.dataZoom;
                    e("xAxis", a), e("yAxis", a)
                }
            }
        }), e
    }),e("echarts/component/dataZoom/dataZoomProcessor", [gr, Ri], function (t) {
        function e(t, e, i) {
            i.getAxisProxy(t.name, e).reset(i)
        }

        function i(t, e, i) {
            i.getAxisProxy(t.name, e).filterData(i)
        }

        var n = t(Ri);
        n.registerProcessor(fr, function (t) {
            t[qn]("dataZoom", function (t) {
                t.eachTargetAxis(e), t.eachTargetAxis(i)
            }), t[qn]("dataZoom", function (t) {
                var e = t.findRepresentativeAxisProxy(), i = e.getDataPercentWindow(), n = e.getDataValueWindow();
                t.setRawRange({start: i[0], end: i[1], startValue: n[0], endValue: n[1]})
            })
        })
    }),e("echarts/component/dataZoom/dataZoomAction", [gr, vr, Ei, Ri], function (t) {
        var e = t(vr), i = t(Ei), n = t(Ri);
        n[pn]("dataZoom", function (t, n) {
            var r = i.createLinkedNodesFinder(e.bind(n[qn], n, "dataZoom"), i.eachAxisDim, function (t, e) {
                return t.get(e.axisIndex)
            }), a = [];
            n[qn]({mainType: "dataZoom", query: t}, function (t) {
                a.push.apply(a, r(t).nodes)
            }), e.each(a, function (e) {
                e.setRawRange({start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue})
            })
        })
    }),e("zrender/vml/Painter", [gr, "../core/log", "./core"], function (t) {
        function e(t) {
            return parseInt(t, 10)
        }

        function i(t, e) {
            a.initVML(), this.root = t, this.storage = e;
            var i = document[Fi]("div"), n = document[Fi]("div");
            i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this[$n]();
            var r = e.delFromMap, o = e.addToMap;
            e.delFromMap = function (t) {
                var i = e.get(t);
                r.call(e, t), i && i.onRemove && i.onRemove(n)
            }, e.addToMap = function (t) {
                t.onAdd && t.onAdd(n), o.call(e, t)
            }, this._firstPaint = !0
        }

        function n(t) {
            return function () {
                r('In IE8.0 VML mode painter not support method "' + t + '"')
            }
        }

        var r = t("../core/log"), a = t("./core");
        i[ir] = {
            constructor: i, getViewportRoot: function () {
                return this._vmlViewport
            }, refresh: function () {
                var t = this.storage.getDisplayList(!0, !0);
                this._paintList(t)
            }, _paintList: function (t) {
                for (var e = this._vmlRoot, i = 0; i < t[zn]; i++) {
                    var n = t[i];
                    n[q] || n[Wn] ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n[s] && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n[s] = !1
                }
                this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1)
            }, resize: function () {
                var t = this._getWidth(), e = this._getHeight();
                if (this._width != t && this._height != e) {
                    this._width = t, this._height = e;
                    var i = this._vmlViewport.style;
                    i.width = t + "px", i[Fn] = e + "px"
                }
            }, dispose: function () {
                this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null
            }, getWidth: function () {
                return this._width
            }, getHeight: function () {
                return this._height
            }, _getWidth: function () {
                var t = this.root, i = t.currentStyle;
                return (t.clientWidth || e(i.width)) - e(i.paddingLeft) - e(i.paddingRight) | 0
            }, _getHeight: function () {
                var t = this.root, i = t.currentStyle;
                return (t.clientHeight || e(i[Fn])) - e(i.paddingTop) - e(i.paddingBottom) | 0
            }
        };
        for (var o = ["getLayer", "insertLayer", "eachLayer", "eachBuildinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], l = 0; l < o[zn]; l++) {
            var c = o[l];
            i[ir][c] = n(c)
        }
        return i
    }),e("zrender/vml/graphic", [gr, "../core/env", "../core/vector", "../core/BoundingRect", "../core/PathProxy", "../tool/color", "../contain/text", "../graphic/mixin/RectText", "../graphic/Displayable", "../graphic/Image", "../graphic/Text", "../graphic/Path", "../graphic/Gradient", "./core"], function (t) {
        if (!t("../core/env")[Xn]) {
            var e = t("../core/vector"), i = t("../core/BoundingRect"), n = t("../core/PathProxy").CMD, r = t("../tool/color"), s = t("../contain/text"), l = t("../graphic/mixin/RectText"), c = t("../graphic/Displayable"), u = t("../graphic/Image"), h = t("../graphic/Text"), d = t("../graphic/Path"), f = t("../graphic/Gradient"), p = t("./core"), v = Math.round, g = Math.sqrt, y = Math.abs, x = Math.cos, _ = Math.sin, w = Math.max, b = e[J], M = ",", S = "progid:DXImageTransform.Microsoft", A = 21600, C = A / 2, T = 1e5, L = 1e3, k = function (t) {
                t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = A + "," + A, t.coordorigin = "0,0"
            }, D = function (t) {
                return String(t)[mn](/&/g, "&amp;")[mn](/"/g, "&quot;")
            }, I = function (t, e, i) {
                return "rgb(" + [t, e, i].join(",") + ")"
            }, P = function (t, e) {
                e && t && e[B] !== t && t.appendChild(e)
            }, z = function (t, e) {
                e && t && e[B] === t && t.removeChild(e)
            }, V = function (t, e, i) {
                return (parseFloat(t) || 0) * T + (parseFloat(e) || 0) * L + i
            }, R = function (t, e) {
                return typeof t === er ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
            }, O = function (t, e, i) {
                var n = r.parse(e);
                i = +i, isNaN(i) && (i = 1), n && (t.color = I(n[0], n[1], n[2]), t[Hi] = i * n[3])
            }, E = function (t) {
                var e = r.parse(t);
                return [I(e[0], e[1], e[2]), e[3]]
            }, N = function (t, e, i) {
                var n = e.fill;
                if (null != n)if (n instanceof f) {
                    var r, a = 0, o = [0, 0], s = 0, l = 1, c = i[Qi](), u = c.width, h = c[Fn];
                    if ("linear" === n.type) {
                        r = "gradient";
                        var d = i[rr], p = [n.x * u, n.y * h], v = [n.x2 * u, n.y2 * h];
                        d && (b(p, p, d), b(v, v, d));
                        var g = v[0] - p[0], m = v[1] - p[1];
                        a = 180 * Math.atan2(g, m) / Math.PI, 0 > a && (a += 360), 1e-6 > a && (a = 0)
                    } else {
                        r = "gradientradial";
                        var p = [n.x * u, n.y * h], d = i[rr], y = i.scale, x = u, _ = h;
                        o = [(p[0] - c.x) / x, (p[1] - c.y) / _], d && b(p, p, d), x /= y[0] * A, _ /= y[1] * A;
                        var M = w(x, _);
                        s = 0 / M, l = 2 * n.r / M - s
                    }
                    var S = n.colorStops.slice();
                    S.sort(function (t, e) {
                        return t.offset - e.offset
                    });
                    for (var C = S[zn], T = [], L = [], k = 0; C > k; k++) {
                        var D = S[k], I = E(D.color);
                        L.push(D.offset * l + s + " " + I[0]), (0 === k || k === C - 1) && T.push(I)
                    }
                    if (C >= 2) {
                        var P = T[0][0], z = T[1][0], V = T[0][1] * e[Hi], R = T[1][1] * e[Hi];
                        t.type = r, t.method = "none", t.focus = "100%", t.angle = a, t.color = P, t.color2 = z, t.colors = L.join(","), t[Hi] = R, t.opacity2 = V
                    }
                    "radial" === r && (t.focusposition = o.join(","))
                } else O(t, n, e[Hi])
            }, G = function (t, e) {
                null != e.lineJoin && (t.joinstyle = e.lineJoin), null != e.miterLimit && (t.miterlimit = e.miterLimit * A), null != e.lineCap && (t.endcap = e.lineCap), null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e[Ne] || e[Ne] instanceof f || O(t, e[Ne], e[Hi])
            }, Z = function (t, e, i, n) {
                var r = "fill" == e, a = t.getElementsByTagName(e)[0];
                null != i[e] && "none" !== i[e] && (r || !r && i[m]) ? (t[r ? "filled" : "stroked"] = "true", i[e] instanceof f && z(t, a), a || (a = p.createNode(e)), r ? N(a, i, n) : G(a, i), P(t, a)) : (t[r ? "filled" : "stroked"] = "false", z(t, a))
            }, F = [[], [], []], H = function (t, e) {
                var i, r, a, o, s, l, c = n.M, u = n.C, h = n.L, d = n.A, f = n.Q, p = [];
                for (o = 0; o < t[zn];) {
                    switch (a = t[o++], r = "", i = 0, a) {
                        case c:
                            r = " m ", i = 1, s = t[o++], l = t[o++], F[0][0] = s, F[0][1] = l;
                            break;
                        case h:
                            r = " l ", i = 1, s = t[o++], l = t[o++], F[0][0] = s, F[0][1] = l;
                            break;
                        case f:
                        case u:
                            r = " c ", i = 3;
                            var m, y, w = t[o++], S = t[o++], T = t[o++], L = t[o++];
                            a === f ? (m = T, y = L, T = (T + 2 * w) / 3, L = (L + 2 * S) / 3, w = (s + 2 * w) / 3, S = (l + 2 * S) / 3) : (m = t[o++], y = t[o++]), F[0][0] = w, F[0][1] = S, F[1][0] = T, F[1][1] = L, F[2][0] = m, F[2][1] = y, s = m, l = y;
                            break;
                        case d:
                            var k = 0, D = 0, I = 1, P = 1, z = 0;
                            e && (k = e[4], D = e[5], I = g(e[0] * e[0] + e[1] * e[1]), P = g(e[2] * e[2] + e[3] * e[3]), z = Math.atan2(-e[1] / P, e[0] / I));
                            var V = t[o++], R = t[o++], O = t[o++], E = t[o++], B = t[o++] + z, N = t[o++] + B + z;
                            o++;
                            var G = t[o++], Z = V + x(B) * O, H = R + _(B) * E, w = V + x(N) * O, S = R + _(N) * E, W = G ? " wa " : " at ";
                            Math.abs(Z - w) < 1e-10 && (Math.abs(N - B) > .01 ? G && (Z += 270 / A) : Math.abs(H - R) < 1e-10 ? G && V > Z || !G && Z > V ? S -= 270 / A : S += 270 / A : G && R > H || !G && H > R ? w += 270 / A : w -= 270 / A), p.push(W, v(((V - O) * I + k) * A - C), M, v(((R - E) * P + D) * A - C), M, v(((V + O) * I + k) * A - C), M, v(((R + E) * P + D) * A - C), M, v((Z * I + k) * A - C), M, v((H * P + D) * A - C), M, v((w * I + k) * A - C), M, v((S * P + D) * A - C)), s = w, l = S;
                            break;
                        case n.R:
                            var q = F[0], U = F[1];
                            q[0] = t[o++], q[1] = t[o++], U[0] = q[0] + t[o++], U[1] = q[1] + t[o++], e && (b(q, q, e), b(U, U, e)), q[0] = v(q[0] * A - C), U[0] = v(U[0] * A - C), q[1] = v(q[1] * A - C), U[1] = v(U[1] * A - C), p.push(" m ", q[0], M, q[1], " l ", U[0], M, q[1], " l ", U[0], M, U[1], " l ", q[0], M, U[1]);
                            break;
                        case n.Z:
                            p.push(" x ")
                    }
                    if (i > 0) {
                        p.push(r);
                        for (var j = 0; i > j; j++) {
                            var X = F[j];
                            e && b(X, X, e), p.push(v(X[0] * A - C), M, v(X[1] * A - C), i - 1 > j ? M : "")
                        }
                    }
                }
                return p.join("")
            };
            d[ir].brushVML = function (t) {
                var e = this.style, i = this._vmlEl;
                i || (i = p.createNode("shape"), k(i), this._vmlEl = i), Z(i, "fill", e, this), Z(i, Ne, e, this);
                var n = this[rr], r = null != n, s = i.getElementsByTagName(Ne)[0];
                if (s) {
                    var l = e[m];
                    if (r && !e.strokeNoScale) {
                        var c = n[0] * n[3] - n[1] * n[2];
                        l *= g(y(c))
                    }
                    s.weight = l + "px"
                }
                var u = this.path;
                this.__dirtyPath && (u[o](), this[a](u, this.shape), u.toStatic(), this.__dirtyPath = !1), i.path = H(u.data, this[rr]), i.style.zIndex = V(this[xn], this.z, this.z2), P(t, i), e.text ? this.drawRectText(t, this[Qi]()) : this.removeRectText(t)
            }, d[ir].onRemove = function (t) {
                z(t, this._vmlEl), this.removeRectText(t)
            }, d[ir].onAdd = function (t) {
                P(t, this._vmlEl), this.appendRectText(t)
            };
            var W = function (t) {
                return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
            };
            u[ir].brushVML = function (t) {
                var e, i, n = this.style, r = n.image;
                if (W(r)) {
                    var a = r.src;
                    if (a === this._imageSrc)e = this._imageWidth, i = this._imageHeight; else {
                        var o = r.runtimeStyle, s = o.width, l = o[Fn];
                        o.width = "auto", o[Fn] = "auto", e = r.width, i = r[Fn], o.width = s, o[Fn] = l, this._imageSrc = a, this._imageWidth = e, this._imageHeight = i
                    }
                    r = a
                } else r === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
                if (r) {
                    var c = n.x || 0, u = n.y || 0, h = n.width, d = n[Fn], f = n.sWidth, m = n.sHeight, y = n.sx || 0, x = n.sy || 0, _ = f && m, A = this._vmlEl;
                    A || (A = p.doc[Fi]("div"), k(A), this._vmlEl = A);
                    var C, T = A.style, L = !1, D = 1, I = 1;
                    if (this[rr] && (C = this[rr], D = g(C[0] * C[0] + C[1] * C[1]), I = g(C[2] * C[2] + C[3] * C[3]), L = C[1] || C[2]), L) {
                        var z = [c, u], R = [c + h, u], O = [c, u + d], E = [c + h, u + d];
                        b(z, z, C), b(R, R, C), b(O, O, C), b(E, E, C);
                        var N = w(z[0], R[0], O[0], E[0]), G = w(z[1], R[1], O[1], E[1]), Z = [];
                        Z.push("M11=", C[0] / D, M, "M12=", C[2] / I, M, "M21=", C[1] / D, M, "M22=", C[3] / I, M, "Dx=", v(c * D + C[4]), M, "Dy=", v(u * I + C[5])), T[Yi] = "0 " + v(N) + "px " + v(G) + "px 0", T[fr] = S + ".Matrix(" + Z.join("") + ", SizingMethod=clip)"
                    } else C && (c = c * D + C[4], u = u * I + C[5]), T[fr] = "", T.left = v(c) + "px", T.top = v(u) + "px";
                    var F = this._imageEl, H = this._cropEl;
                    F || (F = p.doc[Fi]("div"), this._imageEl = F);
                    var q = F.style;
                    if (_) {
                        if (e && i)q.width = v(D * e * h / f) + "px", q[Fn] = v(I * i * d / m) + "px"; else {
                            var U = new Image, j = this;
                            U.onload = function () {
                                U.onload = null, e = U.width, i = U[Fn], q.width = v(D * e * h / f) + "px", q[Fn] = v(I * i * d / m) + "px", j._imageWidth = e, j._imageHeight = i, j._imageSrc = r
                            }, U.src = r
                        }
                        H || (H = p.doc[Fi]("div"), H.style.overflow = "hidden", this._cropEl = H);
                        var X = H.style;
                        X.width = v((h + y * h / f) * D), X[Fn] = v((d + x * d / m) * I), X[fr] = S + ".Matrix(Dx=" + -y * h / f * D + ",Dy=" + -x * d / m * I + ")", H[B] || A.appendChild(H), F[B] != H && H.appendChild(F)
                    } else q.width = v(D * h) + "px", q[Fn] = v(I * d) + "px", A.appendChild(F), H && H[B] && (A.removeChild(H), this._cropEl = null);
                    var Y = "", K = n[Hi];
                    1 > K && (Y += ".Alpha(opacity=" + v(100 * K) + ") "), Y += S + ".AlphaImageLoader(src=" + r + ", SizingMethod=scale)", q[fr] = Y, A.style.zIndex = V(this[xn], this.z, this.z2), P(t, A), n.text && this.drawRectText(t, this[Qi]())
                }
            }, u[ir].onRemove = function (t) {
                z(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t)
            }, u[ir].onAdd = function (t) {
                P(t, this._vmlEl), this.appendRectText(t)
            };
            var q, U = Li, j = {}, X = 0, Y = 100, K = document[Fi]("div"), Q = function (t) {
                var e = j[t];
                if (!e) {
                    X > Y && (X = 0, j = {});
                    var i, n = K.style;
                    try {
                        n.font = t, i = n.fontFamily.split(",")[0]
                    } catch (r) {
                    }
                    e = {
                        style: n.fontStyle || U,
                        variant: n.fontVariant || U,
                        weight: n.fontWeight || U,
                        size: 0 | parseFloat(n.fontSize || 12),
                        family: i || "Microsoft YaHei"
                    }, j[t] = e, X++
                }
                return e
            };
            s.measureText = function (t, e) {
                var i = p.doc;
                q || (q = i[Fi]("div"), q.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", p.doc.body.appendChild(q));
                try {
                    q.style.font = e
                } catch (n) {
                }
                return q.innerHTML = "", q.appendChild(i.createTextNode(t)), {width: q.offsetWidth}
            };
            for (var $ = new i, te = function (t, e, i, n) {
                var r = this.style, a = r.text;
                if (a) {
                    var o, l, c = r[en], u = Q(r.textFont), h = u.style + " " + u.variant + " " + u.weight + " " + u.size + 'px "' + u.family + '"', d = r.textBaseline, f = r.textVerticalAlign;
                    i = i || s[Qi](a, h, c, d);
                    var g = this[rr];
                    if (g && !n && ($.copy(e), $[J](g), e = $), n)o = e.x, l = e.y; else {
                        var m = r.textPosition, y = r.textDistance;
                        if (m instanceof Array)o = e.x + R(m[0], e.width), l = e.y + R(m[1], e[Fn]), c = c || "left", d = d || "top"; else {
                            var x = s.adjustTextPositionOnRect(m, e, i, y);
                            o = x.x, l = x.y, c = c || x[en], d = d || x.textBaseline
                        }
                    }
                    if (f) {
                        switch (f) {
                            case Xi:
                                l -= i[Fn] / 2;
                                break;
                            case Hn:
                                l -= i[Fn]
                        }
                        d = "top"
                    }
                    var _ = u.size;
                    switch (d) {
                        case"hanging":
                        case"top":
                            l += _ / 1.75;
                            break;
                        case Xi:
                            break;
                        default:
                            l -= _ / 2.25
                    }
                    switch (c) {
                        case"left":
                            break;
                        case ji:
                            o -= i.width / 2;
                            break;
                        case"right":
                            o -= i.width
                    }
                    var w, S, A, C = p.createNode, T = this._textVmlEl;
                    T ? (A = T.firstChild, w = A.nextSibling, S = w.nextSibling) : (T = C("line"), w = C("path"), S = C("textpath"), A = C("skew"), S.style["v-text-align"] = "left", k(T), w.textpathok = !0, S.on = !0, T.from = "0 0", T.to = "1000 0.05", P(T, A), P(T, w), P(T, S), this._textVmlEl = T);
                    var L = [o, l], I = T.style;
                    g && n ? (b(L, L, g), A.on = !0, A.matrix = g[0][Di](3) + M + g[2][Di](3) + M + g[1][Di](3) + M + g[3][Di](3) + ",0,0", A.offset = (v(L[0]) || 0) + "," + (v(L[1]) || 0), A.origin = "0 0", I.left = "0px", I.top = "0px") : (A.on = !1, I.left = v(o) + "px", I.top = v(l) + "px"), S[er] = D(a);
                    try {
                        S.style.font = h
                    } catch (z) {
                    }
                    Z(T, "fill", {
                        fill: n ? r.fill : r.textFill,
                        opacity: r[Hi]
                    }, this), Z(T, Ne, {
                        stroke: n ? r[Ne] : r.textStroke,
                        opacity: r[Hi],
                        lineDash: r.lineDash
                    }, this), T.style.zIndex = V(this[xn], this.z, this.z2), P(t, T)
                }
            }, ee = function (t) {
                z(t, this._textVmlEl), this._textVmlEl = null
            }, ie = function (t) {
                P(t, this._textVmlEl)
            }, ne = [l, c, u, d, h], re = 0; re < ne[zn]; re++) {
                var ae = ne[re][ir];
                ae.drawRectText = te, ae.removeRectText = ee, ae.appendRectText = ie
            }
            h[ir].brushVML = function (t) {
                var e = this.style;
                e.text ? this.drawRectText(t, {
                    x: e.x || 0,
                    y: e.y || 0,
                    width: 0,
                    height: 0
                }, this[Qi](), !0) : this.removeRectText(t)
            }, h[ir].onRemove = function (t) {
                this.removeRectText(t)
            }, h[ir].onAdd = function (t) {
                this.appendRectText(t)
            }
        }
    }),e("echarts/chart/sankey/SankeyView", [gr, vi, vr, Ri], function (t) {
        function e(t, e, i) {
            var n = new a.Rect({shape: {x: t.x - 10, y: t.y - 10, width: 0, height: t[Fn] + 20}});
            return a[Ze](n, {shape: {width: t.width + 20, height: t[Fn] + 20}}, e, i), n
        }

        var a = t(vi), o = t(vr), s = a.extendShape({
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                cpx1: 0,
                cpy1: 0,
                cpx2: 0,
                cpy2: 0,
                extent: 0
            }, buildPath: function (t, e) {
                var a = e.extent / 2;
                t[d](e.x1, e.y1 - a), t[r](e.cpx1, e.cpy1 - a, e.cpx2, e.cpy2 - a, e.x2, e.y2 - a), t[n](e.x2, e.y2 + a), t[r](e.cpx2, e.cpy2 + a, e.cpx1, e.cpy1 + a, e.x1, e.y1 + a), t[i]()
            }
        });
        return t(Ri)[hn]({
            type: "sankey", _model: null, render: function (t) {
                var i = t[I](), n = this.group, r = t.layoutInfo, l = t[ur](), c = t[ur]("edge");
                this[Qn] = t, n[rn](), n[Ui] = [r.x, r.y], i.eachNode(function (e) {
                    var i = e[H](), r = e[Jn](), s = r[Jn](Xe), c = s[Jn](nn), u = r[Jn](je), h = u[Jn](nn), d = new a.Rect({
                        shape: {
                            x: i.x,
                            y: i.y,
                            width: e[H]().dx,
                            height: e[H]().dy
                        },
                        style: {
                            text: s.get("show") ? t[ai](e[Mn], Li) || e.id : "",
                            textFont: c[tn](),
                            textFill: c[$i](),
                            textPosition: s.get(Ui)
                        }
                    });
                    d[qi](o[Vn]({fill: e[G]("color")}, r[Jn](ie)[Wi]())), a[Ke](d, o[On](e[Jn]("itemStyle.emphasis"), {
                        text: u.get("show") ? t[ai](e[Mn], Ti) || e.id : "",
                        textFont: h[tn](),
                        textFill: h[$i](),
                        textPosition: u.get(Ui)
                    })), n.add(d), l[He](e[Mn], d), d[_n] = "node"
                }), i.eachEdge(function (e) {
                    var i = new s;
                    i[Mn] = e[Mn], i[bn] = t[bn], i[_n] = "edge";
                    var r = e[Jn]("lineStyle.normal"), o = r.get("curveness"), l = e.node1[H](), u = e.node2[H](), h = e[H]();
                    i.shape.extent = Math.max(1, h.dy);
                    var d = l.x + l.dx, f = l.y + h.sy + h.dy / 2, p = u.x, v = u.y + h.ty + h.dy / 2, g = d * (1 - o) + p * o, m = f, y = d * o + p * (1 - o), x = v;
                    i[ii]({
                        x1: d,
                        y1: f,
                        x2: p,
                        y2: v,
                        cpx1: g,
                        cpy1: m,
                        cpx2: y,
                        cpy2: x
                    }), i[qi](r[Wi]()), a[Ke](i, e[Jn]("lineStyle.emphasis")[Wi]()), n.add(i), c[He](e[Mn], i)
                }), !this._data && t.get(Je) && n.setClipPath(e(n[Qi](), t, function () {
                    n.removeClipPath()
                })), this._data = t[ur]()
            }
        })
    }),e("echarts/chart/sankey/sankeyLayout", [gr, me, "../../util/array/nest", vr], function (t) {
        function e(t, e) {
            return b[Ki](t[Ji](), {width: e[Kn](), height: e[Yn]()})
        }

        function i(t, e, i, n, a, o, l) {
            r(t, i, a), s(t, e, o, n, l), p(t)
        }

        function n(t) {
            S.each(t, function (t) {
                var e = m(t.outEdges, w), i = m(t.inEdges, w), n = Math.max(e, i);
                t[$]({value: n}, !0)
            })
        }

        function r(t, e, i) {
            for (var n = t, r = null, s = 0, l = 0; n[zn];) {
                r = [];
                for (var c = 0, u = n[zn]; u > c; c++) {
                    var h = n[c];
                    h[$]({x: s}, !0), h[$]({dx: e}, !0);
                    for (var d = 0, f = h.outEdges[zn]; f > d; d++)r.push(h.outEdges[d].node2)
                }
                n = r, ++s
            }
            a(t, s), l = (i - e) / (s - 1), o(t, l)
        }

        function a(t, e) {
            S.each(t, function (t) {
                t.outEdges[zn] || t[$]({x: e - 1}, !0)
            })
        }

        function o(t, e) {
            S.each(t, function (t) {
                var i = t[H]().x * e;
                t[$]({x: i}, !0)
            })
        }

        function s(t, e, i, n, r) {
            var a = M().key(function (t) {
                return t[H]().x
            }).sortKeys(_).entries(t).map(function (t) {
                return t.values
            });
            l(t, a, e, i, n), c(a, n, i);
            for (var o = 1; r > 0; r--)o *= .99, u(a, o), c(a, n, i), d(a, o), c(a, n, i)
        }

        function l(t, e, i, n, r) {
            var a = [];
            S.each(e, function (t) {
                var e = t[zn], i = 0;
                S.each(t, function (t) {
                    i += t[H]().value
                });
                var o = (n - (e - 1) * r) / i;
                a.push(o)
            }), a.sort(function (t, e) {
                return t - e
            });
            var o = a[0];
            S.each(e, function (t) {
                S.each(t, function (t, e) {
                    t[$]({y: e}, !0);
                    var i = t[H]().value * o;
                    t[$]({dy: i}, !0)
                })
            }), S.each(i, function (t) {
                var e = +t.getValue() * o;
                t[$]({dy: e}, !0)
            })
        }

        function c(t, e, i) {
            S.each(t, function (t) {
                var n, r, a, o = 0, s = t[zn];
                for (t.sort(x), a = 0; s > a; a++) {
                    if (n = t[a], r = o - n[H]().y, r > 0) {
                        var l = n[H]().y + r;
                        n[$]({y: l}, !0)
                    }
                    o = n[H]().y + n[H]().dy + e
                }
                if (r = o - e - i, r > 0) {
                    var l = n[H]().y - r;
                    for (n[$]({y: l}, !0), o = n[H]().y, a = s - 2; a >= 0; --a)n = t[a], r = n[H]().y + n[H]().dy + e - o, r > 0 && (l = n[H]().y - r, n[$]({y: l}, !0)), o = n[H]().y
                }
            })
        }

        function u(t, e) {
            S.each(t.slice()[k](), function (t) {
                S.each(t, function (t) {
                    if (t.outEdges[zn]) {
                        var i = m(t.outEdges, h) / m(t.outEdges, w), n = t[H]().y + (i - y(t)) * e;
                        t[$]({y: n}, !0)
                    }
                })
            })
        }

        function h(t) {
            return y(t.node2) * t.getValue()
        }

        function d(t, e) {
            S.each(t, function (t) {
                S.each(t, function (t) {
                    if (t.inEdges[zn]) {
                        var i = m(t.inEdges, f) / m(t.inEdges, w), n = t[H]().y + (i - y(t)) * e;
                        t[$]({y: n}, !0)
                    }
                })
            })
        }

        function f(t) {
            return y(t.node1) * t.getValue()
        }

        function p(t) {
            S.each(t, function (t) {
                t.outEdges.sort(v), t.inEdges.sort(g)
            }), S.each(t, function (t) {
                var e = 0, i = 0;
                S.each(t.outEdges, function (t) {
                    t[$]({sy: e}, !0), e += t[H]().dy
                }), S.each(t.inEdges, function (t) {
                    t[$]({ty: i}, !0), i += t[H]().dy
                })
            })
        }

        function v(t, e) {
            return t.node2[H]().y - e.node2[H]().y
        }

        function g(t, e) {
            return t.node1[H]().y - e.node1[H]().y
        }

        function m(t, e) {
            var i, n = 0, r = t[zn], a = -1;
            if (1 === arguments[zn])for (; ++a < r;)i = +t[a], isNaN(i) || (n += i); else for (; ++a < r;)i = +e.call(t, t[a], a), isNaN(i) || (n += i);
            return n
        }

        function y(t) {
            return t[H]().y + t[H]().dy / 2
        }

        function x(t, e) {
            return t[H]().y - e[H]().y
        }

        function _(t, e) {
            return e > t ? -1 : t > e ? 1 : t == e ? 0 : 0 / 0
        }

        function w(t) {
            return t.getValue()
        }

        var b = t(me), M = t("../../util/array/nest"), S = t(vr);
        return function (t, r) {
            t[hr]("sankey", function (t) {
                var a = t.get("nodeWidth"), o = t.get("nodeGap"), s = e(t, r);
                t.layoutInfo = s;
                var l = s.width, c = s[Fn], u = t[I](), h = u.nodes, d = u.edges;
                n(h);
                var f = h[fr](function (t) {
                    return 0 === t[H]().value
                }), p = 0 !== f[zn] ? 0 : t.get("layoutIterations");
                i(h, d, a, o, l, c, p)
            })
        }
    }),e("echarts/chart/sankey/sankeyVisual", [gr, "../../visual/VisualMapping"], function (t) {
        var e = t("../../visual/VisualMapping");
        return function (t) {
            t[hr]("sankey", function (t) {
                var i = t[I](), n = i.nodes;
                n.sort(function (t, e) {
                    return t[H]().value - e[H]().value
                });
                var r = n[0][H]().value, a = n[n[zn] - 1][H]().value;
                n.forEach(function (i) {
                    var n = new e({
                        type: "color",
                        mappingMethod: "linear",
                        dataExtent: [r, a],
                        visual: t.get("color")
                    }), o = n.mapValueToVisual(i[H]().value);
                    i[cr]("color", o);
                    var s = i[Jn](), l = s.get(bi);
                    null != l && i[cr]("color", l)
                })
            })
        }
    }),e("zrender/graphic/Gradient", [gr], function () {
        var t = function (t) {
            this.colorStops = t || []
        };
        return t[ir] = {
            constructor: t, addColorStop: function (t, e) {
                this.colorStops.push({offset: t, color: e})
            }
        }, t
    }),e("echarts/coord/geo/GeoModel", [gr, Ei, c, re, vr, "../../component/helper/selectableMixin", "./geoCreator"], function (t) {
        var e = t(Ei), i = t(c), n = t(re), r = t(vr), a = t("../../component/helper/selectableMixin"), o = t("./geoCreator"), s = i[On]({
            type: "geo",
            coordinateSystem: null,
            init: function (t) {
                i[ir].init.apply(this, arguments), e[ki](t.label, [Ui, "show", nn, "distance", M])
            },
            optionUpdated: function () {
                var t = this[Pi], e = this;
                t.regions = o.getFilledRegions(t.regions, t.map), this._optionModelMap = r.reduce(t.regions || [], function (t, i) {
                    return i.name && (t[i.name] = new n(i, e)), t
                }, {}), this.updateSelectedMap(t.regions)
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                show: !0,
                left: "center",
                top: "center",
                map: "",
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {
                    normal: {show: !1, textStyle: {color: "#000"}},
                    emphasis: {show: !0, textStyle: {color: "rgb(100,0,0)"}}
                },
                itemStyle: {
                    normal: {borderWidth: .5, borderColor: "#444", color: "#eee"},
                    emphasis: {color: "rgba(255,215,0,0.8)"}
                },
                regions: []
            },
            getRegionModel: function (t) {
                return this._optionModelMap[t]
            },
            getFormattedLabel: function (t, e) {
                var i = this.get("label." + e + ".formatter"), n = {name: t};
                return typeof i === fn ? (n.status = e, i(n)) : typeof i === er ? i[mn]("{a}", n.seriesName) : void 0
            },
            setZoom: function (t) {
                this[Pi].zoom = t
            },
            setCenter: function (t) {
                this[Pi][ji] = t
            }
        });
        return r.mixin(s, a), s
    }),e("echarts/component/geo/GeoView", [gr, "../helper/MapDraw", Ri], function (t) {
        var e = t("../helper/MapDraw");
        return t(Ri)[cn]({
            type: "geo", init: function (t, i) {
                var n = new e(i, !0);
                this._mapDraw = n, this.group.add(n.group)
            }, render: function (t, e, i, n) {
                if (!n || "geoToggleSelect" !== n.type || n.from !== this.uid) {
                    var r = this._mapDraw;
                    t.get("show") ? r.draw(t, e, i, this, n) : this._mapDraw.group[rn]()
                }
            }
        })
    }),e("echarts/component/axis", [gr, "../coord/cartesian/AxisModel", "./axis/AxisView"], function (t) {
        t("../coord/cartesian/AxisModel"), t("./axis/AxisView")
    }),e("echarts/component/legend/LegendModel", [gr, vr, re, Ri], function (t) {
        var e = t(vr), i = t(re), n = t(Ri)[un]({
            type: "legend",
            dependencies: [Dn],
            layoutMode: {type: "box", ignoreSize: !0},
            init: function (t, e, i) {
                this[P](t, i), t[Qe] = t[Qe] || {}, this._updateData(i);
                var n = this._data, r = this[Pi][Qe];
                if (n[0] && "single" === this.get("selectedMode")) {
                    var a = !1;
                    for (var o in r)r[o] && (this.select(o), a = !0);
                    !a && this.select(n[0].get("name"))
                }
            },
            mergeOption: function (t) {
                n.superCall(this, zi, t), this._updateData(this[j])
            },
            _updateData: function (t) {
                var n = e.map(this.get("data") || [], function (t) {
                    return typeof t === er && (t = {name: t}), new i(t, this, this[j])
                }, this);
                this._data = n;
                var r = e.map(t.getSeries(), function (t) {
                    return t.name
                });
                t[In](function (t) {
                    if (t.legendDataProvider) {
                        var e = t.legendDataProvider();
                        r = r[Gi](e[K](e[xi]))
                    }
                }), this._availableNames = r
            },
            getData: function () {
                return this._data
            },
            select: function (t) {
                var i = this[Pi][Qe], n = this.get("selectedMode");
                if ("single" === n) {
                    var r = this._data;
                    e.each(r, function (t) {
                        i[t.get("name")] = !1
                    })
                }
                i[t] = !0
            },
            unSelect: function (t) {
                "single" !== this.get("selectedMode") && (this[Pi][Qe][t] = !1)
            },
            toggleSelected: function (t) {
                var e = this[Pi][Qe];
                t in e || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
            },
            isSelected: function (t) {
                var i = this[Pi][Qe];
                return !(t in i && !i[t]) && e[vn](this._availableNames, t) >= 0
            },
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                orient: "horizontal",
                left: "center",
                top: "top",
                align: "auto",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                itemWidth: 25,
                itemHeight: 14,
                textStyle: {color: "#333"},
                selectedMode: !0
            }
        });
        return n
    }),e("echarts/component/toolbox/ToolboxView", [gr, "./featureManager", vr, vi, re, "../../data/DataDiffer", "../helper/listComponent", "zrender/contain/text", Ri], function (t) {
        function e(t) {
            return 0 === t[vn]("my")
        }

        var i = t("./featureManager"), n = t(vr), r = t(vi), a = t(re), o = t("../../data/DataDiffer"), s = t("../helper/listComponent"), l = t("zrender/contain/text");
        return t(Ri)[cn]({
            type: "toolbox", render: function (t, c, u) {
                function h(n, r) {
                    var o, s = m[n], l = m[r], h = v[s], f = new a(h, t, t[j]);
                    if (s && !l) {
                        if (e(s))o = {model: f, onclick: f[Pi].onclick, featureName: s}; else {
                            var p = i.get(s);
                            if (!p)return;
                            o = new p(f)
                        }
                        g[s] = o
                    } else {
                        if (o = g[l], !o)return;
                        o.model = f
                    }
                    return !s && l ? void(o[kn] && o[kn](c, u)) : !f.get("show") || o.unusable ? void(o[En] && o[En](c, u)) : (d(f, o, s), f.setIconStatus = function (t, e) {
                        var i = this[Pi], n = this.iconPaths;
                        i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t][Pn](e)
                    }, void(o[Tn] && o[Tn](f, c, u)))
                }

                function d(e, i, a) {
                    var o = e[Jn]("iconStyle"), s = i.getIcons ? i.getIcons() : e.get("icon"), l = e.get("title") || {};
                    if (typeof s === er) {
                        var h = s, d = l;
                        s = {}, l = {}, s[a] = h, l[a] = d
                    }
                    var v = e.iconPaths = {};
                    n.each(s, function (a, s) {
                        var h = o[Jn](Li)[Wi](), d = o[Jn](Ti)[Wi](), g = {
                            x: -p / 2,
                            y: -p / 2,
                            width: p,
                            height: p
                        }, m = 0 === a[vn]("image://") ? (g.image = a.slice(8), new r.Image({style: g})) : r.makePath(a[mn]("path://", ""), {
                            style: h,
                            hoverStyle: d,
                            rectHover: !0
                        }, g, ji);
                        r[Ke](m), t.get("showTitle") && (m.__title = l[s], m.on(Cn, function () {
                            m[qi]({
                                text: l[s],
                                textPosition: d.textPosition || Hn,
                                textFill: d.fill || d[Ne] || "#000",
                                textAlign: d[en] || ji
                            })
                        }).on(An, function () {
                            m[qi]({textFill: null})
                        })), m[Pn](e.get("iconStatus." + s) || Li), f.add(m), m.on("click", n.bind(i.onclick, i, c, u, s)), v[s] = m
                    })
                }

                var f = this.group;
                if (f[rn](), t.get("show")) {
                    var p = +t.get("itemSize"), v = t.get("feature") || {}, g = this._features || (this._features = {}), m = [];
                    n.each(v, function (t, e) {
                        m.push(e)
                    }), new o(this._featureNames || [], m).add(h)[Gn](h)[En](n.curry(h, null))[qe](), this._featureNames = m, s[Ce](f, t, u), s.addBackground(f, t), f[We](function (t) {
                        var e = t.__title, i = t[$e];
                        if (i && e) {
                            var n = l[Qi](e, i.font), r = t[Ui][0] + f[Ui][0], a = t[Ui][1] + f[Ui][1] + p, o = !1;
                            a + n[Fn] > u[Yn]() && (i.textPosition = "top", o = !0);
                            var s = o ? -5 - n[Fn] : p + 8;
                            r + n.width / 2 > u[Kn]() ? (i.textPosition = ["100%", s], i[en] = "right") : r - n.width / 2 < 0 && (i.textPosition = [0, s], i[en] = "left")
                        }
                    })
                }
            }, remove: function (t, e) {
                n.each(this._features, function (i) {
                    i[En] && i[En](t, e)
                }), this.group[rn]()
            }, dispose: function (t, e) {
                n.each(this._features, function (i) {
                    i[kn] && i[kn](t, e)
                })
            }
        })
    }),e("echarts/component/toolbox/feature/MagicType", [gr, vr, "../../../echarts", "../featureManager"], function (t) {
        function e(t) {
            this.model = t
        }

        var i = t(vr);
        e.defaultOption = {
            show: !0,
            type: [],
            icon: {
                line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
                bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
                stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z",
                tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z"
            },
            title: {line: "", bar: "", stack: "", tiled: ""},
            option: {},
            seriesIndex: {}
        };
        var n = e[ir];
        n.getIcons = function () {
            var t = this.model, e = t.get("icon"), n = {};
            return i.each(t.get("type"), function (t) {
                e[t] && (n[t] = e[t])
            }), n
        };
        var r = {
            line: function (t, e, n, r) {
                return "bar" === t ? i.merge({
                    id: e,
                    type: "line",
                    data: n.get("data"),
                    stack: n.get("stack"),
                    markPoint: n.get("markPoint"),
                    markLine: n.get("markLine")
                }, r.get("option.line") || {}, !0) : void 0
            }, bar: function (t, e, n, r) {
                return "line" === t ? i.merge({
                    id: e,
                    type: "bar",
                    data: n.get("data"),
                    stack: n.get("stack"),
                    markPoint: n.get("markPoint"),
                    markLine: n.get("markLine")
                }, r.get("option.bar") || {}, !0) : void 0
            }, stack: function (t, e, n, r) {
                return "line" === t || "bar" === t ? i.merge({
                    id: e,
                    stack: "__ec_magicType_stack__"
                }, r.get("option.stack") || {}, !0) : void 0
            }, tiled: function (t, e, n, r) {
                return "line" === t || "bar" === t ? i.merge({
                    id: e,
                    stack: ""
                }, r.get("option.tiled") || {}, !0) : void 0
            }
        }, a = [["line", "bar"], ["stack", "tiled"]];
        n.onclick = function (t, e, n) {
            var o = this.model, s = o.get("seriesIndex." + n);
            if (r[n]) {
                var l = {series: []}, c = function (t) {
                    var e = t.subType, a = t.id, s = r[n](e, a, t, o);
                    s && (i[Vn](s, t[Pi]), l[Dn].push(s));
                    var c = t[Ni];
                    if (c && c.type === ce && ("line" === n || "bar" === n)) {
                        var u = c.getAxesByScale(se)[0];
                        if (u) {
                            var h = u.dim, d = t.get(h + "AxisIndex"), f = h + "Axis";
                            l[f] = l[f] || [];
                            for (var p = 0; d >= p; p++)l[f][d] = l[f][d] || {};
                            l[f][d][ue] = "bar" === n ? !0 : !1
                        }
                    }
                };
                i.each(a, function (t) {
                    i[vn](t, n) >= 0 && i.each(t, function (t) {
                        o.setIconStatus(t, Li)
                    })
                }), o.setIconStatus(n, Ti), t[qn]({
                    mainType: "series",
                    query: null == s ? null : {seriesIndex: s}
                }, c), e[Rn]({type: "changeMagicType", currentType: n, newOption: l})
            }
        };
        var o = t("../../../echarts");
        return o[pn]({type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate"}, function (t, e) {
            e[zi](t.newOption)
        }), t("../featureManager")[dn]("magicType", e), e
    }),e("echarts/component/legend/LegendView", [gr, vr, E, vi, "../helper/listComponent", Ri], function (t) {
        function e(t, e) {
            e[Rn]({type: "legendToggleSelect", name: t})
        }

        function i(t, e, i) {
            t.get("legendHoverLink") && i[Rn]({type: "highlight", seriesName: t.name, name: e})
        }

        function n(t, e, i) {
            t.get("legendHoverLink") && i[Rn]({type: "downplay", seriesName: t.name, name: e})
        }

        var r = t(vr), a = t(E), o = t(vi), s = t("../helper/listComponent"), l = r.curry, c = "#ccc";
        return t(Ri)[cn]({
            type: "legend", init: function () {
                this._symbolTypeStore = {}
            }, render: function (t, a, c) {
                var h = this.group;
                if (h[rn](), t.get("show")) {
                    var d = t.get("selectedMode"), p = t.get("align");
                    "auto" === p && (p = "right" === t.get("left") && t.get(u) === f ? "right" : "left");
                    var v = {};
                    r.each(t[ur](), function (r) {
                        var s = r.get("name");
                        if ("" === s || "\n" === s)return void h.add(new o.Group({newline: !0}));
                        var u = a.getSeriesByName(s)[0];
                        if (!v[s])if (u) {
                            var f = u[ur](), g = f[G]("color");
                            typeof g === fn && (g = g(u[wn](0)));
                            var m = f[G]("legendSymbol") || "roundRect", y = f[G](_e), _ = this._createItem(s, r, t, m, y, p, g, d);
                            _.on("click", l(e, s, c)).on(Cn, l(i, u, "", c)).on(An, l(n, u, "", c)), v[s] = !0
                        } else a.eachRawSeries(function (a) {
                            if (!v[s] && a.legendDataProvider) {
                                var o = a.legendDataProvider(), u = o[x](s);
                                if (0 > u)return;
                                var h = o[Mi](u, "color"), f = "roundRect", g = this._createItem(s, r, t, f, null, p, h, d);
                                g.on("click", l(e, s, c)).on(Cn, l(i, a, s, c)).on(An, l(n, a, s, c)), v[s] = !0
                            }
                        }, this)
                    }, this), s[Ce](h, t, c), s.addBackground(h, t)
                }
            }, _createItem: function (t, e, i, n, r, s, l, u) {
                var h = i.get("itemWidth"), d = i.get("itemHeight"), f = i.isSelected(t), p = new o.Group, v = e[Jn](nn), g = e.get("icon");
                if (n = g || n, p.add(a[O](n, 0, 0, h, d, f ? l : c)), !g && r && (r !== n || "none" == r)) {
                    var m = .8 * d;
                    "none" === r && (r = dr), p.add(a[O](r, (h - m) / 2, (d - m) / 2, m, m, f ? l : c))
                }
                var y = "left" === s ? h + 5 : -5, x = s, _ = i.get(M);
                typeof _ === er && _ ? t = _[mn]("{name}", t) : typeof _ === fn && (t = _(t));
                var w = new o.Text({
                    style: {
                        text: t,
                        x: y,
                        y: d / 2,
                        fill: f ? v[$i]() : c,
                        textFont: v[tn](),
                        textAlign: x,
                        textVerticalAlign: "middle"
                    }
                });
                return p.add(w), p.add(new o.Rect({shape: p[Qi](), invisible: !0})), p[We](function (t) {
                    t.silent = !u
                }), this.group.add(p), o[Ke](p), p
            }
        })
    }),e("echarts/component/legend/legendFilter", [], function () {
        return function (t) {
            var e = t[_i]({mainType: "legend"});
            e && e[zn] && t.filterSeries(function (t) {
                for (var i = 0; i < e[zn]; i++)if (!e[i].isSelected(t.name))return !1;
                return !0
            })
        }
    }),e("echarts/scale/Interval", [gr, yi, "../util/format", "./Scale"], function (t) {
        var e = t(yi), i = t("../util/format"), n = t("./Scale"), r = Math.floor, a = Math.ceil, o = n[On]({
            type: "interval",
            _interval: 0,
            setExtent: function (t, e) {
                var i = this._extent;
                isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e))
            },
            unionExtent: function (t) {
                var e = this._extent;
                t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), o[ir][de].call(this, e[0], e[1])
            },
            getInterval: function () {
                return this._interval || this.niceTicks(), this._interval
            },
            setInterval: function (t) {
                this._interval = t, this._niceExtent = this._extent.slice()
            },
            getTicks: function () {
                this._interval || this.niceTicks();
                var t = this._interval, i = this._extent, n = [], r = 1e4;
                if (t) {
                    var a = this._niceExtent;
                    i[0] < a[0] && n.push(i[0]);
                    for (var o = a[0]; o <= a[1];)if (n.push(o), o = e.round(o + t), n[zn] > r)return [];
                    i[1] > a[1] && n.push(i[1])
                }
                return n
            },
            getTicksLabels: function () {
                for (var t = [], e = this[oe](), i = 0; i < e[zn]; i++)t.push(this[ae](e[i]));
                return t
            },
            getLabel: function (t) {
                return i[ke](t)
            },
            niceTicks: function (t) {
                t = t || 5;
                var i = this._extent, n = i[1] - i[0];
                if (isFinite(n)) {
                    0 > n && (n = -n, i[k]());
                    var o = e.nice(n / t, !0), s = [e.round(a(i[0] / o) * o), e.round(r(i[1] / o) * o)];
                    this._interval = o, this._niceExtent = s
                }
            },
            niceExtent: function (t, i, n) {
                var o = this._extent;
                if (o[0] === o[1])if (0 !== o[0]) {
                    var s = o[0] / 2;
                    o[0] -= s, o[1] += s
                } else o[1] = 1;
                var l = o[1] - o[0];
                isFinite(l) || (o[0] = 0, o[1] = 1), this.niceTicks(t);
                var c = this._interval;
                i || (o[0] = e.round(r(o[0] / c) * c)), n || (o[1] = e.round(a(o[1] / c) * c))
            }
        });
        return o[Zn] = function () {
            return new o
        }, o
    }),e("echarts/chart/helper/createListFromArray", [gr, Bi, Oi, vr, Ei, ge], function (t) {
        function e(t) {
            for (var e = 0; e < t[zn] && null == t[e];)e++;
            return t[e]
        }

        function i(t) {
            var i = e(t);
            return null != i && !c[gn](d(i))
        }

        function n(t, e, n) {
            if (t = t || [], !c[gn](t))throw new Error("Invalid data.");
            var r = e.get(Ni), a = p[r], u = h.get(r), v = a && a(t, e, n), g = v && v[Te];
            g || (g = u && u[Te] || ["x", "y"], g = l(g, t, g[Gi](["value"])));
            var m, y = v && v.categoryAxisModel, x = g[0].type === se ? 0 : g[1].type === se ? 1 : -1, _ = new s(g, e), w = o(v, t), b = y && i(t) ? function (t, e, i, n) {
                return n === x ? i : f(d(t), g[n])
            } : function (t, e, i, n) {
                var r = d(t), a = f(r && r[n], g[n]);
                return x === n && typeof a === er && (m = m || y.getCategories(), a = c[vn](m, a), 0 > a && !isNaN(a) && (a = +a)), a
            };
            return _[Ii](t, w, b), _
        }

        function r(t) {
            return t !== be && "time" !== t
        }

        function a(t) {
            return t === be ? se : "time" === t ? "time" : "float"
        }

        function o(t, e) {
            var i = [];
            if (t && t.categoryAxisModel) {
                var n = t.categoryAxisModel.getCategories();
                if (n) {
                    var r = e[zn];
                    if (c[gn](e[0]) && e[0][zn] > 1) {
                        i = [];
                        for (var a = 0; r > a; a++)i[a] = n[e[a][t.categoryIndex || 0]]
                    } else i = n.slice(0)
                }
            }
            return i
        }

        var s = t(Bi), l = t(Oi), c = t(vr), u = t(Ei), h = t(ge), d = u.getDataItemValue, f = u.converDataValue, p = {
            cartesian2d: function (t, e, i) {
                var n = i[ve]("xAxis", e.get("xAxisIndex")), o = i[ve]("yAxis", e.get("yAxisIndex"));
                if (!n || !o)throw new Error("Axis option not found");
                var s = n.get("type"), c = o.get("type"), u = [{name: "x", type: a(s), stackable: r(s)}, {
                    name: "y",
                    type: a(c),
                    stackable: r(c)
                }], h = s === be;
                return l(u, t, ["x", "y", "z"]), {
                    dimensions: u,
                    categoryIndex: h ? 0 : 1,
                    categoryAxisModel: h ? n : c === be ? o : null
                }
            }, polar: function (t, e, i) {
                var n = e.get(Y) || 0, o = function (t) {
                    return t.get(Y) === n
                }, s = i[_i]({mainType: "angleAxis", filter: o})[0], c = i[_i]({mainType: "radiusAxis", filter: o})[0];
                if (!s || !c)throw new Error("Axis option not found");
                var u = c.get("type"), h = s.get("type"), d = [{
                    name: "radius",
                    type: a(u),
                    stackable: r(u)
                }, {name: "angle", type: a(h), stackable: r(h)}], f = h === be;
                return l(d, t, [Oe, "angle", "value"]), {
                    dimensions: d,
                    categoryIndex: f ? 1 : 0,
                    categoryAxisModel: f ? s : u === be ? c : null
                }
            }, geo: function (t) {
                return {dimensions: l([{name: "lng"}, {name: "lat"}], t, ["lng", "lat", "value"])}
            }
        };
        return n
    }),e("echarts/scale/Scale", [gr, "../util/clazz"], function (t) {
        function e() {
            this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments)
        }

        var i = t("../util/clazz"), n = e[ir];
        return n.parse = function (t) {
            return t
        }, n[mi] = function (t) {
            var e = this._extent;
            return t >= e[0] && t <= e[1]
        }, n[gi] = function (t) {
            var e = this._extent;
            return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
        }, n.scale = function (t) {
            var e = this._extent;
            return t * (e[1] - e[0]) + e[0]
        }, n.unionExtent = function (t) {
            var e = this._extent;
            t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
        }, n[we] = function () {
            return this._extent.slice()
        }, n[de] = function (t, e) {
            var i = this._extent;
            isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e)
        }, n.getTicksLabels = function () {
            for (var t = [], e = this[oe](), i = 0; i < e[zn]; i++)t.push(this[ae](e[i]));
            return t
        }, i.enableClassExtend(e), i.enableClassManagement(e, {registerWhenExtend: !0}), e
    }),e("echarts/component/toolbox/feature/Restore", [gr, "../../dataZoom/history", "../featureManager", "../../../echarts"], function (t) {
        function e(t) {
            this.model = t
        }

        var i = t("../../dataZoom/history");
        e.defaultOption = {
            show: !0,
            icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
            title: ""
        };
        var n = e[ir];
        return n.onclick = function (t, e) {
            i.clear(t), e[Rn]({type: "restore", from: this.uid})
        }, t("../featureManager")[dn]("restore", e), t("../../../echarts")[pn]({
            type: "restore",
            event: "restore",
            update: "prepareAndUpdate"
        }, function (t, e) {
            e.resetOption("recreate")
        }), e
    }),e("echarts/util/model", [gr, "./format", "./number", vr], function (t) {
        var e = t("./format"), i = t("./number"), n = t(vr), r = ["x", "y", "z", Oe, "angle"], a = {};
        return a.createNameEach = function (t, e) {
            t = t.slice();
            var i = n.map(t, a.capitalFirst);
            e = (e || []).slice();
            var r = n.map(e, a.capitalFirst);
            return function (a, o) {
                n.each(t, function (t, n) {
                    for (var s = {name: t, capital: i[n]}, l = 0; l < e[zn]; l++)s[e[l]] = t + r[l];
                    a.call(o, s)
                })
            }
        }, a.capitalFirst = function (t) {
            return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
        }, a.eachAxisDim = a.createNameEach(r, ["axisIndex", "axis", "index"]), a[b] = function (t) {
            return n[gn](t) ? t : null == t ? [] : [t]
        }, a.createLinkedNodesFinder = function (t, e, i) {
            function r(t, e) {
                return n[vn](e.nodes, t) >= 0
            }

            function a(t, r) {
                var a = !1;
                return e(function (e) {
                    n.each(i(t, e) || [], function (t) {
                        r.records[e.name][t] && (a = !0)
                    })
                }), a
            }

            function o(t, r) {
                r.nodes.push(t), e(function (e) {
                    n.each(i(t, e) || [], function (t) {
                        r.records[e.name][t] = !0
                    })
                })
            }

            return function (i) {
                function n(t) {
                    !r(t, s) && a(t, s) && (o(t, s), l = !0)
                }

                var s = {nodes: [], records: {}};
                if (e(function (t) {
                        s.records[t.name] = {}
                    }), !i)return s;
                o(i, s);
                var l;
                do l = !1, t(n); while (l);
                return s
            }
        }, a[ki] = function (t, e) {
            if (t) {
                var i = t[Ti] = t[Ti] || {}, r = t[Li] = t[Li] || {};
                n.each(e, function (t) {
                    var e = n[oi](i[t], r[t]);
                    null != e && (i[t] = e)
                })
            }
        }, a.LABEL_OPTIONS = [Ui, "show", nn, "distance", M], a.getDataItemValue = function (t) {
            return t && (null == t.value ? t : t.value)
        }, a.converDataValue = function (t, e) {
            var n = e && e.type;
            return n === se ? t : ("time" !== n || isFinite(t) || null == t || "-" === t || (t = +i.parseDate(t)), null == t || "" === t ? 0 / 0 : +t)
        }, a.dataFormatMixin = {
            getDataParams: function (t, e) {
                var i = this[ur](e), n = this[bn], r = this.name, a = this[ye](t, e), o = i[Si](t), s = i[xi](t, !0), l = i.getRawDataItem(t);
                return {
                    componentType: this[w],
                    componentSubType: this.subType,
                    seriesType: this[w] === Dn ? this.subType : null,
                    seriesIndex: n,
                    seriesName: r,
                    name: s,
                    dataIndex: o,
                    data: l,
                    dataType: e,
                    value: a,
                    color: i[Mi](t, "color"),
                    $vars: ["seriesName", "name", "value"]
                }
            }, getFormattedLabel: function (t, i, r, a) {
                i = i || Li;
                var o = this[ur](r), s = o[Ai](t), l = this[wn](t, r);
                null != a && n[gn](l.value) && (l.value = l.value[a]);
                var c = s.get(["label", i, M]);
                return typeof c === fn ? (l.status = i, c(l)) : typeof c === er ? e.formatTpl(c, l) : void 0
            }, getRawValue: function (t, e) {
                var i = this[ur](e), r = i.getRawDataItem(t);
                return null != r ? n[Bn](r) && !n[gn](r) ? r.value : r : void 0
            }, formatTooltip: n.noop
        }, a.mappingToExists = function (t, e) {
            e = (e || []).slice();
            var i = n.map(t || [], function (t) {
                return {exist: t}
            });
            return n.each(e, function (t, r) {
                if (n[Bn](t))for (var o = 0; o < i[zn]; o++) {
                    var s = i[o].exist;
                    if (!i[o][Pi] && (null != t.id && s.id === t.id + "" || null != t.name && !a.isIdInner(t) && !a.isIdInner(s) && s.name === t.name + "")) {
                        i[o][Pi] = t, e[r] = null;
                        break
                    }
                }
            }), n.each(e, function (t) {
                if (n[Bn](t)) {
                    for (var e = 0; e < i[zn]; e++) {
                        var r = i[e].exist;
                        if (!i[e][Pi] && !a.isIdInner(r) && null == t.id) {
                            i[e][Pi] = t;
                            break
                        }
                    }
                    e >= i[zn] && i.push({option: t})
                }
            }), i
        }, a.isIdInner = function (t) {
            return n[Bn](t) && t.id && 0 === (t.id + "")[vn]("\x00_ec_\x00")
        }, a
    }),e("echarts/model/Model", [gr, vr, "../util/clazz", "./mixin/lineStyle", "./mixin/areaStyle", "./mixin/textStyle", "./mixin/itemStyle"], function (t) {
        function e(t, e, i, n) {
            this.parentModel = e, this[j] = i, this[Pi] = t, this.init && (arguments[zn] <= 4 ? this.init(t, e, i, n) : this.init.apply(this, arguments))
        }

        var i = t(vr), n = t("../util/clazz");
        e[ir] = {
            constructor: e, init: null, mergeOption: function (t) {
                i.merge(this[Pi], t, !0)
            }, get: function (t, e) {
                if (!t)return this[Pi];
                typeof t === er && (t = t.split("."));
                for (var i = this[Pi], n = this.parentModel, r = 0; r < t[zn] && (!t[r] || (i = i && "object" == typeof i ? i[t[r]] : null, null != i)); r++);
                return null == i && n && !e && (i = n.get(t)), i
            }, getShallow: function (t, e) {
                var i = this[Pi], n = i && i[t], r = this.parentModel;
                return null == n && r && !e && (n = r[N](t)), n
            }, getModel: function (t, i) {
                var n = this.get(t, !0), r = this.parentModel, a = new e(n, i || r && r[Jn](t), this[j]);
                return a
            }, isEmpty: function () {
                return null == this[Pi]
            }, restoreData: function () {
            }, clone: function () {
                var t = this.constructor;
                return new t(i.clone(this[Pi]))
            }, setReadOnly: function (t) {
                n.setReadOnly(this, t)
            }
        }, n.enableClassExtend(e);
        var r = i.mixin;
        return r(e, t("./mixin/lineStyle")), r(e, t("./mixin/areaStyle")), r(e, t("./mixin/textStyle")), r(e, t("./mixin/itemStyle")), e
    }),e("echarts/data/List", [gr, "../model/Model", "./DataDiffer", vr, "../util/model"], function (t) {
        function e(t) {
            return u[gn](t) || (t = [t]), t
        }

        function i(t, e) {
            var i = t[Te], n = new g(u.map(i, t.getDimensionInfo, t), t[ri]);
            p(n, t);
            for (var r = n._storage = {}, a = t._storage, o = 0; o < i[zn]; o++) {
                var s = i[o], l = a[s];
                r[s] = u[vn](e, s) >= 0 ? new l.constructor(a[s][zn]) : a[s]
            }
            return n
        }

        var n = v, r = typeof window === v ? global : window, a = typeof r.Float64Array === n ? Array : r.Float64Array, o = typeof r.Int32Array === n ? Array : r.Int32Array, s = {
            "float": a,
            "int": o,
            ordinal: Array,
            number: Array,
            time: Array
        }, l = t("../model/Model"), c = t("./DataDiffer"), u = t(vr), h = t("../util/model"), d = u[Bn], f = ["stackedOn", "_nameList", "_idList", "_rawData"], p = function (t, e) {
            u.each(f[Gi](e.__wrappedMethods || []), function (i) {
                e.hasOwnProperty(i) && (t[i] = e[i])
            }), t.__wrappedMethods = e.__wrappedMethods
        }, g = function (t, e) {
            t = t || ["x", "y"];
            for (var i = {}, n = [], r = 0; r < t[zn]; r++) {
                var a, o = {};
                typeof t[r] === er ? (a = t[r], o = {
                    name: a,
                    stackable: !1,
                    type: "number"
                }) : (o = t[r], a = o.name, o.type = o.type || sn), n.push(a), i[a] = o
            }
            this[Te] = n, this._dimensionInfos = i, this[ri] = e, this[_n], this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent
        }, m = g[ir];
        m.type = "list", m.getDimension = function (t) {
            return isNaN(t) || (t = this[Te][t] || t), t
        }, m.getDimensionInfo = function (t) {
            return u.clone(this._dimensionInfos[this.getDimension(t)])
        }, m[Ii] = function (t, e, i) {
            if (t = t || [], !u[gn](t))throw new Error("Invalid data.");
            this._rawData = t;
            var n = this._storage = {}, r = this.indices = [], a = this[Te], o = t[zn], l = this._dimensionInfos, c = [], d = {};
            e = e || [];
            for (var f = 0; f < a[zn]; f++) {
                var p = l[a[f]], v = s[p.type];
                n[a[f]] = new v(o)
            }
            i = i || function (t, e, i, n) {
                    var r = h.getDataItemValue(t);
                    return h.converDataValue(u[gn](r) ? r[n] : r, l[e])
                };
            for (var g = 0; g < t[zn]; g++) {
                for (var m = t[g], y = 0; y < a[zn]; y++) {
                    var x = a[y], _ = n[x];
                    _[g] = i(m, x, g, y)
                }
                r.push(g)
            }
            for (var f = 0; f < t[zn]; f++) {
                var w = "";
                e[f] || (e[f] = t[f].name, w = t[f].id);
                var b = e[f] || "";
                !w && b && (d[b] = d[b] || 0, w = b, d[b] > 0 && (w += "__ec__" + d[b]), d[b]++), w && (c[f] = w)
            }
            this._nameList = e, this._idList = c
        }, m.count = function () {
            return this.indices[zn]
        }, m.get = function (t, e, i) {
            var n = this._storage, r = this.indices[e];
            if (null == r)return 0 / 0;
            var a = n[t] && n[t][r];
            if (i) {
                var o = this._dimensionInfos[t];
                if (o && o.stackable)for (var s = this.stackedOn; s;) {
                    var l = s.get(t, e);
                    (a >= 0 && l > 0 || 0 >= a && 0 > l) && (a += l), s = s.stackedOn
                }
            }
            return a
        }, m.getValues = function (t, e, i) {
            var n = [];
            u[gn](t) || (i = e, e = t, t = this[Te]);
            for (var r = 0, a = t[zn]; a > r; r++)n.push(this.get(t[r], e, i));
            return n
        }, m.hasValue = function (t) {
            for (var e = this[Te], i = this._dimensionInfos, n = 0, r = e[zn]; r > n; n++)if (i[e[n]].type !== se && isNaN(this.get(e[n], t)))return !1;
            return !0
        }, m[Re] = function (t, e) {
            var i = this._storage[t], n = this.getDimensionInfo(t);
            e = n && n.stackable && e;
            var r, a = (this._extent || (this._extent = {}))[t + !!e];
            if (a)return a;
            if (i) {
                for (var o = 1 / 0, s = -1 / 0, l = 0, c = this.count(); c > l; l++)r = this.get(t, l, e), o > r && (o = r), r > s && (s = r);
                return this._extent[t + e] = [o, s]
            }
            return [1 / 0, -1 / 0]
        }, m.getSum = function (t, e) {
            var i = this._storage[t], n = 0;
            if (i)for (var r = 0, a = this.count(); a > r; r++) {
                var o = this.get(t, r, e);
                isNaN(o) || (n += o)
            }
            return n
        }, m[vn] = function (t, e) {
            var i = this._storage, n = i[t], r = this.indices;
            if (n)for (var a = 0, o = r[zn]; o > a; a++) {
                var s = r[a];
                if (n[s] === e)return a
            }
            return -1
        }, m[x] = function (t) {
            for (var e = this.indices, i = this._nameList, n = 0, r = e[zn]; r > n; n++) {
                var a = e[n];
                if (i[a] === t)return n
            }
            return -1
        }, m.indexOfNearest = function (t, e, i) {
            var n = this._storage, r = n[t];
            if (r) {
                for (var a = Number.MAX_VALUE, o = -1, s = 0, l = this.count(); l > s; s++) {
                    var c = e - this.get(t, s, i), u = Math.abs(c);
                    (a > u || u === a && c > 0) && (a = u, o = s)
                }
                return o
            }
            return -1
        }, m[Si] = function (t) {
            var e = this.indices[t];
            return null == e ? -1 : e
        }, m.getRawDataItem = function (t) {
            return this._rawData[this[Si](t)]
        }, m[xi] = function (t) {
            return this._nameList[this.indices[t]] || ""
        }, m.getId = function (t) {
            return this._idList[this.indices[t]] || this[Si](t) + ""
        }, m.each = function (t, i, n, r) {
            typeof t === fn && (r = n, n = i, i = t, t = []), t = u.map(e(t), this.getDimension, this);
            var a = [], o = t[zn], s = this.indices;
            r = r || this;
            for (var l = 0; l < s[zn]; l++)if (0 === o)i.call(r, l); else if (1 === o)i.call(r, this.get(t[0], l, n), l); else {
                for (var c = 0; o > c; c++)a[c] = this.get(t[c], l, n);
                a[c] = l, i.apply(r, a)
            }
        }, m.filterSelf = function (t, i, n, r) {
            typeof t === fn && (r = n, n = i, i = t, t = []), t = u.map(e(t), this.getDimension, this);
            var a = [], o = [], s = t[zn], l = this.indices;
            r = r || this;
            for (var c = 0; c < l[zn]; c++) {
                var h;
                if (1 === s)h = i.call(r, this.get(t[0], c, n), c); else {
                    for (var d = 0; s > d; d++)o[d] = this.get(t[d], c, n);
                    o[d] = c, h = i.apply(r, o)
                }
                h && a.push(l[c])
            }
            return this.indices = a, this._extent = {}, this
        }, m[K] = function (t, e, i, n) {
            typeof t === fn && (n = i, i = e, e = t, t = []);
            var r = [];
            return this.each(t, function () {
                r.push(e && e.apply(this, arguments))
            }, i, n), r
        }, m.map = function (t, n, r, a) {
            t = u.map(e(t), this.getDimension, this);
            var o = i(this, t), s = o.indices = this.indices, l = o._storage, c = [];
            return this.each(t, function () {
                var e = arguments[arguments[zn] - 1], i = n && n.apply(this, arguments);
                if (null != i) {
                    typeof i === sn && (c[0] = i, i = c);
                    for (var r = 0; r < i[zn]; r++) {
                        var a = t[r], o = l[a], u = s[e];
                        o && (o[u] = i[r])
                    }
                }
            }, r, a), o
        }, m.downSample = function (t, e, n, r) {
            for (var a = i(this, [t]), o = this._storage, s = a._storage, l = this.indices, c = a.indices = [], u = [], h = [], d = Math.floor(1 / e), f = s[t], p = this.count(), v = 0; v < o[t][zn]; v++)s[t][v] = o[t][v];
            for (var v = 0; p > v; v += d) {
                d > p - v && (d = p - v, u[zn] = d);
                for (var g = 0; d > g; g++) {
                    var m = l[v + g];
                    u[g] = f[m], h[g] = m
                }
                var y = n(u), m = h[r(u, y) || 0];
                f[m] = y, c.push(m)
            }
            return a
        }, m[Ai] = function (t) {
            var e = this[ri];
            return t = this.indices[t], new l(this._rawData[t], e, e && e[j])
        }, m.diff = function (t) {
            var e = this._idList, i = t && t._idList;
            return new c(t ? t.indices : [], this.indices, function (t) {
                return i[t] || t + ""
            }, function (t) {
                return e[t] || t + ""
            })
        }, m[G] = function (t) {
            var e = this._visual;
            return e && e[t]
        }, m[cr] = function (t, e) {
            if (d(t))for (var i in t)t.hasOwnProperty(i) && this[cr](i, t[i]); else this._visual = this._visual || {}, this._visual[t] = e
        }, m[$] = function (t, e) {
            if (d(t))for (var i in t)t.hasOwnProperty(i) && this[$](i, t[i]); else this._layout[t] = e
        }, m[H] = function (t) {
            return this._layout[t]
        }, m[fi] = function (t) {
            return this._itemLayouts[t]
        }, m[Ve] = function (t, e, i) {
            this._itemLayouts[t] = i ? u[On](this._itemLayouts[t] || {}, e) : e
        }, m.clearItemLayouts = function () {
            this._itemLayouts[zn] = 0
        }, m[Mi] = function (t, e, i) {
            var n = this._itemVisuals[t], r = n && n[e];
            return null != r || i ? r : this[G](e)
        }, m[wi] = function (t, e, i) {
            var n = this._itemVisuals[t] || {};
            if (this._itemVisuals[t] = n, d(e))for (var r in e)e.hasOwnProperty(r) && (n[r] = e[r]); else n[e] = i
        };
        var y = function (t) {
            t[bn] = this[bn], t[Mn] = this[Mn], t[_n] = this[_n]
        };
        return m[He] = function (t, e) {
            var i = this[ri];
            e && (e[Mn] = t, e[_n] = this[_n], e[bn] = i && i[bn], "group" === e.type && e[yn](y, e)), this._graphicEls[t] = e
        }, m[pi] = function (t) {
            return this._graphicEls[t]
        }, m[ne] = function (t, e) {
            u.each(this._graphicEls, function (i, n) {
                i && t && t.call(e, i, n)
            })
        }, m.cloneShallow = function () {
            var t = u.map(this[Te], this.getDimensionInfo, this), e = new g(t, this[ri]);
            return e._storage = this._storage, p(e, this), e.indices = this.indices.slice(), e
        }, m.wrapMethod = function (t, e) {
            var i = this[t];
            typeof i === fn && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () {
                var t = i.apply(this, arguments);
                return e.apply(this, [t][Gi](u.slice(arguments)))
            })
        }, m.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], m.CHANGABLE_METHODS = ["filterSelf"], g
    }),e("zrender/graphic/Path", [gr, "./Displayable", p, "../core/PathProxy", "../contain/path", "./Gradient"], function (t) {
        function e(t) {
            var e = t.fill;
            return null != e && "none" !== e
        }

        function i(t) {
            var e = t[Ne];
            return null != e && "none" !== e && t[m] > 0
        }

        function n(t) {
            r.call(this, t), this.path = new c
        }

        var r = t("./Displayable"), l = t(p), c = t("../core/PathProxy"), u = t("../contain/path"), h = (t("./Gradient"), Math.abs);
        return n[ir] = {
            constructor: n, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, brush: function (t) {
                t.save();
                var n = this.style, r = this.path, s = i(n), l = e(n), c = l && !!n.fill.colorStops, u = s && !!n[Ne].colorStops;
                if (n.bind(t, this), this.setTransform(t), this.__dirtyPath) {
                    var h = this[Qi]();
                    c && (this._fillGradient = n.getGradient(t, n.fill, h)), u && (this._strokeGradient = n.getGradient(t, n[Ne], h))
                }
                c && (t.fillStyle = this._fillGradient), u && (t.strokeStyle = this._strokeGradient);
                var d = n.lineDash, f = n.lineDashOffset, p = !!t.setLineDash, v = this.getGlobalScale();
                r.setScale(v[0], v[1]), this.__dirtyPath || d && !p && s ? (r = this.path[o](t), d && !p && (r.setLineDash(d), r.setLineDashOffset(f)), this[a](r, this.shape), this.__dirtyPath = !1) : (t[o](), this.path.rebuildPath(t)), l && r.fill(t), d && p && (t.setLineDash(d), t.lineDashOffset = f), s && r[Ne](t), null != n.text && this.drawRectText(t, this[Qi]()), t.restore()
            }, buildPath: function () {
            }, getBoundingRect: function () {
                var t = this._rect, n = this.style, r = !t;
                if (r) {
                    var l = this.path;
                    this.__dirtyPath && (l[o](), this[a](l, this.shape)), t = l[Qi]()
                }
                if (this._rect = t, i(n)) {
                    var c = this._rectWithStroke || (this._rectWithStroke = t.clone());
                    if (this[s] || r) {
                        c.copy(t);
                        var u = n[m], h = n.strokeNoScale ? this.getLineScale() : 1;
                        e(n) || (u = Math.max(u, this.strokeContainThreshold)), h > 1e-10 && (c.width += u / h, c[Fn] += u / h, c.x -= u / h / 2, c.y -= u / h / 2)
                    }
                    return c
                }
                return t
            }, contain: function (t, n) {
                var r = this.transformCoordToLocal(t, n), a = this[Qi](), o = this.style;
                if (t = r[0], n = r[1], a[mi](t, n)) {
                    var s = this.path.data;
                    if (i(o)) {
                        var l = o[m], c = o.strokeNoScale ? this.getLineScale() : 1;
                        if (c > 1e-10 && (e(o) || (l = Math.max(l, this.strokeContainThreshold)), u.containStroke(s, l / c, t, n)))return !0
                    }
                    if (e(o))return u[mi](s, t, n)
                }
                return !1
            }, dirty: function (t) {
                0 === arguments[zn] && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this[s] = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
            }, animateShape: function (t) {
                return this[hi]("shape", t)
            }, attrKV: function (t, e) {
                "shape" === t ? this[ii](e) : r[ir].attrKV.call(this, t, e)
            }, setShape: function (t, e) {
                var i = this.shape;
                if (i) {
                    if (l[Bn](t))for (var n in t)i[n] = t[n]; else i[t] = e;
                    this.dirty(!0)
                }
                return this
            }, getLineScale: function () {
                var t = this[rr];
                return t && h(t[0] - 1) > 1e-10 && h(t[3] - 1) > 1e-10 ? Math.sqrt(h(t[0] * t[3] - t[2] * t[1])) : 1
            }
        }, n[On] = function (t) {
            var e = function (e) {
                n.call(this, e), t.style && this.style.extendFrom(t.style, !1);
                var i = t.shape;
                if (i) {
                    this.shape = this.shape || {};
                    var r = this.shape;
                    for (var a in i)!r.hasOwnProperty(a) && i.hasOwnProperty(a) && (r[a] = i[a])
                }
                t.init && t.init.call(this, e)
            };
            l[on](e, n);
            for (var i in t)"style" !== i && "shape" !== i && (e[ir][i] = t[i]);
            return e
        }, l[on](n, r), n
    }),e("zrender/container/Group", [gr, p, "../Element", "../core/BoundingRect"], function (t) {
        var e = t(p), i = t("../Element"), n = t("../core/BoundingRect"), r = function (t) {
            t = t || {}, i.call(this, t);
            for (var e in t)this[e] = t[e];
            this._children = [], this.__storage = null, this[s] = !0
        };
        return r[ir] = {
            constructor: r, type: "group", silent: !1, children: function () {
                return this._children.slice()
            }, childAt: function (t) {
                return this._children[t]
            }, childOfName: function (t) {
                for (var e = this._children, i = 0; i < e[zn]; i++)if (e[i].name === t)return e[i]
            }, childCount: function () {
                return this._children[zn]
            }, add: function (t) {
                return t && t !== this && t[U] !== this && (this._children.push(t), this._doAdd(t)), this
            }, addBefore: function (t, e) {
                if (t && t !== this && t[U] !== this && e && e[U] === this) {
                    var i = this._children, n = i[vn](e);
                    n >= 0 && (i[Ln](n, 0, t), this._doAdd(t))
                }
                return this
            }, _doAdd: function (t) {
                t[U] && t[U][En](t), t[U] = this;
                var e = this.__storage, i = this.__zr;
                e && e !== t.__storage && (e.addToMap(t), t instanceof r && t.addChildrenToStorage(e)), i && i.refresh()
            }, remove: function (t) {
                var i = this.__zr, n = this.__storage, a = this._children, o = e[vn](a, t);
                return 0 > o ? this : (a[Ln](o, 1), t[U] = null, n && (n.delFromMap(t.id), t instanceof r && t.delChildrenFromStorage(n)), i && i.refresh(), this)
            }, removeAll: function () {
                var t, e, i = this._children, n = this.__storage;
                for (e = 0; e < i[zn]; e++)t = i[e], n && (n.delFromMap(t.id), t instanceof r && t.delChildrenFromStorage(n)), t[U] = null;
                return i[zn] = 0, this
            }, eachChild: function (t, e) {
                for (var i = this._children, n = 0; n < i[zn]; n++) {
                    var r = i[n];
                    t.call(e, r, n)
                }
                return this
            }, traverse: function (t, e) {
                for (var i = 0; i < this._children[zn]; i++) {
                    var n = this._children[i];
                    t.call(e, n), "group" === n.type && n[yn](t, e)
                }
                return this
            }, addChildrenToStorage: function (t) {
                for (var e = 0; e < this._children[zn]; e++) {
                    var i = this._children[e];
                    t.addToMap(i), i instanceof r && i.addChildrenToStorage(t)
                }
            }, delChildrenFromStorage: function (t) {
                for (var e = 0; e < this._children[zn]; e++) {
                    var i = this._children[e];
                    t.delFromMap(i.id), i instanceof r && i.delChildrenFromStorage(t)
                }
            }, dirty: function () {
                return this[s] = !0, this.__zr && this.__zr.refresh(), this
            }, getBoundingRect: function (t) {
                for (var e = null, i = new n(0, 0, 0, 0), r = t || this._children, a = [], o = 0; o < r[zn]; o++) {
                    var s = r[o];
                    if (!s[Wn] && !s[q]) {
                        var l = s[Qi](), c = s.getLocalTransform(a);
                        c ? (i.copy(l), i[J](c), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l))
                    }
                }
                return e || i
            }
        }, e[on](r, i), r
    }),e("echarts/chart/sankey/SankeySeries", [gr, Pe, "../helper/createGraphFromNodeEdge"], function (t) {
        var e = t(Pe), i = t("../helper/createGraphFromNodeEdge"), n = e[On]({
            type: "series.sankey",
            layoutInfo: null,
            getInitialData: function (t) {
                var e = t.edges || t.links, n = t.data || t.nodes;
                if (n && e) {
                    var r = i(n, e, this, !0);
                    return r.data
                }
            },
            getGraph: function () {
                return this[ur]().graph
            },
            getEdgeData: function () {
                return this[I]().edgeData
            },
            formatTooltip: function (t, e, i) {
                if ("edge" === i) {
                    var r = this[wn](t, i), a = r.data, o = a.source + " -- " + a[Sn];
                    return r.value && (o += " : " + r.value), o
                }
                return n.superCall(this, "formatTooltip", t, e)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                layout: null,
                left: "5%",
                top: "5%",
                right: "20%",
                bottom: "5%",
                nodeWidth: 20,
                nodeGap: 8,
                layoutIterations: 32,
                label: {
                    normal: {show: !0, position: "right", textStyle: {color: "#000", fontSize: 12}},
                    emphasis: {show: !0}
                },
                itemStyle: {normal: {borderWidth: 1, borderColor: "#333"}},
                lineStyle: {normal: {color: "#314656", opacity: .2, curveness: .5}, emphasis: {opacity: .6}},
                animationEasing: "linear",
                animationDuration: 1e3
            }
        });
        return n
    }),e("zrender/graphic/Text", [gr, "./Displayable", p, "../contain/text"], function (t) {
        var e = t("./Displayable"), i = t(p), n = t("../contain/text"), r = function (t) {
            e.call(this, t)
        };
        return r[ir] = {
            constructor: r, type: "text", brush: function (t) {
                var e = this.style, i = e.x || 0, r = e.y || 0, a = e.text, o = e.fill, s = e[Ne];
                if (null != a && (a += ""), a) {
                    if (t.save(), this.style.bind(t), this.setTransform(t), o && (t.fillStyle = o), s && (t.strokeStyle = s), t.font = e.textFont || e.font, t[en] = e[en], e.textVerticalAlign) {
                        var l = n[Qi](a, t.font, e[en], "top");
                        switch (t.textBaseline = Xi, e.textVerticalAlign) {
                            case Xi:
                                r -= l[Fn] / 2 - l.lineHeight / 2;
                                break;
                            case Hn:
                                r -= l[Fn] - l.lineHeight / 2;
                                break;
                            default:
                                r += l.lineHeight / 2
                        }
                    } else t.textBaseline = e.textBaseline;
                    for (var c = n.measureText("", t.font).width, u = a.split("\n"), h = 0; h < u[zn]; h++)o && t.fillText(u[h], i, r), s && t.strokeText(u[h], i, r), r += c;
                    t.restore()
                }
            }, getBoundingRect: function () {
                if (!this._rect) {
                    var t = this.style, e = t.textVerticalAlign, i = n[Qi](t.text + "", t.textFont || t.font, t[en], e ? "top" : t.textBaseline);
                    switch (e) {
                        case Xi:
                            i.y -= i[Fn] / 2;
                            break;
                        case Hn:
                            i.y -= i[Fn]
                    }
                    i.x += t.x || 0, i.y += t.y || 0, this._rect = i
                }
                return this._rect
            }
        }, i[on](r, e), r
    }),e("echarts/component/legend/legendAction", [gr, Ri, vr], function (t) {
        function e(t, e, i) {
            var r, a = {}, o = "toggleSelected" === t;
            return i[qn]("legend", function (i) {
                o && null != r ? i[r ? "select" : "unSelect"](e.name) : (i[t](e.name), r = i.isSelected(e.name));
                var s = i[ur]();
                n.each(s, function (t) {
                    var e = t.get("name");
                    if ("\n" !== e && "" !== e) {
                        var n = i.isSelected(e);
                        a[e] = e in a ? a[e] && n : n
                    }
                })
            }), {name: e.name, selected: a}
        }

        var i = t(Ri), n = t(vr);
        i[pn]("legendToggleSelect", "legendselectchanged", n.curry(e, "toggleSelected")), i[pn]("legendSelect", "legendselected", n.curry(e, "select")), i[pn]("legendUnSelect", "legendunselected", n.curry(e, "unSelect"))
    }),e("zrender/tool/path", [gr, "../graphic/Path", "../core/PathProxy", "./transformPath", "../core/matrix"], function (t) {
        function e(t, e, i, n, r, a, o, s, l, c, u) {
            var v = l * (p / 180), y = f(v) * (t - i) / 2 + d(v) * (e - n) / 2, x = -1 * d(v) * (t - i) / 2 + f(v) * (e - n) / 2, _ = y * y / (o * o) + x * x / (s * s);
            _ > 1 && (o *= h(_), s *= h(_));
            var w = (r === a ? -1 : 1) * h((o * o * s * s - o * o * x * x - s * s * y * y) / (o * o * x * x + s * s * y * y)) || 0, b = w * o * x / s, M = w * -s * y / o, S = (t + i) / 2 + f(v) * b - d(v) * M, A = (e + n) / 2 + d(v) * b + f(v) * M, C = m([1, 0], [(y - b) / o, (x - M) / s]), T = [(y - b) / o, (x - M) / s], L = [(-1 * y - b) / o, (-1 * x - M) / s], k = m(T, L);
            g(T, L) <= -1 && (k = p), g(T, L) >= 1 && (k = 0), 0 === a && k > 0 && (k -= 2 * p), 1 === a && 0 > k && (k += 2 * p), u.addData(c, S, A, o, s, C, k, v, a)
        }

        function i(t) {
            if (!t)return [];
            var i, n = t[mn](/-/g, " -")[mn](/  /g, " ")[mn](/ /g, ",")[mn](/,,/g, ",");
            for (i = 0; i < u[zn]; i++)n = n[mn](new RegExp(u[i], "g"), "|" + u[i]);
            var r, a = n.split("|"), s = 0, l = 0, c = new o, h = o.CMD;
            for (i = 1; i < a[zn]; i++) {
                var d, f = a[i], p = f.charAt(0), v = 0, g = f.slice(1)[mn](/e,-/g, "e-").split(",");
                g[zn] > 0 && "" === g[0] && g.shift();
                for (var m = 0; m < g[zn]; m++)g[m] = parseFloat(g[m]);
                for (; v < g[zn] && !isNaN(g[v]) && !isNaN(g[0]);) {
                    var y, x, _, w, b, M, S, A = s, C = l;
                    switch (p) {
                        case"l":
                            s += g[v++], l += g[v++], d = h.L, c.addData(d, s, l);
                            break;
                        case"L":
                            s = g[v++], l = g[v++], d = h.L, c.addData(d, s, l);
                            break;
                        case"m":
                            s += g[v++], l += g[v++], d = h.M, c.addData(d, s, l), p = "l";
                            break;
                        case"M":
                            s = g[v++], l = g[v++], d = h.M, c.addData(d, s, l), p = "L";
                            break;
                        case"h":
                            s += g[v++], d = h.L, c.addData(d, s, l);
                            break;
                        case"H":
                            s = g[v++], d = h.L, c.addData(d, s, l);
                            break;
                        case"v":
                            l += g[v++], d = h.L, c.addData(d, s, l);
                            break;
                        case"V":
                            l = g[v++], d = h.L, c.addData(d, s, l);
                            break;
                        case"C":
                            d = h.C, c.addData(d, g[v++], g[v++], g[v++], g[v++], g[v++], g[v++]), s = g[v - 2], l = g[v - 1];
                            break;
                        case"c":
                            d = h.C, c.addData(d, g[v++] + s, g[v++] + l, g[v++] + s, g[v++] + l, g[v++] + s, g[v++] + l), s += g[v - 2], l += g[v - 1];
                            break;
                        case"S":
                            y = s, x = l;
                            var T = c.len(), L = c.data;
                            r === h.C && (y += s - L[T - 4], x += l - L[T - 3]), d = h.C, A = g[v++], C = g[v++], s = g[v++], l = g[v++], c.addData(d, y, x, A, C, s, l);
                            break;
                        case"s":
                            y = s, x = l;
                            var T = c.len(), L = c.data;
                            r === h.C && (y += s - L[T - 4], x += l - L[T - 3]), d = h.C, A = s + g[v++], C = l + g[v++], s += g[v++], l += g[v++], c.addData(d, y, x, A, C, s, l);
                            break;
                        case"Q":
                            A = g[v++], C = g[v++], s = g[v++], l = g[v++], d = h.Q, c.addData(d, A, C, s, l);
                            break;
                        case"q":
                            A = g[v++] + s, C = g[v++] + l, s += g[v++], l += g[v++], d = h.Q, c.addData(d, A, C, s, l);
                            break;
                        case"T":
                            y = s, x = l;
                            var T = c.len(), L = c.data;
                            r === h.Q && (y += s - L[T - 4], x += l - L[T - 3]), s = g[v++], l = g[v++], d = h.Q, c.addData(d, y, x, s, l);
                            break;
                        case"t":
                            y = s, x = l;
                            var T = c.len(), L = c.data;
                            r === h.Q && (y += s - L[T - 4], x += l - L[T - 3]), s += g[v++], l += g[v++], d = h.Q, c.addData(d, y, x, s, l);
                            break;
                        case"A":
                            _ = g[v++], w = g[v++], b = g[v++], M = g[v++], S = g[v++], A = s, C = l, s = g[v++], l = g[v++], d = h.A, e(A, C, s, l, M, S, _, w, b, d, c);
                            break;
                        case"a":
                            _ = g[v++], w = g[v++], b = g[v++], M = g[v++], S = g[v++], A = s, C = l, s += g[v++], l += g[v++], d = h.A, e(A, C, s, l, M, S, _, w, b, d, c)
                    }
                }
                ("z" === p || "Z" === p) && (d = h.Z, c.addData(d)), r = d
            }
            return c.toStatic(), c
        }

        function n(t, e) {
            var n, r = i(t);
            return e = e || {}, e[a] = function (t) {
                t.setData(r.data), n && l(t, n);
                var e = t[Zi]();
                e && t.rebuildPath(e)
            }, e[J] = function (t) {
                n || (n = c[Zn]()), c.mul(n, t, n)
            }, e
        }

        var r = t("../graphic/Path"), o = t("../core/PathProxy"), l = t("./transformPath"), c = t("../core/matrix"), u = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"], h = Math.sqrt, d = Math.sin, f = Math.cos, p = Math.PI, v = function (t) {
            return Math.sqrt(t[0] * t[0] + t[1] * t[1])
        }, g = function (t, e) {
            return (t[0] * e[0] + t[1] * e[1]) / (v(t) * v(e))
        }, m = function (t, e) {
            return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(g(t, e))
        };
        return {
            createFromString: function (t, e) {
                return new r(n(t, e))
            }, extendFromString: function (t, e) {
                return r[On](n(t, e))
            }, mergePath: function (t, e) {
                var i, n, o = [], l = t[zn];
                for (n = 0; l > n; n++)i = t[n], i[s] && i[a](i.path, i.shape), o.push(i.path);
                var c = new r(e);
                return c[a] = function (t) {
                    t.appendPath(o);
                    var e = t[Zi]();
                    e && t.rebuildPath(e)
                }, c
            }
        }
    }),e("echarts/model/globalDefault", [], function () {
        var t = "";
        return typeof navigator !== v && (t = navigator.platform || ""), {
            color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
            grid: {},
            textStyle: {
                fontFamily: t.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
                fontSize: 12,
                fontStyle: "normal",
                fontWeight: "normal"
            },
            animation: !0,
            animationThreshold: 2e3,
            animationDuration: 1e3,
            animationDurationUpdate: 300,
            animationEasing: "exponentialOut",
            animationEasingUpdate: "cubicOut"
        }
    }),e("zrender/graphic/shape/Polygon", [gr, "../helper/poly", "../Path"], function (t) {
        var e = t("../helper/poly");
        return t("../Path")[On]({
            type: "polygon",
            shape: {points: null, smooth: !1, smoothConstraint: null},
            buildPath: function (t, i) {
                e[a](t, i, !0)
            }
        })
    }),e("zrender/graphic/Image", [gr, "./Displayable", "../core/BoundingRect", p, "./helper/roundRect", "../core/LRU"], function (t) {
        function e(t) {
            i.call(this, t)
        }

        var i = t("./Displayable"), n = t("../core/BoundingRect"), r = t(p), s = t("./helper/roundRect"), l = t("../core/LRU"), c = new l(50);
        return e[ir] = {
            constructor: e, type: "image", brush: function (t) {
                var e, i = this.style, n = i.image;
                if (e = typeof n === er ? this._image : n, !e && n) {
                    var r = c.get(n);
                    if (!r)return e = new Image, e.onload = function () {
                        e.onload = null;
                        for (var t = 0; t < r.pending[zn]; t++)r.pending[t].dirty()
                    }, r = {image: e, pending: [this]}, e.src = n, c.put(n, r), void(this._image = e);
                    if (e = r.image, this._image = e, !e.width || !e[Fn])return void r.pending.push(this)
                }
                if (e) {
                    var l = i.width || e.width, u = i[Fn] || e[Fn], h = i.x || 0, d = i.y || 0;
                    if (!e.width || !e[Fn])return;
                    if (t.save(), i.bind(t), this.setTransform(t), i.r && (t[o](), s[a](t, i), t.clip()), i.sWidth && i.sHeight) {
                        var f = i.sx || 0, p = i.sy || 0;
                        t.drawImage(e, f, p, i.sWidth, i.sHeight, h, d, l, u)
                    } else if (i.sx && i.sy) {
                        var f = i.sx, p = i.sy, v = l - f, g = u - p;
                        t.drawImage(e, f, p, v, g, h, d, l, u)
                    } else t.drawImage(e, h, d, l, u);
                    null == i.width && (i.width = l), null == i[Fn] && (i[Fn] = u), null != i.text && this.drawRectText(t, this[Qi]()), t.restore()
                }
            }, getBoundingRect: function () {
                var t = this.style;
                return this._rect || (this._rect = new n(t.x || 0, t.y || 0, t.width || 0, t[Fn] || 0)), this._rect
            }
        }, r[on](e, i), e
    }),e("zrender/graphic/shape/Rect", [gr, "../helper/roundRect", "../Path"], function (t) {
        var e = t("../helper/roundRect");
        return t("../Path")[On]({
            type: "rect",
            shape: {r: 0, x: 0, y: 0, width: 0, height: 0},
            buildPath: function (t, n) {
                var r = n.x, o = n.y, s = n.width, l = n[Fn];
                n.r ? e[a](t, n) : t.rect(r, o, s, l), t[i]()
            }
        })
    }),e("zrender/graphic/shape/Line", [gr, "../Path"], function (t) {
        return t("../Path")[On]({
            type: "line",
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, percent: 1},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i = e.x1, r = e.y1, a = e.x2, o = e.y2, s = e.percent;
                0 !== s && (t[d](i, r), 1 > s && (a = i * (1 - s) + a * s, o = r * (1 - s) + o * s), t[n](a, o))
            },
            pointAt: function (t) {
                var e = this.shape;
                return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
            }
        })
    }),e("zrender/graphic/shape/BezierCurve", [gr, "../../core/curve", "../../core/vector", "../Path"], function (t) {
        function e(t, e, i) {
            var n = t.cpx2, r = t.cpy2;
            return null === n || null === r ? [(i ? u : l)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? u : l)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? c : s)(t.x1, t.cpx1, t.x2, e), (i ? c : s)(t.y1, t.cpy1, t.y2, e)]
        }

        var i = t("../../core/curve"), n = t("../../core/vector"), a = i.quadraticSubdivide, o = i.cubicSubdivide, s = i.quadraticAt, l = i.cubicAt, c = i.quadraticDerivativeAt, u = i.cubicDerivativeAt, h = [];
        return t("../Path")[On]({
            type: "bezier-curve",
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i = e.x1, n = e.y1, s = e.x2, l = e.y2, c = e.cpx1, u = e.cpy1, f = e.cpx2, p = e.cpy2, v = e.percent;
                0 !== v && (t[d](i, n), null == f || null == p ? (1 > v && (a(i, c, s, v, h), c = h[1], s = h[2], a(n, u, l, v, h), u = h[1], l = h[2]), t.quadraticCurveTo(c, u, s, l)) : (1 > v && (o(i, c, f, s, v, h), c = h[1], f = h[2], s = h[3], o(n, u, p, l, v, h), u = h[1], p = h[2], l = h[3]), t[r](c, u, f, p, s, l)))
            },
            pointAt: function (t) {
                return e(this.shape, t, !1)
            },
            tangentAt: function (t) {
                var i = e(this.shape, t, !0);
                return n[gi](i, i)
            }
        })
    }),e("zrender/graphic/shape/Arc", [gr, "../Path"], function (t) {
        return t("../Path")[On]({
            type: "arc",
            shape: {cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, e) {
                var i = e.cx, n = e.cy, r = Math.max(e.r, 0), a = e[di], o = e.endAngle, s = e[Fe], l = Math.cos(a), c = Math.sin(a);
                t[d](l * r + i, c * r + n), t.arc(i, n, r, a, o, !s)
            }
        })
    }),e("zrender/graphic/CompoundPath", [gr, "./Path"], function (t) {
        var e = t("./Path");
        return e[On]({
            type: "compound", shape: {paths: null}, _updatePathDirty: function () {
                for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e[zn]; i++)t = t || e[i].__dirtyPath;
                this.__dirtyPath = t, this[s] = this[s] || t
            }, beforeBrush: function () {
                this._updatePathDirty();
                for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t[zn]; i++)t[i].path.setScale(e[0], e[1])
            }, buildPath: function (t, e) {
                for (var i = e.paths || [], n = 0; n < i[zn]; n++)i[n][a](t, i[n].shape)
            }, afterBrush: function () {
                for (var t = this.shape.paths, e = 0; e < t[zn]; e++)t[e].__dirtyPath = !1
            }, getBoundingRect: function () {
                return this._updatePathDirty(), e[ir][Qi].call(this)
            }
        })
    }),e("zrender/graphic/LinearGradient", [gr, p, "./Gradient"], function (t) {
        var e = t(p), i = t("./Gradient"), n = function (t, e, n, r, a) {
            this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == n ? 1 : n, this.y2 = null == r ? 0 : r, i.call(this, a)
        };
        return n[ir] = {constructor: n, type: "linear"}, e[on](n, i), n
    }),e("zrender/graphic/shape/Circle", [gr, "../Path"], function (t) {
        return t("../Path")[On]({
            type: "circle", shape: {cx: 0, cy: 0, r: 0}, buildPath: function (t, e) {
                t[d](e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
            }
        })
    }),e("zrender/graphic/RadialGradient", [gr, p, "./Gradient"], function (t) {
        var e = t(p), i = t("./Gradient"), n = function (t, e, n, r) {
            this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == n ? .5 : n, i.call(this, r)
        };
        return n[ir] = {constructor: n, type: "radial"}, e[on](n, i), n
    }),e(X, [gr, "./vector", "./matrix"], function (t) {
        function e(t, e, i, n) {
            this.x = t, this.y = e, this.width = i, this[Fn] = n
        }

        var i = t("./vector"), n = t("./matrix"), r = i[J], a = Math.min, o = Math.abs, s = Math.max;
        return e[ir] = {
            constructor: e, union: function (t) {
                var e = a(t.x, this.x), i = a(t.y, this.y);
                this.width = s(t.x + t.width, this.x + this.width) - e, this[Fn] = s(t.y + t[Fn], this.y + this[Fn]) - i, this.x = e, this.y = i
            }, applyTransform: function () {
                var t = [], e = [];
                return function (i) {
                    i && (t[0] = this.x, t[1] = this.y, e[0] = this.x + this.width, e[1] = this.y + this[Fn], r(t, t, i), r(e, e, i), this.x = a(t[0], e[0]), this.y = a(t[1], e[1]), this.width = o(e[0] - t[0]), this[Fn] = o(e[1] - t[1]))
                }
            }(), calculateTransform: function (t) {
                var e = this, i = t.width / e.width, r = t[Fn] / e[Fn], a = n[Zn]();
                return n.translate(a, a, [-e.x, -e.y]), n.scale(a, a, [i, r]), n.translate(a, a, [t.x, t.y]), a
            }, intersect: function (t) {
                var e = this, i = e.x, n = e.x + e.width, r = e.y, a = e.y + e[Fn], o = t.x, s = t.x + t.width, l = t.y, c = t.y + t[Fn];
                return !(o > n || i > s || l > a || r > c)
            }, contain: function (t, e) {
                var i = this;
                return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i[Fn]
            }, clone: function () {
                return new e(this.x, this.y, this.width, this[Fn])
            }, copy: function (t) {
                this.x = t.x, this.y = t.y, this.width = t.width, this[Fn] = t[Fn]
            }
        }, e
    }),e("echarts/coord/polar/Polar", [gr, "./RadiusAxis", "./AngleAxis"], function (t) {
        var e = t("./RadiusAxis"), i = t("./AngleAxis"), n = function (t) {
            this.name = t || "", this.cx = 0, this.cy = 0, this._radiusAxis = new e, this._angleAxis = new i
        };
        return n[ir] = {
            constructor: n, type: "polar", dimensions: [Oe, "angle"], containPoint: function (t) {
                var e = this.pointToCoord(t);
                return this._radiusAxis[mi](e[0]) && this._angleAxis[mi](e[1])
            }, containData: function (t) {
                return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1])
            }, getAxis: function (t) {
                return this["_" + t + "Axis"]
            }, getAxesByScale: function (t) {
                var e = [], i = this._angleAxis, n = this._radiusAxis;
                return i.scale.type === t && e.push(i), n.scale.type === t && e.push(n), e
            }, getAngleAxis: function () {
                return this._angleAxis
            }, getRadiusAxis: function () {
                return this._radiusAxis
            }, getOtherAxis: function (t) {
                var e = this._angleAxis;
                return t === e ? this._radiusAxis : e
            }, getBaseAxis: function () {
                return this.getAxesByScale(se)[0] || this.getAxesByScale("time")[0] || this.getAngleAxis()
            }, dataToPoints: function (t) {
                return t[K](this[Te], function (t, e) {
                    return this[Se]([t, e])
                }, this)
            }, dataToPoint: function (t, e) {
                return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)])
            }, pointToData: function (t, e) {
                var i = this.pointToCoord(t);
                return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)]
            }, pointToCoord: function (t) {
                var e = t[0] - this.cx, i = t[1] - this.cy, n = this.getAngleAxis(), r = n[we](), a = Math.min(r[0], r[1]), o = Math.max(r[0], r[1]);
                n[fe] ? a = o - 360 : o = a + 360;
                var s = Math.sqrt(e * e + i * i);
                e /= s, i /= s;
                for (var l = Math.atan2(-i, e) / Math.PI * 180, c = a > l ? 1 : -1; a > l || l > o;)l += 360 * c;
                return [s, l]
            }, coordToPoint: function (t) {
                var e = t[0], i = t[1] / 180 * Math.PI, n = Math.cos(i) * e + this.cx, r = -Math.sin(i) * e + this.cy;
                return [n, r]
            }
        }, n
    }),e("echarts/coord/polar/PolarModel", [gr, "./AxisModel", Ri], function (t) {
        t("./AxisModel"), t(Ri)[un]({
            type: "polar",
            dependencies: ["polarAxis", "angleAxis"],
            coordinateSystem: null,
            findAxisModel: function (t) {
                var e, i = this[j];
                return i[qn](t, function (t) {
                    i[ve]("polar", t[N](Y)) === this && (e = t)
                }, this), e
            },
            defaultOption: {zlevel: 0, z: 0, center: ["50%", "50%"], radius: "80%"}
        })
    }),e("echarts/component/visualMap/preprocessor", [gr, vr], function (t) {
        function e(t, e) {
            return t && t.hasOwnProperty && t.hasOwnProperty(e)
        }

        var i = t(vr), n = i.each;
        return function (t) {
            var r = t && t.visualMap;
            i[gn](r) || (r = r ? [r] : []), n(r, function (t) {
                if (t) {
                    e(t, "splitList") && !e(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
                    var r = t.pieces;
                    r && i[gn](r) && n(r, function (t) {
                        i[Bn](t) && (e(t, "start") && !e(t, "min") && (t.min = t.start), e(t, "end") && !e(t, "max") && (t.max = t.end))
                    })
                }
            })
        }
    }),e("echarts/component/visualMap/typeDefaulter", [gr, c], function (t) {
        t(c).registerSubTypeDefaulter("visualMap", function (t) {
            return t[D] || (t.pieces ? t.pieces[zn] > 0 : t[S] > 0) && !t.calculable ? "piecewise" : "continuous"
        })
    }),e("echarts/component/visualMap/visualCoding", [gr, Ri, "../../visual/VisualMapping", vr], function (t) {
        function e(t) {
            var e = t.targetVisuals, i = {};
            r.each(["inRange", "outOfRange"], function (t) {
                var r = n.prepareVisualTypes(e[t]);
                i[t] = r
            }), t.eachTargetSeries(function (n) {
                function r(t) {
                    return s[Mi](o, t)
                }

                function a(t, e) {
                    s[wi](o, t, e)
                }

                var o, s = n[ur](), l = t.getDataDimension(s);
                s.each([l], function (n, s) {
                    o = s;
                    for (var l = t.getValueState(n), c = e[l], u = i[l], h = 0, d = u[zn]; d > h; h++) {
                        var f = u[h];
                        c[f] && c[f].applyVisual(n, r, a)
                    }
                }, !0)
            })
        }

        var i = t(Ri), n = t("../../visual/VisualMapping"), r = t(vr);
        i.registerVisualCoding("component", function (t) {
            t[qn]("visualMap", function (i) {
                e(i, t)
            })
        })
    }),e("echarts/component/visualMap/ContinuousModel", [gr, "./VisualMapModel", vr, Be], function (t) {
        var e = t("./VisualMapModel"), i = t(vr), n = t(Be), r = [20, 140], a = e[On]({
            type: "visualMap.continuous",
            defaultOption: {
                align: "auto",
                calculable: !1,
                range: null,
                realtime: !0,
                itemHeight: null,
                itemWidth: null,
                hoverLink: !0
            },
            doMergeOption: function (t, e) {
                a[Vi](this, "doMergeOption", arguments), this.resetTargetSeries(t, e), this.resetExtent(), this.resetVisual(function (t) {
                    t.mappingMethod = "linear"
                }), this._resetRange()
            },
            resetItemSize: function () {
                e[ir].resetItemSize.apply(this, arguments);
                var t = this.itemSize;
                this._orient === Ae && t[k](), (null == t[0] || isNaN(t[0])) && (t[0] = r[0]), (null == t[1] || isNaN(t[1])) && (t[1] = r[1])
            },
            _resetRange: function () {
                var t = this[we](), e = this[Pi].range;
                !e || e.auto ? (t.auto = 1, this[Pi].range = t) : i[gn](e) && (e[0] > e[1] && e[k](), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1]))
            },
            completeVisualOption: function () {
                e[ir].completeVisualOption.apply(this, arguments), i.each(this.stateList, function (t) {
                    var e = this[Pi].controller[t][xe];
                    e && e[0] !== e[1] && (e[0] = 0)
                }, this)
            },
            setSelected: function (t) {
                this[Pi].range = t.slice(), this._resetRange()
            },
            getSelected: function () {
                var t = this[we](), e = n.asc((this.get("range") || []).slice());
                return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), e[1] < t[0] && (e[1] = t[0]), e
            },
            getValueState: function (t) {
                var e = this[Pi].range, i = this[we]();
                return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange" : "outOfRange"
            },
            findTargetDataIndices: function (t) {
                var e = [];
                return this.eachTargetSeries(function (i) {
                    var n = [], r = i[ur]();
                    r.each(this.getDataDimension(r), function (e, i) {
                        t[0] <= e && e <= t[1] && n.push(i)
                    }, !0, this), e.push({seriesId: i.id, dataIndices: n})
                }, this), e
            }
        });
        return a
    }),e("zrender/graphic/shape/Sector", [gr, "../Path"], function (t) {
        return t("../Path")[On]({
            type: "sector",
            shape: {cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
            buildPath: function (t, e) {
                var r = e.cx, a = e.cy, o = Math.max(e.r0 || 0, 0), s = Math.max(e.r, 0), l = e[di], c = e.endAngle, u = e[Fe], h = Math.cos(l), f = Math.sin(l);
                t[d](h * o + r, f * o + a), t[n](h * s + r, f * s + a), t.arc(r, a, s, l, c, !u), t[n](Math.cos(c) * o + r, Math.sin(c) * o + a), 0 !== o && t.arc(r, a, o, c, l, u), t[i]()
            }
        })
    }),e("echarts/component/visualMap/ContinuousView", [gr, "./VisualMapView", vi, vr, Be, "../helper/sliderMove", "zrender/graphic/LinearGradient", "./helper"], function (t) {
        function e(t, e, i) {
            return new a[R]({shape: {points: t}, draggable: !!e, cursor: i, drift: e})
        }

        function i(t, e) {
            return 0 === t ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]]
        }

        function n(t, e, i) {
            return t ? [[0, -m(x, y(e, 0))], [_, 0], [0, m(x, y(i - e, 0))]] : [[0, 0], [5, -5], [5, 5]]
        }

        var r = t("./VisualMapView"), a = t(vi), o = t(vr), s = t(Be), l = t("../helper/sliderMove"), c = t("zrender/graphic/LinearGradient"), d = t("./helper"), p = s[ze], v = d.convertDataIndicesToBatch, g = o.each, m = Math.min, y = Math.max, x = 6, _ = 6, w = r[On]({
            type: "visualMap.continuous", init: function () {
                r[ir].init.apply(this, arguments), this._shapes = {}, this._dataInterval = [], this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = []
            }, doRender: function (t, e, i, n) {
                n && "selectDataRange" === n.type && n.from === this.uid ? this._updateView() : this._buildView()
            }, _buildView: function () {
                this.group[rn]();
                var t = this.visualMapModel, e = this.group;
                this._orient = t.get(u), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(e);
                var i = t.get("text");
                this._renderEndsText(e, i, 0), this._renderEndsText(e, i, 1), this._updateView(!0), this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(e)
            }, _renderEndsText: function (t, e, i) {
                if (e) {
                    var n = e[1 - i];
                    n = null != n ? n + "" : "";
                    var r = this.visualMapModel, o = r.get("textGap"), s = r.itemSize, l = this._shapes.barGroup, c = this._applyTransform([s[0] / 2, 0 === i ? -o : s[1] + o], l), u = this._applyTransform(0 === i ? Hn : "top", l), h = this._orient, d = this.visualMapModel.textStyleModel;
                    this.group.add(new a.Text({
                        style: {
                            x: c[0],
                            y: c[1],
                            textVerticalAlign: h === Ae ? Xi : u,
                            textAlign: h === Ae ? u : ji,
                            text: n,
                            textFont: d[tn](),
                            fill: d[$i]()
                        }
                    }))
                }
            }, _renderBar: function (t) {
                var i = this.visualMapModel, n = this._shapes, r = i.itemSize, a = this._orient, s = this._useHandle, l = d.getItemAlign(i, this.api, r), c = n.barGroup = this._createBarGroup(l);
                c.add(n.outOfRange = e()), c.add(n.inRange = e(null, o.bind(this._modifyHandle, this, "all"), s ? "move" : null));
                var u = i.textStyleModel.getTextRect(""), h = Math.max(u.width, u[Fn]);
                s && (n.handleThumbs = [], n.handleLabels = [], n.handleLabelPoints = [], this._createHandle(c, 0, r, h, a, l), this._createHandle(c, 1, r, h, a, l)), this._createIndicator(c, r, h, a), t.add(c)
            }, _createHandle: function (t, n, r, s, l) {
                var c = o.bind(this._modifyHandle, this, n), u = e(i(n, s), c, "move");
                u[Ui][0] = r[0], t.add(u);
                var h = this.visualMapModel.textStyleModel, d = new a.Text({
                    draggable: !0,
                    drift: c,
                    style: {x: 0, y: 0, text: "", textFont: h[tn](), fill: h[$i]()}
                });
                this.group.add(d);
                var f = [l === Ae ? s / 2 : 1.5 * s, l === Ae ? 0 === n ? -(1.5 * s) : 1.5 * s : 0 === n ? -s / 2 : s / 2], p = this._shapes;
                p.handleThumbs[n] = u, p.handleLabelPoints[n] = f, p.handleLabels[n] = d
            }, _createIndicator: function (t, i, n, r) {
                var o = e([[0, 0]], null, "move");
                o[Ui][0] = i[0], o.attr({invisible: !0, silent: !0}), t.add(o);
                var s = this.visualMapModel.textStyleModel, l = new a.Text({
                    silent: !0,
                    invisible: !0,
                    style: {x: 0, y: 0, text: "", textFont: s[tn](), fill: s[$i]()}
                });
                this.group.add(l);
                var c = [r === Ae ? n / 2 : _ + 3, 0], u = this._shapes;
                u.indicator = o, u.indicatorLabel = l, u.indicatorLabelPoint = c
            }, _modifyHandle: function (t, e, i) {
                if (this._useHandle) {
                    var n = this._applyTransform([e, i], this._shapes.barGroup, !0);
                    this._updateInterval(t, n[1]), this.api[Rn]({
                        type: "selectDataRange",
                        from: this.uid,
                        visualMapId: this.visualMapModel.id,
                        selected: this._dataInterval.slice()
                    })
                }
            }, _resetInterval: function () {
                var t = this.visualMapModel, e = this._dataInterval = t.getSelected(), i = t[we](), n = [0, t.itemSize[1]];
                this._handleEnds = [p(e[0], i, n, !0), p(e[1], i, n, !0)]
            }, _updateInterval: function (t, e) {
                e = e || 0;
                var i = this.visualMapModel, n = this._handleEnds;
                l(e, n, [0, i.itemSize[1]], "all" === t ? "rigid" : "push", t);
                var r = i[we](), a = [0, i.itemSize[1]];
                this._dataInterval = [p(n[0], a, r, !0), p(n[1], a, r, !0)]
            }, _updateView: function (t) {
                var e = this.visualMapModel, i = e[we](), n = this._shapes, r = [0, e.itemSize[1]], a = t ? r : this._handleEnds, o = this._createBarVisual(this._dataInterval, i, a, "inRange"), s = this._createBarVisual(i, i, r, "outOfRange");
                n.inRange[qi]({
                    fill: o.barColor,
                    opacity: o[Hi]
                })[ii](V, o.barPoints), n.outOfRange[qi]({
                    fill: s.barColor,
                    opacity: s[Hi]
                })[ii](V, s.barPoints), this._updateHandle(a, o)
            }, _createBarVisual: function (t, e, i, n) {
                var r = {
                    forceState: n,
                    convertOpacityToAlpha: !0
                }, a = this._makeColorGradient(t, r), o = [this.getControllerVisual(t[0], xe, r), this.getControllerVisual(t[1], xe, r)], s = this._createBarPoints(i, o);
                return {barColor: new c(0, 0, 1, 1, a), barPoints: s, handlesColor: [a[0].color, a[a[zn] - 1].color]}
            }, _makeColorGradient: function (t, e) {
                var i = 100, n = [], r = (t[1] - t[0]) / i;
                n.push({color: this.getControllerVisual(t[0], "color", e), offset: 0});
                for (var a = 1; i > a; a++) {
                    var o = t[0] + r * a;
                    if (o > t[1])break;
                    n.push({color: this.getControllerVisual(o, "color", e), offset: a / i})
                }
                return n.push({color: this.getControllerVisual(t[1], "color", e), offset: 1}), n
            }, _createBarPoints: function (t, e) {
                var i = this.visualMapModel.itemSize;
                return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]]
            }, _createBarGroup: function (t) {
                var e = this._orient, i = this.visualMapModel.get(fe);
                return new a.Group(e !== Ae || i ? e === Ae && i ? {
                    scale: t === Hn ? [-1, 1] : [1, 1],
                    rotation: -Math.PI / 2
                } : e !== f || i ? {scale: "left" === t ? [1, 1] : [-1, 1]} : {scale: "left" === t ? [1, -1] : [-1, -1]} : {
                    scale: t === Hn ? [1, 1] : [-1, 1],
                    rotation: Math.PI / 2
                })
            }, _updateHandle: function (t, e) {
                if (this._useHandle) {
                    var i = this._shapes, n = this.visualMapModel, r = i.handleThumbs, o = i.handleLabels;
                    g([0, 1], function (s) {
                        var l = r[s];
                        l[qi]("fill", e.handlesColor[s]), l[Ui][1] = t[s];
                        var c = a[J](i.handleLabelPoints[s], a.getTransform(l, this.group));
                        o[s][qi]({
                            x: c[0],
                            y: c[1],
                            text: n.formatValueText(this._dataInterval[s]),
                            textVerticalAlign: "middle",
                            textAlign: this._applyTransform(this._orient === Ae ? 0 === s ? Hn : "top" : "left", i.barGroup)
                        })
                    }, this)
                }
            }, _showIndicator: function (t, e) {
                var i = this.visualMapModel, r = i[we](), o = i.itemSize, s = [0, o[1]], l = p(t, r, s, !0), c = this._shapes, u = c.indicator;
                if (u) {
                    u[Ui][1] = l, u.attr(q, !1), u[ii](V, n(e, l, o[1]));
                    var h = {convertOpacityToAlpha: !0}, d = this.getControllerVisual(t, "color", h);
                    u[qi]("fill", d);
                    var f = a[J](c.indicatorLabelPoint, a.getTransform(u, this.group)), v = c.indicatorLabel;
                    v.attr(q, !1);
                    var g = this._applyTransform("left", c.barGroup), m = this._orient;
                    v[qi]({
                        text: (e ? "" : "") + i.formatValueText(t),
                        textVerticalAlign: m === Ae ? g : Xi,
                        textAlign: m === Ae ? ji : g,
                        x: f[0],
                        y: f[1]
                    })
                }
            }, _enableHoverLinkToSeries: function () {
                function t(t) {
                    var e = this.visualMapModel, i = e.itemSize;
                    if (e[Pi].hoverLink) {
                        var n = this._applyTransform([t[F], t[Z]], this._shapes.barGroup, !0, !0), r = [n[1] - x / 2, n[1] + x / 2], a = [0, i[1]], o = e[we](), s = [p(r[0], a, o, !0), p(r[1], a, o, !0)];
                        0 <= n[0] && n[0] <= i[0] && this._showIndicator((s[0] + s[1]) / 2, !0);
                        var l = v(this._hoverLinkDataIndices);
                        this._hoverLinkDataIndices = e.findTargetDataIndices(s);
                        var c = v(this._hoverLinkDataIndices), u = d.removeDuplicateBatch(l, c);
                        this.api[Rn]({type: "downplay", batch: u[0]}), this.api[Rn]({type: "highlight", batch: u[1]})
                    }
                }

                this._shapes.barGroup.on(h, o.bind(t, this)).on(An, o.bind(this._clearHoverLinkToSeries, this))
            }, _enableHoverLinkFromSeries: function () {
                var t = this.api.getZr();
                this.visualMapModel[Pi].hoverLink ? (t.on(Cn, this._hoverLinkFromSeriesMouseOver, this), t.on(An, this._hideIndicator, this)) : this._clearHoverLinkFromSeries()
            }, _hoverLinkFromSeriesMouseOver: function (t) {
                var e = t[Sn];
                if (e && null != e[Mn]) {
                    var i = e.dataModel || this[j].getSeriesByIndex(e[bn]), n = i[ur](e[_n]), r = n.getDimension(this.visualMapModel.getDataDimension(n)), a = n.get(r, e[Mn], !0);
                    this._showIndicator(a)
                }
            }, _hideIndicator: function () {
                var t = this._shapes;
                t.indicator && t.indicator.attr(q, !0), t.indicatorLabel && t.indicatorLabel.attr(q, !0)
            }, _clearHoverLinkToSeries: function () {
                this._hideIndicator();
                var t = this._hoverLinkDataIndices;
                this.api[Rn]({type: "downplay", batch: v(t)}), t[zn] = 0
            }, _clearHoverLinkFromSeries: function () {
                this._hideIndicator();
                var t = this.api.getZr();
                t.off(Cn, this._hoverLinkFromSeriesMouseOver), t.off(An, this._hideIndicator)
            }, _applyTransform: function (t, e, i, n) {
                var r = a.getTransform(e, n ? null : this.group);
                return a[o[gn](t) ? J : "transformDirection"](t, r, i)
            }, dispose: function () {
                this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
            }, remove: function () {
                this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
            }
        });
        return w
    }),e("echarts/component/toolbox/featureManager", [gr], function () {
        var t = {};
        return {
            register: function (e, i) {
                t[e] = i
            }, get: function (e) {
                return t[e]
            }
        }
    }),e("echarts/util/component", [gr, vr, "./clazz"], function (t) {
        var e = t(vr), i = t("./clazz"), n = i.parseClassType, r = 0, a = {}, o = "_";
        return a.getUID = function (t) {
            return [t || "", r++, Math.random()].join(o)
        }, a.enableSubTypeDefaulter = function (t) {
            var e = {};
            return t.registerSubTypeDefaulter = function (t, i) {
                t = n(t), e[t.main] = i
            }, t.determineSubType = function (i, r) {
                var a = r.type;
                if (!a) {
                    var o = n(i).main;
                    t.hasSubTypes(i) && e[o] && (a = e[o](r))
                }
                return a
            }, t
        }, a.enableTopologicalTravel = function (t, i) {
            function n(t) {
                var n = {}, o = [];
                return e.each(t, function (s) {
                    var l = r(n, s), c = l.originalDeps = i(s), u = a(c, t);
                    l.entryCount = u[zn], 0 === l.entryCount && o.push(s), e.each(u, function (t) {
                        e[vn](l.predecessor, t) < 0 && l.predecessor.push(t);
                        var i = r(n, t);
                        e[vn](i.successor, t) < 0 && i.successor.push(s)
                    })
                }), {graph: n, noEntryList: o}
            }

            function r(t, e) {
                return t[e] || (t[e] = {predecessor: [], successor: []}), t[e]
            }

            function a(t, i) {
                var n = [];
                return e.each(t, function (t) {
                    e[vn](i, t) >= 0 && n.push(t)
                }), n
            }

            t.topologicalTravel = function (t, i, r, a) {
                function o(t) {
                    c[t].entryCount--, 0 === c[t].entryCount && u.push(t)
                }

                function s(t) {
                    h[t] = !0, o(t)
                }

                if (t[zn]) {
                    var l = n(i), c = l.graph, u = l.noEntryList, h = {};
                    for (e.each(t, function (t) {
                        h[t] = !0
                    }); u[zn];) {
                        var d = u.pop(), f = c[d], p = !!h[d];
                        p && (r.call(a, d, f.originalDeps.slice()), delete h[d]), e.each(f.successor, p ? s : o)
                    }
                    e.each(h, function () {
                        throw new Error("Circle dependency may exists")
                    })
                }
            }
        }, a
    }),e("echarts/util/clazz", [gr, vr], function (t) {
        function e(t, e) {
            var i = n.slice(arguments, 2);
            return this.superClass[ir][e].apply(t, i)
        }

        function i(t, e, i) {
            return this.superClass[ir][e].apply(t, i)
        }

        var n = t(vr), r = {}, a = ".", o = "___EC__COMPONENT__CONTAINER___", s = r.parseClassType = function (t) {
            var e = {main: "", sub: ""};
            return t && (t = t.split(a), e.main = t[0] || "", e.sub = t[1] || ""), e
        };
        return r.enableClassExtend = function (t, r) {
            t[On] = function (a) {
                var o = function () {
                    r && r.apply(this, arguments), t.apply(this, arguments)
                };
                return n[On](o[ir], a), o[On] = this[On], o.superCall = e, o[Vi] = i, n[on](o, this), o.superClass = this, o
            }
        }, r.enableClassManagement = function (t, e) {
            function i(t) {
                var e = r[t.main];
                return e && e[o] || (e = r[t.main] = {}, e[o] = !0), e
            }

            e = e || {};
            var r = {};
            if (t.registerClass = function (t, e) {
                    if (e)if (e = s(e), e.sub) {
                        if (e.sub !== o) {
                            var n = i(e);
                            n[e.sub] = t
                        }
                    } else {
                        if (r[e.main])throw new Error(e.main + "exists.");
                        r[e.main] = t
                    }
                    return t
                }, t.getClass = function (t, e, i) {
                    var n = r[t];
                    if (n && n[o] && (n = e ? n[e] : null), i && !n)throw new Error("Component " + t + "." + (e || "") + " not exists. Load it first.");
                    return n
                }, t.getClassesByMainType = function (t) {
                    t = s(t);
                    var e = [], i = r[t.main];
                    return i && i[o] ? n.each(i, function (t, i) {
                        i !== o && e.push(t)
                    }) : e.push(i), e
                }, t.hasClass = function (t) {
                    return t = s(t), !!r[t.main]
                }, t.getAllClassMainTypes = function () {
                    var t = [];
                    return n.each(r, function (e, i) {
                        t.push(i)
                    }), t
                }, t.hasSubTypes = function (t) {
                    t = s(t);
                    var e = r[t.main];
                    return e && e[o]
                }, t.parseClassType = s, e.registerWhenExtend) {
                var a = t[On];
                a && (t[On] = function (e) {
                    var i = a.call(this, e);
                    return t.registerClass(i, e.type)
                })
            }
            return t
        }, r.setReadOnly = function () {
        }, r
    }),e("zrender/graphic/shape/Ring", [gr, "../Path"], function (t) {
        return t("../Path")[On]({
            type: "ring", shape: {cx: 0, cy: 0, r: 0, r0: 0}, buildPath: function (t, e) {
                var i = e.cx, n = e.cy, r = 2 * Math.PI;
                t[d](i + e.r, n), t.arc(i, n, e.r, 0, r, !1), t[d](i + e.r0, n), t.arc(i, n, e.r0, 0, r, !0)
            }
        })
    }),e("zrender/graphic/shape/Polyline", [gr, "../helper/poly", "../Path"], function (t) {
        var e = t("../helper/poly");
        return t("../Path")[On]({
            type: "polyline",
            shape: {points: null, smooth: !1, smoothConstraint: null},
            style: {stroke: "#000", fill: null},
            buildPath: function (t, i) {
                e[a](t, i, !1)
            }
        })
    }),e("zrender/core/PathProxy", [gr, "./curve", "./vector", "./bbox", "./BoundingRect", "../config"], function (t) {
        var e = t("./curve"), a = t("./vector"), s = t("./bbox"), c = t("./BoundingRect"), u = t("../config").devicePixelRatio, h = {
            M: 1,
            L: 2,
            C: 3,
            Q: 4,
            A: 5,
            Z: 6,
            R: 7
        }, f = [], p = [], g = [], m = [], y = Math.min, x = Math.max, _ = Math.cos, w = Math.sin, b = Math.sqrt, M = Math.abs, S = typeof Float32Array != v, A = function () {
            this.data = [], this._len = 0, this._ctx = null, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._ux = 0, this._uy = 0
        };
        return A[ir] = {
            constructor: A,
            _lineDash: null,
            _dashOffset: 0,
            _dashIdx: 0,
            _dashSum: 0,
            setScale: function (t, e) {
                this._ux = M(1 / u / t) || 0, this._uy = M(1 / u / e) || 0
            },
            getContext: function () {
                return this._ctx
            },
            beginPath: function (t) {
                return this._ctx = t, t && t[o](), this._len = 0, this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
            },
            moveTo: function (t, e) {
                return this.addData(h.M, t, e), this._ctx && this._ctx[d](t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
            },
            lineTo: function (t, e) {
                var i = M(t - this._xi) > this._ux || M(e - this._yi) > this._uy || 0 === this._len;
                return this.addData(h.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx[n](t, e)), i && (this._xi = t, this._yi = e), this
            },
            bezierCurveTo: function (t, e, i, n, a, o) {
                return this.addData(h.C, t, e, i, n, a, o), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, a, o) : this._ctx[r](t, e, i, n, a, o)), this._xi = a, this._yi = o, this
            },
            quadraticCurveTo: function (t, e, i, n) {
                return this.addData(h.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this
            },
            arc: function (t, e, i, n, r, a) {
                return this.addData(h.A, t, e, i, i, n, r - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, a), this._xi = _(r) * i + t, this._xi = w(r) * i + t, this
            },
            arcTo: function (t, e, i, n, r) {
                return this._ctx && this._ctx.arcTo(t, e, i, n, r), this
            },
            rect: function (t, e, i, n) {
                return this._ctx && this._ctx.rect(t, e, i, n), this.addData(h.R, t, e, i, n), this
            },
            closePath: function () {
                this.addData(h.Z);
                var t = this._ctx, e = this._x0, n = this._y0;
                return t && (this._needsDash() && this._dashedLineTo(e, n), t[i]()), this._xi = e, this._yi = n, this
            },
            fill: function (t) {
                t && t.fill(), this.toStatic()
            },
            stroke: function (t) {
                t && t[Ne](), this.toStatic()
            },
            setLineDash: function (t) {
                if (t instanceof Array) {
                    this._lineDash = t, this._dashIdx = 0;
                    for (var e = 0, i = 0; i < t[zn]; i++)e += t[i];
                    this._dashSum = e
                }
                return this
            },
            setLineDashOffset: function (t) {
                return this._dashOffset = t, this
            },
            len: function () {
                return this._len
            },
            setData: function (t) {
                var e = t[zn];
                this.data && this.data[zn] == e || !S || (this.data = new Float32Array(e));
                for (var i = 0; e > i; i++)this.data[i] = t[i];
                this._len = e
            },
            appendPath: function (t) {
                t instanceof Array || (t = [t]);
                for (var e = t[zn], i = 0, n = this._len, r = 0; e > r; r++)i += t[r].len();
                S && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
                for (var r = 0; e > r; r++)for (var a = t[r].data, o = 0; o < a[zn]; o++)this.data[n++] = a[o];
                this._len = n
            },
            addData: function (t) {
                var e = this.data;
                this._len + arguments[zn] > e[zn] && (this._expandData(), e = this.data);
                for (var i = 0; i < arguments[zn]; i++)e[this._len++] = arguments[i];
                this._prevCmd = t
            },
            _expandData: function () {
                if (!(this.data instanceof Array)) {
                    for (var t = [], e = 0; e < this._len; e++)t[e] = this.data[e];
                    this.data = t
                }
            },
            _needsDash: function () {
                return this._lineDash
            },
            _dashedLineTo: function (t, e) {
                var i, r, a = this._dashSum, o = this._dashOffset, s = this._lineDash, l = this._ctx, c = this._xi, u = this._yi, h = t - c, f = e - u, p = b(h * h + f * f), v = c, g = u, m = s[zn];
                for (h /= p, f /= p, 0 > o && (o = a + o), o %= a, v -= o * h, g -= o * f; h >= 0 && t >= v || 0 > h && v > t;)r = this._dashIdx, i = s[r], v += h * i, g += f * i, this._dashIdx = (r + 1) % m, h > 0 && c > v || 0 > h && v > c || l[r % 2 ? d : n](h >= 0 ? y(v, t) : x(v, t), f >= 0 ? y(g, e) : x(g, e));
                h = v - t, f = g - e, this._dashOffset = -b(h * h + f * f)
            },
            _dashedBezierTo: function (t, i, r, a, o, s) {
                var l, c, u, h, f, p = this._dashSum, v = this._dashOffset, g = this._lineDash, m = this._ctx, y = this._xi, x = this._yi, _ = e.cubicAt, w = 0, M = this._dashIdx, S = g[zn], A = 0;
                for (0 > v && (v = p + v), v %= p, l = 0; 1 > l; l += .1)c = _(y, t, r, o, l + .1) - _(y, t, r, o, l), u = _(x, i, a, s, l + .1) - _(x, i, a, s, l), w += b(c * c + u * u);
                for (; S > M && (A += g[M], !(A > v)); M++);
                for (l = (A - v) / w; 1 >= l;)h = _(y, t, r, o, l), f = _(x, i, a, s, l), M % 2 ? m[d](h, f) : m[n](h, f), l += g[M] / w, M = (M + 1) % S;
                M % 2 !== 0 && m[n](o, s), c = o - h, u = s - f, this._dashOffset = -b(c * c + u * u)
            },
            _dashedQuadraticTo: function (t, e, i, n) {
                var r = i, a = n;
                i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a)
            },
            toStatic: function () {
                var t = this.data;
                t instanceof Array && (t[zn] = this._len, S && (this.data = new Float32Array(t)))
            },
            getBoundingRect: function () {
                f[0] = f[1] = g[0] = g[1] = Number.MAX_VALUE, p[0] = p[1] = m[0] = m[1] = -Number.MAX_VALUE;
                for (var t = this.data, e = 0, i = 0, n = 0, r = 0, o = 0; o < t[zn];) {
                    var l = t[o++];
                    switch (1 == o && (e = t[o], i = t[o + 1], n = e, r = i), l) {
                        case h.M:
                            n = t[o++], r = t[o++], e = n, i = r, g[0] = n, g[1] = r, m[0] = n, m[1] = r;
                            break;
                        case h.L:
                            s.fromLine(e, i, t[o], t[o + 1], g, m), e = t[o++], i = t[o++];
                            break;
                        case h.C:
                            s.fromCubic(e, i, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], g, m), e = t[o++], i = t[o++];
                            break;
                        case h.Q:
                            s.fromQuadratic(e, i, t[o++], t[o++], t[o], t[o + 1], g, m), e = t[o++], i = t[o++];
                            break;
                        case h.A:
                            var u = t[o++], d = t[o++], v = t[o++], y = t[o++], x = t[o++], b = t[o++] + x, M = (t[o++], 1 - t[o++]);
                            1 == o && (n = _(x) * v + u, r = w(x) * y + d), s.fromArc(u, d, v, y, x, b, M, g, m), e = _(b) * v + u, i = w(b) * y + d;
                            break;
                        case h.R:
                            n = e = t[o++], r = i = t[o++];
                            var S = t[o++], A = t[o++];
                            s.fromLine(n, r, n + S, r + A, g, m);
                            break;
                        case h.Z:
                            e = n, i = r
                    }
                    a.min(f, f, g), a.max(p, p, m)
                }
                return 0 === o && (f[0] = f[1] = p[0] = p[1] = 0), new c(f[0], f[1], p[0] - f[0], p[1] - f[1])
            },
            rebuildPath: function (t) {
                for (var e, a, o, s, c, u, f = this.data, p = this._ux, v = this._uy, g = this._len, m = 0; g > m;) {
                    var y = f[m++];
                    switch (1 == m && (o = f[m], s = f[m + 1], e = o, a = s), y) {
                        case h.M:
                            e = o = f[m++], a = s = f[m++], t[d](o, s);
                            break;
                        case h.L:
                            c = f[m++], u = f[m++], (M(c - o) > p || M(u - s) > v || m === g - 1) && (t[n](c, u), o = c, s = u);
                            break;
                        case h.C:
                            t[r](f[m++], f[m++], f[m++], f[m++], f[m++], f[m++]), o = f[m - 2], s = f[m - 1];
                            break;
                        case h.Q:
                            t.quadraticCurveTo(f[m++], f[m++], f[m++], f[m++]), o = f[m - 2], s = f[m - 1];
                            break;
                        case h.A:
                            var x = f[m++], b = f[m++], S = f[m++], A = f[m++], C = f[m++], T = f[m++], L = f[m++], k = f[m++], D = S > A ? S : A, I = S > A ? 1 : S / A, P = S > A ? A / S : 1, z = Math.abs(S - A) > .001, V = C + T;
                            z ? (t.translate(x, b), t[l](L), t.scale(I, P), t.arc(0, 0, D, C, V, 1 - k), t.scale(1 / I, 1 / P), t[l](-L), t.translate(-x, -b)) : t.arc(x, b, D, C, V, 1 - k), 1 == m && (e = _(C) * S + x, a = w(C) * A + b), o = _(V) * S + x, s = w(V) * A + b;
                            break;
                        case h.R:
                            e = o = f[m], a = s = f[m + 1], t.rect(f[m++], f[m++], f[m++], f[m++]);
                            break;
                        case h.Z:
                            t[i](), o = e, s = a
                    }
                }
            }
        }, A.CMD = h, A
    }),e("zrender/contain/text", [gr, p, "../core/BoundingRect"], function (t) {
        function e(t, e) {
            var i = t + ":" + e;
            if (s[i])return s[i];
            for (var n = (t + "").split("\n"), r = 0, a = 0, o = n[zn]; o > a; a++)r = Math.max(d.measureText(n[a], e).width, r);
            return l > c && (l = 0, s = {}), l++, s[i] = r, r
        }

        function i(t, i, n, r) {
            var a = ((t || "") + "").split("\n")[zn], o = e(t, i), s = e("", i), l = a * s, c = new h(0, 0, o, l);
            switch (c.lineHeight = s, r) {
                case Hn:
                case"alphabetic":
                    c.y -= s;
                    break;
                case Xi:
                    c.y -= s / 2
            }
            switch (n) {
                case"end":
                case"right":
                    c.x -= c.width;
                    break;
                case ji:
                    c.x -= c.width / 2
            }
            return c
        }

        function n(t, e, i, n) {
            var r = e.x, a = e.y, o = e[Fn], s = e.width, l = i[Fn], c = o / 2 - l / 2, u = "left";
            switch (t) {
                case"left":
                    r -= n, a += c, u = "right";
                    break;
                case"right":
                    r += n + s, a += c, u = "left";
                    break;
                case"top":
                    r += s / 2, a -= n + l, u = ji;
                    break;
                case Hn:
                    r += s / 2, a += o + n, u = ji;
                    break;
                case si:
                    r += s / 2, a += c, u = ji;
                    break;
                case"insideLeft":
                    r += n, a += c, u = "left";
                    break;
                case"insideRight":
                    r += s - n, a += c, u = "right";
                    break;
                case"insideTop":
                    r += s / 2, a += n, u = ji;
                    break;
                case"insideBottom":
                    r += s / 2, a += o - l - n, u = ji;
                    break;
                case"insideTopLeft":
                    r += n, a += n, u = "left";
                    break;
                case"insideTopRight":
                    r += s - n, a += n, u = "right";
                    break;
                case"insideBottomLeft":
                    r += n, a += o - l - n;
                    break;
                case"insideBottomRight":
                    r += s - n, a += o - l - n, u = "right"
            }
            return {x: r, y: a, textAlign: u, textBaseline: "top"}
        }

        function r(t, i, n, r) {
            if (!n)return "";
            r = u[Vn]({
                ellipsis: "...",
                minCharacters: 3,
                maxIterations: 3,
                cnCharWidth: e("", i),
                ascCharWidth: e("a", i)
            }, r, !0), n -= e(r.ellipsis);
            for (var o = (t + "").split("\n"), s = 0, l = o[zn]; l > s; s++)o[s] = a(o[s], i, n, r);
            return o.join("\n")
        }

        function a(t, i, n, r) {
            for (var a = 0; ; a++) {
                var s = e(t, i);
                if (n > s || a >= r.maxIterations) {
                    t += r.ellipsis;
                    break
                }
                var l = 0 === a ? o(t, n, r) : Math.floor(t[zn] * n / s);
                if (l < r.minCharacters) {
                    t = "";
                    break
                }
                t = t.substr(0, l)
            }
            return t
        }

        function o(t, e, i) {
            for (var n = 0, r = 0, a = t[zn]; a > r && e > n; r++) {
                var o = t.charCodeAt(r);
                n += o >= 0 && 127 >= o ? i.ascCharWidth : i.cnCharWidth
            }
            return r
        }

        var s = {}, l = 0, c = 5e3, u = t(p), h = t("../core/BoundingRect"), d = {
            getWidth: e,
            getBoundingRect: i,
            adjustTextPositionOnRect: n,
            ellipsis: r,
            measureText: function (t, e) {
                var i = u[Zi]();
                return i.font = e, i.measureText(t)
            }
        };
        return d
    }),e("echarts/coord/axisHelper", [gr, "../scale/Ordinal", "../scale/Interval", "../scale/Time", "../scale/Log", "../scale/Scale", yi, vr, "zrender/contain/text"], function (t) {
        var e = t("../scale/Ordinal"), i = t("../scale/Interval");
        t("../scale/Time"), t("../scale/Log");
        var n = t("../scale/Scale"), r = t(yi), a = t(vr), o = t("zrender/contain/text"), s = {};
        return s.getScaleExtent = function (t, e) {
            var i = t.scale, n = i[we](), o = n[1] - n[0];
            if (i.type === se)return isFinite(o) ? n : [0, 0];
            var s = e.getMin ? e.getMin() : e.get("min"), l = e.getMax ? e.getMax() : e.get("max"), c = e.getNeedCrossZero ? e.getNeedCrossZero() : !e.get("scale"), u = e.get(ue);
            a[gn](u) || (u = [u || 0, u || 0]), u[0] = r[Ee](u[0], 1), u[1] = r[Ee](u[1], 1);
            var h = !0, d = !0;
            return null == s && (s = n[0] - u[0] * o, h = !1), null == l && (l = n[1] + u[1] * o, d = !1), "dataMin" === s && (s = n[0]), "dataMax" === l && (l = n[1]), c && (s > 0 && l > 0 && !h && (s = 0), 0 > s && 0 > l && !d && (l = 0)), [s, l]
        }, s.niceScaleExtent = function (t, e) {
            var i = t.scale, n = s.getScaleExtent(t, e), r = null != (e.getMin ? e.getMin() : e.get("min")), a = null != (e.getMax ? e.getMax() : e.get("max")), o = e.get(S);
            i[de](n[0], n[1]), i.niceExtent(o, r, a);
            var l = e.get("minInterval");
            if (isFinite(l) && !r && !a && i.type === Q) {
                var c = i.getInterval(), u = Math.max(Math.abs(c), l) / c;
                n = i[we](), i[de](u * n[0], n[1] * u), i.niceExtent(o)
            }
            var c = e.get(Q);
            null != c && i.setInterval && i.setInterval(c)
        }, s.createScaleByModel = function (t, r) {
            if (r = r || t.get("type"))switch (r) {
                case be:
                    return new e(t.getCategories(), [1 / 0, -1 / 0]);
                case"value":
                    return new i;
                default:
                    return (n.getClass(r) || i)[Zn](t)
            }
        }, s.ifAxisCrossZero = function (t) {
            var e = t.scale[we](), i = e[0], n = e[1];
            return !(i > 0 && n > 0 || 0 > i && 0 > n)
        }, s.getAxisLabelInterval = function (t, e, i, n) {
            var r, a = 0, s = 0, l = 1;
            e[zn] > 40 && (l = Math.round(e[zn] / 40));
            for (var c = 0; c < t[zn]; c += l) {
                var u = t[c], h = o[Qi](e[c], i, ji, "top");
                h[n ? "x" : "y"] += u, h[n ? "width" : Fn] *= 1.5, r ? r.intersect(h) ? (s++, a = Math.max(a, s)) : (r.union(h), s = 0) : r = h.clone()
            }
            return 0 === a && l > 1 ? l : a * l
        }, s[pe] = function (t, e) {
            var i = t.scale, n = i.getTicksLabels(), r = i[oe]();
            return typeof e === er ? (e = function (t) {
                return function (e) {
                    return t[mn]("{value}", e)
                }
            }(e), a.map(n, e)) : typeof e === fn ? a.map(r, function (n, r) {
                return e(t.type === be ? i[ae](n) : n, r)
            }, this) : n
        }, s
    }),e("zrender/vml/core", [gr, "exports", "module", "../core/env"], function (t, e, i) {
        if (!t("../core/env")[Xn]) {
            var n, r = "urn:schemas-microsoft-com:vml", a = window, o = a.document, s = !1;
            try {
                !o.namespaces.zrvml && o.namespaces.add("zrvml", r), n = function (t) {
                    return o[Fi]("<zrvml:" + t + ' class="zrvml">')
                }
            } catch (l) {
                n = function (t) {
                    return o[Fi]("<" + t + ' xmlns="' + r + '" class="zrvml">')
                }
            }
            var c = function () {
                if (!s) {
                    s = !0;
                    var t = o.styleSheets;
                    t[zn] < 31 ? o.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
                }
            };
            i.exports = {doc: o, initVML: c, createNode: n}
        }
    }),e("echarts/coord/cartesian/Cartesian2D", [gr, vr, "./Cartesian"], function (t) {
        function e(t) {
            n.call(this, t)
        }

        var i = t(vr), n = t("./Cartesian");
        return e[ir] = {
            constructor: e, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function () {
                return this.getAxesByScale(se)[0] || this.getAxesByScale("time")[0] || this[he]("x")
            }, containPoint: function (t) {
                var e = this[he]("x"), i = this[he]("y");
                return e[mi](e.toLocalCoord(t[0])) && i[mi](i.toLocalCoord(t[1]))
            }, containData: function (t) {
                return this[he]("x").containData(t[0]) && this[he]("y").containData(t[1])
            }, dataToPoints: function (t, e) {
                return t[K](["x", "y"], function (t, e) {
                    return this[Se]([t, e])
                }, e, this)
            }, dataToPoint: function (t, e) {
                var i = this[he]("x"), n = this[he]("y");
                return [i.toGlobalCoord(i[te](t[0], e)), n.toGlobalCoord(n[te](t[1], e))]
            }, pointToData: function (t, e) {
                var i = this[he]("x"), n = this[he]("y");
                return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)]
            }, getOtherAxis: function (t) {
                return this[he]("x" === t.dim ? "y" : "x")
            }
        }, i[on](e, n), e
    }),e("echarts/coord/cartesian/Axis2D", [gr, vr, "../Axis", "./axisLabelInterval"], function (t) {
        var e = t(vr), i = t("../Axis"), n = t("./axisLabelInterval"), r = function (t, e, n, r, a) {
            i.call(this, t, e, n), this.type = r || "value", this[Ui] = a || Hn
        };
        return r[ir] = {
            constructor: r, index: 0, onZero: !1, model: null, isHorizontal: function () {
                var t = this[Ui];
                return "top" === t || t === Hn
            }, getGlobalExtent: function () {
                var t = this[we]();
                return t[0] = this.toGlobalCoord(t[0]), t[1] = this.toGlobalCoord(t[1]), t
            }, getLabelInterval: function () {
                var t = this._labelInterval;
                return t || (t = this._labelInterval = n(this)), t
            }, isLabelIgnored: function (t) {
                if (this.type === be) {
                    var e = this.getLabelInterval();
                    return typeof e === fn && !e(t, this.scale[ae](t)) || t % (e + 1)
                }
            }, toLocalCoord: null, toGlobalCoord: null
        }, e[on](r, i), r
    }),e("echarts/coord/cartesian/GridModel", [gr, "./AxisModel", c], function (t) {
        t("./AxisModel");
        var e = t(c);
        return e[On]({
            type: "grid",
            dependencies: ["xAxis", "yAxis"],
            layoutMode: "box",
            coordinateSystem: null,
            defaultOption: {
                show: !1,
                zlevel: 0,
                z: 0,
                left: "10%",
                top: 60,
                right: "10%",
                bottom: 60,
                containLabel: !1,
                backgroundColor: "rgba(0,0,0,0)",
                borderWidth: 1,
                borderColor: "#ccc"
            }
        })
    }),e("echarts/component/visualMap/visualMapAction", [gr, Ri], function (t) {
        var e = t(Ri), i = {type: "selectDataRange", event: "dataRangeSelected", update: "update"};
        e[pn](i, function (t, e) {
            e[qn]({mainType: "visualMap", query: t}, function (e) {
                e.setSelected(t[Qe])
            })
        })
    }),e("echarts/model/mixin/lineStyle", [gr, "./makeStyleMapper"], function (t) {
        var e = t("./makeStyleMapper")([[m, "width"], [Ne, "color"], [Hi], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
        return {
            getLineStyle: function (t) {
                var i = e.call(this, t), n = this.getLineDash();
                return n && (i.lineDash = n), i
            }, getLineDash: function () {
                var t = this.get("type");
                return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
            }
        }
    }),e("echarts/model/mixin/areaStyle", [gr, "./makeStyleMapper"], function (t) {
        return {getAreaStyle: t("./makeStyleMapper")([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], [Hi], ["shadowColor"]])}
    }),e("echarts/model/mixin/boxLayout", [gr], function () {
        return {
            getBoxLayoutParams: function () {
                return {
                    left: this.get("left"),
                    top: this.get("top"),
                    right: this.get("right"),
                    bottom: this.get(Hn),
                    width: this.get("width"),
                    height: this.get(Fn)
                }
            }
        }
    }),e("echarts/model/mixin/textStyle", [gr, "zrender/contain/text"], function (t) {
        function e(t, e) {
            return t && t[N](e)
        }

        var i = t("zrender/contain/text");
        return {
            getTextColor: function () {
                var t = this[j];
                return this[N]("color") || t && t.get("textStyle.color")
            }, getFont: function () {
                var t = this[j], i = t && t[Jn](nn);
                return [this[N]("fontStyle") || e(i, "fontStyle"), this[N]("fontWeight") || e(i, "fontWeight"), (this[N]("fontSize") || e(i, "fontSize") || 12) + "px", this[N]("fontFamily") || e(i, "fontFamily") || "sans-serif"].join(" ")
            }, getTextRect: function (t) {
                var e = this.get(nn) || {};
                return i[Qi](t, this[tn](), e.align, e.baseline)
            }, ellipsis: function (t, e, n) {
                return i.ellipsis(t, this[tn](), e, n)
            }
        }
    }),e("echarts/model/mixin/itemStyle", [gr, "./makeStyleMapper"], function (t) {
        return {getItemStyle: t("./makeStyleMapper")([["fill", "color"], [Ne, Ge], [m, "borderWidth"], [Hi], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]])}
    }),e("echarts/data/DataDiffer", [gr], function () {
        function t(t) {
            return t
        }

        function e(e, i, n, r) {
            this._old = e, this._new = i, this._oldKeyGetter = n || t, this._newKeyGetter = r || t
        }

        function i(t, e, i) {
            for (var n = 0; n < t[zn]; n++) {
                var r = i(t[n]), a = e[r];
                null == a ? e[r] = n : (a[zn] || (e[r] = a = [a]), a.push(n))
            }
        }

        return e[ir] = {
            constructor: e, add: function (t) {
                return this._add = t, this
            }, update: function (t) {
                return this._update = t, this
            }, remove: function (t) {
                return this._remove = t, this
            }, execute: function () {
                var t, e = this._old, n = this._new, r = this._oldKeyGetter, a = this._newKeyGetter, o = {}, s = {};
                for (i(e, o, r), i(n, s, a), t = 0; t < e[zn]; t++) {
                    var l = r(e[t]), c = s[l];
                    if (null != c) {
                        var u = c[zn];
                        u ? (1 === u && (s[l] = null), c = c.unshift()) : s[l] = null, this._update && this._update(c, t)
                    } else this._remove && this._remove(t)
                }
                for (var l in s)if (s.hasOwnProperty(l)) {
                    var c = s[l];
                    if (null == c)continue;
                    if (c[zn])for (var t = 0, u = c[zn]; u > t; t++)this._add && this._add(c[t]); else this._add && this._add(c)
                }
            }
        }, e
    }),e("zrender/tool/transformPath", [gr, "../core/PathProxy", "../core/vector"], function (t) {
        function e(t, e) {
            var n, l, c, u, h, d, f = t.data, p = i.M, v = i.C, g = i.L, m = i.R, y = i.A, x = i.Q;
            for (c = 0, u = 0; c < f[zn];) {
                switch (n = f[c++], u = c, l = 0, n) {
                    case p:
                        l = 1;
                        break;
                    case g:
                        l = 1;
                        break;
                    case v:
                        l = 3;
                        break;
                    case x:
                        l = 2;
                        break;
                    case y:
                        var _ = e[4], w = e[5], b = o(e[0] * e[0] + e[1] * e[1]), M = o(e[2] * e[2] + e[3] * e[3]), S = s(-e[1] / M, e[0] / b);
                        f[c++] += _, f[c++] += w, f[c++] *= b, f[c++] *= M, f[c++] += S, f[c++] += S, c += 2, u = c;
                        break;
                    case m:
                        d[0] = f[c++], d[1] = f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1], d[0] += f[c++], d[1] += f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1]
                }
                for (h = 0; l > h; h++) {
                    var d = a[h];
                    d[0] = f[c++], d[1] = f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1]
                }
            }
        }

        var i = t("../core/PathProxy").CMD, n = t("../core/vector"), r = n[J], a = [[], [], []], o = Math.sqrt, s = Math.atan2;
        return e
    }),e("zrender/graphic/mixin/RectText", [gr, "../../contain/text", "../../core/BoundingRect"], function (t) {
        function e(t, e) {
            return typeof t === er ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
        }

        function i(t, e) {
            t[rr](e[0], e[1], e[2], e[3], e[4], e[5])
        }

        var n = t("../../contain/text"), r = t("../../core/BoundingRect"), a = new r, o = function () {
        };
        return o[ir] = {
            constructor: o, drawRectText: function (t, r, o) {
                var s = this.style, l = s.text;
                if (null != l && (l += ""), l) {
                    var c, u, h = s.textPosition, d = s.textDistance, f = s[en], p = s.textFont || s.font, v = s.textBaseline, g = s.textVerticalAlign;
                    o = o || n[Qi](l, p, f, v);
                    var m = this[rr], y = this.invTransform;
                    if (m && (a.copy(r), a[J](m), r = a, i(t, y)), h instanceof Array) {
                        if (c = r.x + e(h[0], r.width), u = r.y + e(h[1], r[Fn]), f = f || "left", v = v || "top", g) {
                            switch (g) {
                                case Xi:
                                    u -= o[Fn] / 2 - o.lineHeight / 2;
                                    break;
                                case Hn:
                                    u -= o[Fn] - o.lineHeight / 2;
                                    break;
                                default:
                                    u += o.lineHeight / 2
                            }
                            v = Xi
                        }
                    } else {
                        var x = n.adjustTextPositionOnRect(h, r, o, d);
                        c = x.x, u = x.y, f = f || x[en], v = v || x.textBaseline
                    }
                    t[en] = f, t.textBaseline = v;
                    var _ = s.textFill, w = s.textStroke;
                    _ && (t.fillStyle = _), w && (t.strokeStyle = w), t.font = p, t.shadowColor = s.textShadowColor, t.shadowBlur = s.textShadowBlur, t.shadowOffsetX = s.textShadowOffsetX, t.shadowOffsetY = s.textShadowOffsetY;
                    for (var b = l.split("\n"), M = 0; M < b[zn]; M++)_ && t.fillText(b[M], c, u), w && t.strokeText(b[M], c, u), u += o.lineHeight;
                    m && i(t, m)
                }
            }
        }, o
    }),e("zrender/graphic/Displayable", [gr, p, "./Style", "../Element", "./mixin/RectText"], function (t) {
        function e(t) {
            t = t || {}, r.call(this, t);
            for (var e in t)t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
            this.style = new n(t.style), this._rect = null, this.__clipPaths = []
        }

        var i = t(p), n = t("./Style"), r = t("../Element"), a = t("./mixin/RectText");
        return e[ir] = {
            constructor: e,
            type: "displayable",
            __dirty: !0,
            invisible: !1,
            z: 0,
            z2: 0,
            zlevel: 0,
            draggable: !1,
            dragging: !1,
            silent: !1,
            culling: !1,
            cursor: "pointer",
            rectHover: !1,
            beforeBrush: function () {
            },
            afterBrush: function () {
            },
            brush: function () {
            },
            getBoundingRect: function () {
            },
            contain: function (t, e) {
                return this.rectContain(t, e)
            },
            traverse: function (t, e) {
                t.call(e, this)
            },
            rectContain: function (t, e) {
                var i = this.transformCoordToLocal(t, e), n = this[Qi]();
                return n[mi](i[0], i[1])
            },
            dirty: function () {
                this[s] = !0, this._rect = null, this.__zr && this.__zr.refresh()
            },
            animateStyle: function (t) {
                return this[hi]("style", t)
            },
            attrKV: function (t, e) {
                "style" !== t ? r[ir].attrKV.call(this, t, e) : this.style.set(e)
            },
            setStyle: function (t, e) {
                return this.style.set(t, e), this.dirty(!1), this
            },
            useStyle: function (t) {
                return this.style = new n(t), this.dirty(!1), this
            }
        }, i[on](e, r), i.mixin(e, a), e
    }),e("echarts/coord/polar/AngleAxis", [gr, vr, "../Axis"], function (t) {
        function e(t, e) {
            e = e || [0, 360], n.call(this, "angle", t, e), this.type = be
        }

        var i = t(vr), n = t("../Axis");
        return e[ir] = {constructor: e, dataToAngle: n[ir][te], angleToData: n[ir].coordToData}, i[on](e, n), e
    }),e("zrender/core/curve", [gr, "./vector"], function (t) {
        function e(t) {
            return t > -_ && _ > t
        }

        function i(t) {
            return t > _ || -_ > t
        }

        function n(t, e, i, n, r) {
            var a = 1 - r;
            return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i)
        }

        function r(t, e, i, n, r) {
            var a = 1 - r;
            return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r)
        }

        function a(t, i, n, r, a, o) {
            var s = r + 3 * (i - n) - t, l = 3 * (n - 2 * i + t), c = 3 * (i - t), u = t - a, h = l * l - 3 * s * c, d = l * c - 9 * s * u, f = c * c - 3 * l * u, p = 0;
            if (e(h) && e(d))if (e(l))o[0] = 0; else {
                var v = -c / l;
                v >= 0 && 1 >= v && (o[p++] = v)
            } else {
                var g = d * d - 4 * h * f;
                if (e(g)) {
                    var m = d / h, v = -l / s + m, _ = -m / 2;
                    v >= 0 && 1 >= v && (o[p++] = v), _ >= 0 && 1 >= _ && (o[p++] = _)
                } else if (g > 0) {
                    var w = x(g), S = h * l + 1.5 * s * (-d + w), A = h * l + 1.5 * s * (-d - w);
                    S = 0 > S ? -y(-S, M) : y(S, M), A = 0 > A ? -y(-A, M) : y(A, M);
                    var v = (-l - (S + A)) / (3 * s);
                    v >= 0 && 1 >= v && (o[p++] = v)
                } else {
                    var C = (2 * h * l - 3 * s * d) / (2 * x(h * h * h)), T = Math.acos(C) / 3, L = x(h), k = Math.cos(T), v = (-l - 2 * L * k) / (3 * s), _ = (-l + L * (k + b * Math.sin(T))) / (3 * s), D = (-l + L * (k - b * Math.sin(T))) / (3 * s);
                    v >= 0 && 1 >= v && (o[p++] = v), _ >= 0 && 1 >= _ && (o[p++] = _), D >= 0 && 1 >= D && (o[p++] = D)
                }
            }
            return p
        }

        function o(t, n, r, a, o) {
            var s = 6 * r - 12 * n + 6 * t, l = 9 * n + 3 * a - 3 * t - 9 * r, c = 3 * n - 3 * t, u = 0;
            if (e(l)) {
                if (i(s)) {
                    var h = -c / s;
                    h >= 0 && 1 >= h && (o[u++] = h)
                }
            } else {
                var d = s * s - 4 * l * c;
                if (e(d))o[0] = -s / (2 * l); else if (d > 0) {
                    var f = x(d), h = (-s + f) / (2 * l), p = (-s - f) / (2 * l);
                    h >= 0 && 1 >= h && (o[u++] = h), p >= 0 && 1 >= p && (o[u++] = p)
                }
            }
            return u
        }

        function s(t, e, i, n, r, a) {
            var o = (e - t) * r + t, s = (i - e) * r + e, l = (n - i) * r + i, c = (s - o) * r + o, u = (l - s) * r + s, h = (u - c) * r + c;
            a[0] = t, a[1] = o, a[2] = c, a[3] = h, a[4] = h, a[5] = u, a[6] = l, a[7] = n
        }

        function l(t, e, i, r, a, o, s, l, c, u, h) {
            var d, f, p, v, g, y = .005, _ = 1 / 0;
            S[0] = c, S[1] = u;
            for (var b = 0; 1 > b; b += .05)A[0] = n(t, i, a, s, b), A[1] = n(e, r, o, l, b), v = m(S, A), _ > v && (d = b, _ = v);
            _ = 1 / 0;
            for (var M = 0; 32 > M && !(w > y); M++)f = d - y, p = d + y, A[0] = n(t, i, a, s, f), A[1] = n(e, r, o, l, f), v = m(A, S), f >= 0 && _ > v ? (d = f, _ = v) : (C[0] = n(t, i, a, s, p), C[1] = n(e, r, o, l, p), g = m(C, S), 1 >= p && _ > g ? (d = p, _ = g) : y *= .5);
            return h && (h[0] = n(t, i, a, s, d), h[1] = n(e, r, o, l, d)), x(_)
        }

        function c(t, e, i, n) {
            var r = 1 - n;
            return r * (r * t + 2 * n * e) + n * n * i
        }

        function u(t, e, i, n) {
            return 2 * ((1 - n) * (e - t) + n * (i - e))
        }

        function h(t, n, r, a, o) {
            var s = t - 2 * n + r, l = 2 * (n - t), c = t - a, u = 0;
            if (e(s)) {
                if (i(l)) {
                    var h = -c / l;
                    h >= 0 && 1 >= h && (o[u++] = h)
                }
            } else {
                var d = l * l - 4 * s * c;
                if (e(d)) {
                    var h = -l / (2 * s);
                    h >= 0 && 1 >= h && (o[u++] = h)
                } else if (d > 0) {
                    var f = x(d), h = (-l + f) / (2 * s), p = (-l - f) / (2 * s);
                    h >= 0 && 1 >= h && (o[u++] = h), p >= 0 && 1 >= p && (o[u++] = p)
                }
            }
            return u
        }

        function d(t, e, i) {
            var n = t + i - 2 * e;
            return 0 === n ? .5 : (t - e) / n
        }

        function f(t, e, i, n, r) {
            var a = (e - t) * n + t, o = (i - e) * n + e, s = (o - a) * n + a;
            r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i
        }

        function p(t, e, i, n, r, a, o, s, l) {
            var u, h = .005, d = 1 / 0;
            S[0] = o, S[1] = s;
            for (var f = 0; 1 > f; f += .05) {
                A[0] = c(t, i, r, f), A[1] = c(e, n, a, f);
                var p = m(S, A);
                d > p && (u = f, d = p)
            }
            d = 1 / 0;
            for (var v = 0; 32 > v && !(w > h); v++) {
                var g = u - h, y = u + h;
                A[0] = c(t, i, r, g), A[1] = c(e, n, a, g);
                var p = m(A, S);
                if (g >= 0 && d > p)u = g, d = p; else {
                    C[0] = c(t, i, r, y), C[1] = c(e, n, a, y);
                    var _ = m(C, S);
                    1 >= y && d > _ ? (u = y, d = _) : h *= .5
                }
            }
            return l && (l[0] = c(t, i, r, u), l[1] = c(e, n, a, u)), x(d)
        }

        var v = t("./vector"), g = v[Zn], m = v.distSquare, y = Math.pow, x = Math.sqrt, _ = 1e-8, w = 1e-4, b = x(3), M = 1 / 3, S = g(), A = g(), C = g();
        return {
            cubicAt: n,
            cubicDerivativeAt: r,
            cubicRootAt: a,
            cubicExtrema: o,
            cubicSubdivide: s,
            cubicProjectPoint: l,
            quadraticAt: c,
            quadraticDerivativeAt: u,
            quadraticRootAt: h,
            quadraticExtremum: d,
            quadraticSubdivide: f,
            quadraticProjectPoint: p
        }
    }),e("zrender/core/bbox", [gr, "./vector", "./curve"], function (t) {
        var e = t("./vector"), i = t("./curve"), n = {}, r = Math.min, a = Math.max, o = Math.sin, s = Math.cos, l = e[Zn](), c = e[Zn](), u = e[Zn](), h = 2 * Math.PI;
        n.fromPoints = function (t, e, i) {
            if (0 !== t[zn]) {
                var n, o = t[0], s = o[0], l = o[0], c = o[1], u = o[1];
                for (n = 1; n < t[zn]; n++)o = t[n], s = r(s, o[0]), l = a(l, o[0]), c = r(c, o[1]), u = a(u, o[1]);
                e[0] = s, e[1] = c, i[0] = l, i[1] = u
            }
        }, n.fromLine = function (t, e, i, n, o, s) {
            o[0] = r(t, i), o[1] = r(e, n), s[0] = a(t, i), s[1] = a(e, n)
        };
        var d = [], f = [];
        return n.fromCubic = function (t, e, n, o, s, l, c, u, h, p) {
            var v, g = i.cubicExtrema, m = i.cubicAt, y = g(t, n, s, c, d);
            for (h[0] = 1 / 0, h[1] = 1 / 0, p[0] = -1 / 0, p[1] = -1 / 0, v = 0; y > v; v++) {
                var x = m(t, n, s, c, d[v]);
                h[0] = r(x, h[0]), p[0] = a(x, p[0])
            }
            for (y = g(e, o, l, u, f), v = 0; y > v; v++) {
                var _ = m(e, o, l, u, f[v]);
                h[1] = r(_, h[1]), p[1] = a(_, p[1])
            }
            h[0] = r(t, h[0]), p[0] = a(t, p[0]), h[0] = r(c, h[0]), p[0] = a(c, p[0]), h[1] = r(e, h[1]), p[1] = a(e, p[1]), h[1] = r(u, h[1]), p[1] = a(u, p[1])
        }, n.fromQuadratic = function (t, e, n, o, s, l, c, u) {
            var h = i.quadraticExtremum, d = i.quadraticAt, f = a(r(h(t, n, s), 1), 0), p = a(r(h(e, o, l), 1), 0), v = d(t, n, s, f), g = d(e, o, l, p);
            c[0] = r(t, s, v), c[1] = r(e, l, g), u[0] = a(t, s, v), u[1] = a(e, l, g)
        }, n.fromArc = function (t, i, n, r, a, d, f, p, v) {
            var g = e.min, m = e.max, y = Math.abs(a - d);
            if (1e-4 > y % h && y > 1e-4)return p[0] = t - n, p[1] = i - r, v[0] = t + n, void(v[1] = i + r);
            if (l[0] = s(a) * n + t, l[1] = o(a) * r + i, c[0] = s(d) * n + t, c[1] = o(d) * r + i, g(p, l, c), m(v, l, c), a %= h, 0 > a && (a += h), d %= h, 0 > d && (d += h), a > d && !f ? d += h : d > a && f && (a += h), f) {
                var x = d;
                d = a, a = x
            }
            for (var _ = 0; d > _; _ += Math.PI / 2)_ > a && (u[0] = s(_) * n + t, u[1] = o(_) * r + i, g(p, u, p), m(v, u, v))
        }, n
    }),e("echarts/component/helper/selectableMixin", [gr, vr], function (t) {
        var e = t(vr);
        return {
            updateSelectedMap: function (t) {
                this._selectTargetMap = e.reduce(t || [], function (t, e) {
                    return t[e.name] = e, t
                }, {})
            }, select: function (t) {
                var i = this._selectTargetMap, n = i[t], r = this.get("selectedMode");
                "single" === r && e.each(i, function (t) {
                    t[Qe] = !1
                }), n && (n[Qe] = !0)
            }, unSelect: function (t) {
                var e = this._selectTargetMap[t];
                e && (e[Qe] = !1)
            }, toggleSelected: function (t) {
                var e = this._selectTargetMap[t];
                return null != e ? (this[e[Qe] ? "unSelect" : "select"](t), e[Qe]) : void 0
            }, isSelected: function (t) {
                var e = this._selectTargetMap[t];
                return e && e[Qe]
            }
        }
    }),e("echarts/model/mixin/makeStyleMapper", [gr, vr], function (t) {
        var e = t(vr);
        return function (t) {
            for (var i = 0; i < t[zn]; i++)t[i][1] || (t[i][1] = t[i][0]);
            return function (i) {
                for (var n = {}, r = 0; r < t[zn]; r++) {
                    var a = t[r][1];
                    if (!(i && e[vn](i, a) >= 0)) {
                        var o = this[N](a);
                        null != o && (n[t[r][0]] = o)
                    }
                }
                return n
            }
        }
    }),e("zrender/graphic/Style", [gr], function () {
        var t = ["lineCap", "lineJoin", "miterLimit", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowColor"], e = function (t) {
            this.extendFrom(t)
        };
        e[ir] = {
            constructor: e,
            fill: "#000000",
            stroke: null,
            opacity: 1,
            lineDash: null,
            lineDashOffset: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            lineWidth: 1,
            strokeNoScale: !1,
            text: null,
            textFill: "#000",
            textStroke: null,
            textPosition: "inside",
            textBaseline: null,
            textAlign: null,
            textVerticalAlign: null,
            textDistance: 5,
            textShadowBlur: 0,
            textShadowOffsetX: 0,
            textShadowOffsetY: 0,
            bind: function (e, i) {
                for (var n = this.fill, r = this[Ne], a = 0; a < t[zn]; a++) {
                    var o = t[a];
                    null != this[o] && (e[o] = this[o])
                }
                if (null != r) {
                    var s = this[m];
                    e[m] = s / (this.strokeNoScale && i && i.getLineScale ? i.getLineScale() : 1)
                }
                null == n || "none" === n || n.colorStops || (e.fillStyle = n), null == r || "none" === r || r.colorStops || (e.strokeStyle = r), null != this[Hi] && (e.globalAlpha = this[Hi])
            },
            extendFrom: function (t, e) {
                if (t) {
                    var i = this;
                    for (var n in t)!t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n])
                }
            },
            set: function (t, e) {
                typeof t === er ? this[t] = e : this.extendFrom(t, !0)
            },
            clone: function () {
                var t = new this.constructor;
                return t.extendFrom(this, !0), t
            },
            createLinearGradient: function (t, e, i) {
                var n = e.x * i.width + i.x, r = e.x2 * i.width + i.x, a = e.y * i[Fn] + i.y, o = e.y2 * i[Fn] + i.y, s = t.createLinearGradient(n, a, r, o);
                return s
            },
            createRadialGradient: function (t, e, i) {
                var n = i.width, r = i[Fn], a = Math.min(n, r), o = e.x * n + i.x, s = e.y * r + i.y, l = e.r * a, c = t.createRadialGradient(o, s, 0, o, s, l);
                return c
            },
            getGradient: function (t, e, i) {
                for (var n = "radial" === e.type ? "createRadialGradient" : "createLinearGradient", r = this[n](t, e, i), a = e.colorStops, o = 0; o < a[zn]; o++)r.addColorStop(a[o].offset, a[o].color);
                return r
            }
        };
        var i, n, r = e[ir];
        for (n = 0; n < t[zn]; n++)i = t[n], i in r || (r[i] = null);
        return e
    }),e("zrender/contain/path", [gr, "../core/PathProxy", "./line", "./cubic", "./quadratic", "./arc", "./util", "../core/curve", "./windingLine"], function (t) {
        function e(t, e) {
            return Math.abs(t - e) < m
        }

        function i() {
            var t = x[0];
            x[0] = x[1], x[1] = t
        }

        function n(t, e, n, r, a, o, s, l, c, u) {
            if (u > e && u > r && u > o && u > l || e > u && r > u && o > u && l > u)return 0;
            var h = f.cubicRootAt(e, r, o, l, u, y);
            if (0 === h)return 0;
            for (var d, p, v = 0, g = -1, m = 0; h > m; m++) {
                var _ = y[m], w = f.cubicAt(t, n, a, s, _);
                c > w || (0 > g && (g = f.cubicExtrema(e, r, o, l, x), x[1] < x[0] && g > 1 && i(), d = f.cubicAt(e, r, o, l, x[0]), g > 1 && (p = f.cubicAt(e, r, o, l, x[1]))), v += 2 == g ? _ < x[0] ? e > d ? 1 : -1 : _ < x[1] ? d > p ? 1 : -1 : p > l ? 1 : -1 : _ < x[0] ? e > d ? 1 : -1 : d > l ? 1 : -1)
            }
            return v
        }

        function r(t, e, i, n, r, a, o, s) {
            if (s > e && s > n && s > a || e > s && n > s && a > s)return 0;
            var l = f.quadraticRootAt(e, n, a, s, y);
            if (0 === l)return 0;
            var c = f.quadraticExtremum(e, n, a);
            if (c >= 0 && 1 >= c) {
                for (var u = 0, h = f.quadraticAt(e, n, a, c), d = 0; l > d; d++) {
                    var p = f.quadraticAt(t, i, r, y[d]);
                    o > p || (u += y[d] < c ? e > h ? 1 : -1 : h > a ? 1 : -1)
                }
                return u
            }
            var p = f.quadraticAt(t, i, r, y[0]);
            return o > p ? 0 : e > a ? 1 : -1
        }

        function a(t, e, i, n, r, a, o, s) {
            if (s -= e, s > i || -i > s)return 0;
            var l = Math.sqrt(i * i - s * s);
            y[0] = -l, y[1] = l;
            var c = Math.abs(n - r);
            if (1e-4 > c)return 0;
            if (1e-4 > c % g) {
                n = 0, r = g;
                var u = a ? 1 : -1;
                return o >= y[0] + t && o <= y[1] + t ? u : 0
            }
            if (a) {
                var l = n;
                n = d(r), r = d(l)
            } else n = d(n), r = d(r);
            n > r && (r += g);
            for (var h = 0, f = 0; 2 > f; f++) {
                var p = y[f];
                if (p + t > o) {
                    var v = Math.atan2(s, p), u = a ? 1 : -1;
                    0 > v && (v = g + v), (v >= n && r >= v || v + g >= n && r >= v + g) && (v > Math.PI / 2 && v < 1.5 * Math.PI && (u = -u), h += u)
                }
            }
            return h
        }

        function o(t, i, o, l, d) {
            for (var f = 0, g = 0, m = 0, y = 0, x = 0, _ = 0; _ < t[zn];) {
                var w = t[_++];
                if (w === s.M && _ > 1 && (o || (f += p(g, m, y, x, l, d)), 0 !== f))return !0;
                switch (1 == _ && (g = t[_], m = t[_ + 1], y = g, x = m), w) {
                    case s.M:
                        y = t[_++], x = t[_++], g = y, m = x;
                        break;
                    case s.L:
                        if (o) {
                            if (v(g, m, t[_], t[_ + 1], i, l, d))return !0
                        } else f += p(g, m, t[_], t[_ + 1], l, d) || 0;
                        g = t[_++], m = t[_++];
                        break;
                    case s.C:
                        if (o) {
                            if (c.containStroke(g, m, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], i, l, d))return !0
                        } else f += n(g, m, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
                        g = t[_++], m = t[_++];
                        break;
                    case s.Q:
                        if (o) {
                            if (u.containStroke(g, m, t[_++], t[_++], t[_], t[_ + 1], i, l, d))return !0
                        } else f += r(g, m, t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
                        g = t[_++], m = t[_++];
                        break;
                    case s.A:
                        var b = t[_++], M = t[_++], S = t[_++], A = t[_++], C = t[_++], T = t[_++], L = (t[_++], 1 - t[_++]), k = Math.cos(C) * S + b, D = Math.sin(C) * A + M;
                        _ > 1 ? f += p(g, m, k, D, l, d) : (y = k, x = D);
                        var I = (l - b) * A / S + b;
                        if (o) {
                            if (h.containStroke(b, M, A, C, C + T, L, i, I, d))return !0
                        } else f += a(b, M, A, C, C + T, L, I, d);
                        g = Math.cos(C + T) * S + b, m = Math.sin(C + T) * A + M;
                        break;
                    case s.R:
                        y = g = t[_++], x = m = t[_++];
                        var P = t[_++], z = t[_++], k = y + P, D = x + z;
                        if (o) {
                            if (v(y, x, k, x, i, l, d) || v(k, x, k, D, i, l, d) || v(k, D, y, D, i, l, d) || v(y, D, k, D, i, l, d))return !0
                        } else f += p(k, x, k, D, l, d), f += p(y, D, y, x, l, d);
                        break;
                    case s.Z:
                        if (o) {
                            if (v(g, m, y, x, i, l, d))return !0
                        } else if (f += p(g, m, y, x, l, d), 0 !== f)return !0;
                        g = y, m = x
                }
            }
            return o || e(m, x) || (f += p(g, m, y, x, l, d) || 0), 0 !== f
        }

        var s = t("../core/PathProxy").CMD, l = t("./line"), c = t("./cubic"), u = t("./quadratic"), h = t("./arc"), d = t("./util").normalizeRadian, f = t("../core/curve"), p = t("./windingLine"), v = l.containStroke, g = 2 * Math.PI, m = 1e-4, y = [-1, -1, -1], x = [-1, -1];
        return {
            contain: function (t, e, i) {
                return o(t, 0, !1, e, i)
            }, containStroke: function (t, e, i, n) {
                return o(t, e, !0, i, n)
            }
        }
    }),e("echarts/coord/polar/RadiusAxis", [gr, vr, "../Axis"], function (t) {
        function e(t, e) {
            n.call(this, Oe, t, e), this.type = be
        }

        var i = t(vr), n = t("../Axis");
        return e[ir] = {constructor: e, dataToRadius: n[ir][te], radiusToData: n[ir].coordToData}, i[on](e, n), e
    }),e("echarts/chart/helper/LineDraw", [gr, vi, "./Line"], function (t) {
        function e(t) {
            return isNaN(t[0]) || isNaN(t[1])
        }

        function i(t) {
            return !e(t[0]) && !e(t[1])
        }

        function n(t) {
            this._ctor = t || a, this.group = new r.Group
        }

        var r = t(vi), a = t("./Line"), o = n[ir];
        return o[li] = function (t) {
            var e = this._lineData, n = this.group, r = this._ctor;
            t.diff(e).add(function (e) {
                if (i(t[fi](e))) {
                    var a = new r(t, e);
                    t[He](e, a), n.add(a)
                }
            })[Gn](function (a, o) {
                var s = e[pi](o);
                return i(t[fi](a)) ? (s ? s[li](t, a) : s = new r(t, a), t[He](a, s), void n.add(s)) : void n[En](s)
            })[En](function (t) {
                n[En](e[pi](t))
            })[qe](), this._lineData = t
        }, o[Nn] = function () {
            var t = this._lineData;
            t[ne](function (e, i) {
                e[Nn](t, i)
            }, this)
        }, o[En] = function () {
            this.group[rn]()
        }, n
    }),e("echarts/chart/helper/EffectLine", [gr, vi, "./Line", vr, E, "zrender/core/curve"], function (t) {
        function e(t, e) {
            r.Group.call(this);
            var i = new a(t, e);
            this.add(i), this._updateEffectSymbol(t, e)
        }

        function i(t, e) {
            t.__p1 = e[0], t.__p2 = e[1], t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]
        }

        function n() {
            var t = this.__p1, e = this.__p2, i = this.__cp1, n = this.__t, r = this[Ui], a = l.quadraticAt, o = l.quadraticDerivativeAt;
            r[0] = a(t[0], i[0], e[0], n), r[1] = a(t[1], i[1], e[1], n);
            var s = o(t[0], i[0], e[0], n), c = o(t[1], i[1], e[1], n);
            this[Ye] = -Math.atan2(c, s) - Math.PI / 2, this[Wn] = !1
        }

        var r = t(vi), a = t("./Line"), o = t(vr), s = t(E), l = t("zrender/core/curve"), c = e[ir];
        return c._updateEffectSymbol = function (t, e) {
            var r = t[Ai](e), a = r[Jn]("effect"), l = a.get(xe), c = a.get(_e);
            o[gn](l) || (l = [l, l]);
            var u = a.get("color") || t[Mi](e, "color"), h = this[ni](1), d = 1e3 * a.get("period");
            (this._symbolType !== c || d !== this._period) && (h = s[O](c, -.5, -.5, 1, 1, u), h[Wn] = !0, h.z2 = 100, this._symbolType = c, this._period = d, this.add(h), h.__t = 0, h[hi]("", !0).when(d, {__t: 1}).delay(e / t.count() * d / 2).during(o.bind(n, h)).start()), h[qi]("shadowColor", u), h[qi](a[Wi](["color"])), h.attr("scale", l);
            var f = t[fi](e);
            i(h, f), h.setColor(u), h.attr("scale", l)
        }, c[li] = function (t, e) {
            this[ni](0)[li](t, e), this._updateEffectSymbol(t, e)
        }, c[Nn] = function (t, e) {
            this[ni](0)[Nn](t, e);
            var n = this[ni](1), r = t[fi](e);
            i(n, r)
        }, o[on](e, r.Group), e
    }),e("echarts/chart/helper/Line", [gr, E, ar, "./LinePath", vi, vr, Be], function (t) {
        function e(t) {
            return "_" + t + "Type"
        }

        function i(t, e, i) {
            var n = e[Mi](i, "color"), r = e[Mi](i, t), a = e[Mi](i, t + "Size");
            if (r && "none" !== r) {
                d[gn](a) || (a = [a, a]);
                var o = l[O](r, -a[0] / 2, -a[1] / 2, a[0], a[1], n);
                return o.name = t, o
            }
        }

        function n(t) {
            var e = new u({name: "line"});
            return r(e.shape, t), e
        }

        function r(t, e) {
            var i = e[0], n = e[1], r = e[2];
            t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, r && (t.cpx1 = r[0], t.cpy1 = r[1])
        }

        function a() {
            var t = this, e = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), n = t.childOfName("label");
            if (e || i || !n[Wn]) {
                for (var r = 1, a = this[U]; a;)a.scale && (r /= a.scale[0]), a = a[U];
                var o = t.childOfName("line");
                if (this[s] || o[s]) {
                    var l = o.shape.percent, u = o.pointAt(0), h = o.pointAt(l), d = c.sub([], h, u);
                    if (c[gi](d, d), e) {
                        e.attr(Ui, u);
                        var f = o.tangentAt(0);
                        e.attr(Ye, Math.PI / 2 - Math.atan2(f[1], f[0])), e.attr("scale", [r * l, r * l])
                    }
                    if (i) {
                        i.attr(Ui, h);
                        var f = o.tangentAt(1);
                        i.attr(Ye, -Math.PI / 2 - Math.atan2(f[1], f[0])), i.attr("scale", [r * l, r * l])
                    }
                    if (!n[Wn]) {
                        n.attr(Ui, h);
                        var p, v, g, m = 5 * r;
                        if ("end" === n.__position)p = [d[0] * m + h[0], d[1] * m + h[1]], v = d[0] > .8 ? "left" : d[0] < -.8 ? "right" : ji, g = d[1] > .8 ? "top" : d[1] < -.8 ? Hn : Xi; else if (n.__position === Xi) {
                            var y = l / 2, f = o.tangentAt(y), x = [f[1], -f[0]], _ = o.pointAt(y);
                            x[1] > 0 && (x[0] = -x[0], x[1] = -x[1]), p = [_[0] + x[0] * m, _[1] + x[1] * m], v = ji, g = Hn;
                            var w = -Math.atan2(f[1], f[0]);
                            h[0] < u[0] && (w = Math.PI + w), n.attr(Ye, w)
                        } else p = [-d[0] * m + u[0], -d[1] * m + u[1]], v = d[0] > .8 ? "right" : d[0] < -.8 ? "left" : ji, g = d[1] > .8 ? Hn : d[1] < -.8 ? "top" : Xi;
                        n.attr({
                            style: {textVerticalAlign: n.__verticalAlign || g, textAlign: n.__textAlign || v},
                            position: p,
                            scale: [r, r]
                        })
                    }
                }
            }
        }

        function o(t, e) {
            h.Group.call(this), this._createLine(t, e)
        }

        var l = t(E), c = t(ar), u = t("./LinePath"), h = t(vi), d = t(vr), f = t(Be), p = ["fromSymbol", "toSymbol"], v = o[ir];
        return v.beforeUpdate = a, v._createLine = function (t, r) {
            var a = t[ri], o = t[fi](r), s = n(o);
            s.shape.percent = 0, h[Ze](s, {shape: {percent: 1}}, a, r), this.add(s);
            var l = new h.Text({name: "label"});
            this.add(l), d.each(p, function (n) {
                var a = i(n, t, r);
                this.add(a), this[e(n)] = t[Mi](r, n)
            }, this), this._updateCommonStl(t, r)
        }, v[li] = function (t, n) {
            var a = t[ri], o = this.childOfName("line"), s = t[fi](n), l = {shape: {}};
            r(l.shape, s), h[ei](o, l, a, n), d.each(p, function (r) {
                var a = t[Mi](n, r), o = e(r);
                if (this[o] !== a) {
                    var s = i(r, t, n);
                    this[En](this.childOfName(r)), this.add(s)
                }
                this[o] = a
            }, this), this._updateCommonStl(t, n)
        }, v._updateCommonStl = function (t, e) {
            var i = t[ri], n = this.childOfName("line"), r = t[Ai](e), a = r[Jn](Xe), o = a[Jn](nn), s = r[Jn](je), l = s[Jn](nn), c = f.round(i[ye](e));
            isNaN(c) && (c = t[xi](e)), n[ti](d[On]({
                strokeNoScale: !0,
                fill: "none",
                stroke: t[Mi](e, "color")
            }, r[Jn]("lineStyle.normal")[Ue]())), n[$e] = r[Jn]("lineStyle.emphasis")[Ue]();
            var u = t[Mi](e, "color") || "#000", p = this.childOfName("label");
            p[qi]({
                text: a.get("show") ? d[oi](i[ai](e, Li, t[_n]), c) : "",
                textFont: o[tn](),
                fill: o[$i]() || u
            }), p[$e] = {
                text: s.get("show") ? d[oi](i[ai](e, Ti, t[_n]), c) : "",
                textFont: l[tn](),
                fill: l[$i]() || u
            }, p.__textAlign = o.get("align"), p.__verticalAlign = o.get("baseline"), p.__position = a.get(Ui), p[Wn] = !p.style.text && !p[$e].text, h[Ke](this)
        }, v[Nn] = function (t, e) {
            var i = t[fi](e), n = this.childOfName("line");
            r(n.shape, i), n.dirty(!0)
        }, v.setLinePoints = function (t) {
            var e = this.childOfName("line");
            r(e.shape, t), e.dirty()
        }, d[on](o, h.Group), o
    }),e("zrender/config", [], function () {
        var t = 1;
        typeof window !== v && (t = Math.max(window.devicePixelRatio || 1, 1));
        var e = {debugMode: 0, devicePixelRatio: t};
        return e
    }),e("echarts/scale/Ordinal", [gr, vr, "./Scale"], function (t) {
        var e = t(vr), i = t("./Scale"), n = i[ir], r = i[On]({
            type: "ordinal", init: function (t, e) {
                this._data = t, this._extent = e || [0, t[zn] - 1]
            }, parse: function (t) {
                return typeof t === er ? e[vn](this._data, t) : Math.round(t)
            }, contain: function (t) {
                return t = this.parse(t), n[mi].call(this, t) && null != this._data[t]
            }, normalize: function (t) {
                return n[gi].call(this, this.parse(t))
            }, scale: function (t) {
                return Math.round(n.scale.call(this, t))
            }, getTicks: function () {
                for (var t = [], e = this._extent, i = e[0]; i <= e[1];)t.push(i), i++;
                return t
            }, getLabel: function (t) {
                return this._data[t]
            }, count: function () {
                return this._extent[1] - this._extent[0] + 1
            }, niceTicks: e.noop, niceExtent: e.noop
        });
        return r[Zn] = function () {
            return new r
        }, r
    }),e("echarts/coord/geo/Geo", [gr, "./parseGeoJson", vr, X, "../View", "./fix/nanhai", "./fix/textCoord", "./fix/geoCoord"], function (t) {
        function e(t, e, i, n, r) {
            a.call(this, t), this.map = e, this._nameCoordMap = {}, this.loadGeoJson(i, n, r)
        }

        var i = t("./parseGeoJson"), n = t(vr), r = t(X), a = t("../View"), o = [t("./fix/nanhai"), t("./fix/textCoord"), t("./fix/geoCoord")];
        return e[ir] = {
            constructor: e, type: "geo", dimensions: ["lng", "lat"], containCoord: function (t) {
                for (var e = this.regions, i = 0; i < e[zn]; i++)if (e[i][mi](t))return !0;
                return !1
            }, loadGeoJson: function (t, e, r) {
                try {
                    this.regions = t ? i(t) : []
                } catch (a) {
                    throw"Invalid geoJson format\n" + a
                }
                e = e || {}, r = r || {};
                for (var s = this.regions, l = {}, c = 0; c < s[zn]; c++) {
                    var u = s[c].name;
                    u = r[u] || u, s[c].name = u, l[u] = s[c], this.addGeoCoord(u, s[c][ji]);
                    var h = e[u];
                    h && s[c].transformTo(h.left, h.top, h.width, h[Fn])
                }
                this._regionsMap = l, this._rect = null, n.each(o, function (t) {
                    t(this)
                }, this)
            }, transformTo: function (t, e, i, n) {
                var a = this[Qi]();
                a = a.clone(), a.y = -a.y - a[Fn];
                var o = this._viewTransform;
                o[rr] = a.calculateTransform(new r(t, e, i, n)), o.decomposeTransform();
                var s = o.scale;
                s[1] = -s[1], o.updateTransform(), this._updateTransform()
            }, getRegion: function (t) {
                return this._regionsMap[t]
            }, getRegionByCoord: function (t) {
                for (var e = this.regions, i = 0; i < e[zn]; i++)if (e[i][mi](t))return e[i]
            }, addGeoCoord: function (t, e) {
                this._nameCoordMap[t] = e
            }, getGeoCoord: function (t) {
                return this._nameCoordMap[t]
            }, getBoundingRect: function () {
                if (this._rect)return this._rect;
                for (var t, e = this.regions, i = 0; i < e[zn]; i++) {
                    var n = e[i][Qi]();
                    t = t || n.clone(), t.union(n)
                }
                return this._rect = t || new r(0, 0, 0, 0)
            }, dataToPoints: function (t) {
                var e = [];
                return t[K](["lng", "lat"], function (t, i) {
                    return e[0] = t, e[1] = i, this[Se](e)
                }, this)
            }, dataToPoint: function (t) {
                return typeof t === er && (t = this.getGeoCoord(t)), t ? a[ir][Se].call(this, t) : void 0
            }
        }, n.mixin(e, a), e
    }),e("echarts/coord/Axis", [gr, yi, vr], function (t) {
        function e(t, e) {
            var i = t[1] - t[0], n = e, r = i / n / 2;
            t[0] += r, t[1] -= r
        }

        var i = t(yi), n = i[ze], r = t(vr), a = [0, 1], o = function (t, e, i) {
            this.dim = t, this.scale = e, this._extent = i || [0, 0], this[fe] = !1, this.onBand = !1
        };
        return o[ir] = {
            constructor: o, contain: function (t) {
                var e = this._extent, i = Math.min(e[0], e[1]), n = Math.max(e[0], e[1]);
                return t >= i && n >= t
            }, containData: function (t) {
                return this[mi](this[te](t))
            }, getExtent: function () {
                var t = this._extent.slice();
                return t
            }, getPixelPrecision: function (t) {
                return i.getPixelPrecision(t || this.scale[we](), this._extent)
            }, setExtent: function (t, e) {
                var i = this._extent;
                i[0] = t, i[1] = e
            }, dataToCoord: function (t, i) {
                var r = this._extent, o = this.scale;
                return t = o[gi](t), this.onBand && o.type === se && (r = r.slice(), e(r, o.count())), n(t, a, r, i)
            }, coordToData: function (t, i) {
                var r = this._extent, o = this.scale;
                this.onBand && o.type === se && (r = r.slice(), e(r, o.count()));
                var s = n(t, r, a, i);
                return this.scale.scale(s)
            }, getTicksCoords: function () {
                if (this.onBand) {
                    for (var t = this.getBands(), e = [], i = 0; i < t[zn]; i++)e.push(t[i][0]);
                    return t[i - 1] && e.push(t[i - 1][1]), e
                }
                return r.map(this.scale[oe](), this[te], this)
            }, getLabelsCoords: function () {
                if (this.onBand) {
                    for (var t, e = this.getBands(), i = [], n = 0; n < e[zn]; n++)t = e[n], i.push((t[0] + t[1]) / 2);
                    return i
                }
                return r.map(this.scale[oe](), this[te], this)
            }, getBands: function () {
                for (var t = this[we](), e = [], i = this.scale.count(), n = t[0], r = t[1], a = r - n, o = 0; i > o; o++)e.push([a * o / i + n, a * (o + 1) / i + n]);
                return e
            }, getBandWidth: function () {
                var t = this._extent, e = this.scale[we](), i = e[1] - e[0] + (this.onBand ? 1 : 0);
                0 === i && (i = 1);
                var n = Math.abs(t[1] - t[0]);
                return Math.abs(n) / i
            }
        }, o
    }),e("echarts/coord/geo/parseGeoJson", [gr, vr, "./Region"], function (t) {
        function e(t) {
            if (!t.UTF8Encoding)return t;
            for (var e = t.features, n = 0; n < e[zn]; n++)for (var r = e[n], a = r.geometry, o = a.coordinates, s = a.encodeOffsets, l = 0; l < o[zn]; l++) {
                var c = o[l];
                if (a.type === R)o[l] = i(c, s[l]); else if ("MultiPolygon" === a.type)for (var u = 0; u < c[zn]; u++) {
                    var h = c[u];
                    c[u] = i(h, s[l][u])
                }
            }
            return t.UTF8Encoding = !1, t
        }

        function i(t, e) {
            for (var i = [], n = e[0], r = e[1], a = 0; a < t[zn]; a += 2) {
                var o = t.charCodeAt(a) - 64, s = t.charCodeAt(a + 1) - 64;
                o = o >> 1 ^ -(1 & o), s = s >> 1 ^ -(1 & s), o += n, s += r, n = o, r = s, i.push([o / 1024, s / 1024])
            }
            return i
        }

        function n(t) {
            for (var e = [], i = 0; i < t[zn]; i++)for (var n = 0; n < t[i][zn]; n++)e.push(t[i][n]);
            return e
        }

        var r = t(vr), a = t("./Region");
        return function (t) {
            return e(t), r.map(r[fr](t.features, function (t) {
                return t.geometry && t.properties
            }), function (t) {
                var e = t.properties, i = t.geometry, r = i.coordinates;
                return "MultiPolygon" === i.type && (r = n(r)), new a(e.name, r, e.cp)
            })
        }
    }),e("echarts/coord/View", [gr, ar, or, "zrender/mixin/Transformable", vr, X], function (t) {
        function e() {
            a.call(this)
        }

        function i(t) {
            this.name = t, this[L], a.call(this), this._roamTransform = new e, this._viewTransform = new e, this._center, this._zoom
        }

        var n = t(ar), r = t(or), a = t("zrender/mixin/Transformable"), o = t(vr), s = t(X), l = n[J];
        return o.mixin(e, a), i[ir] = {
            constructor: i,
            type: "view",
            dimensions: ["x", "y"],
            setBoundingRect: function (t, e, i, n) {
                return this._rect = new s(t, e, i, n), this._rect
            },
            getBoundingRect: function () {
                return this._rect
            },
            setViewRect: function (t, e, i, n) {
                i = i, n = n, this.transformTo(t, e, i, n), this._viewRect = new s(t, e, i, n)
            },
            transformTo: function (t, e, i, n) {
                var r = this[Qi](), a = this._viewTransform;
                a[rr] = r.calculateTransform(new s(t, e, i, n)), a.decomposeTransform(), this._updateTransform()
            },
            setCenter: function (t) {
                t && (this._center = t, this._updateCenterAndZoom())
            },
            setZoom: function (t) {
                t = t || 1;
                var e = this[L];
                e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom()
            },
            getDefaultCenter: function () {
                var t = this[Qi](), e = t.x + t.width / 2, i = t.y + t[Fn] / 2;
                return [e, i]
            },
            getCenter: function () {
                return this._center || this.getDefaultCenter()
            },
            getZoom: function () {
                return this._zoom || 1
            },
            getRoamTransform: function () {
                return this._roamTransform
            },
            _updateCenterAndZoom: function () {
                var t = this._viewTransform.getLocalTransform(), e = this._roamTransform, i = this.getDefaultCenter(), r = this.getCenter(), a = this.getZoom();
                r = n[J]([], r, t), i = n[J]([], i, t), e.origin = r, e[Ui] = [i[0] - r[0], i[1] - r[1]], e.scale = [a, a], this._updateTransform()
            },
            _updateTransform: function () {
                var t = this._roamTransform, e = this._viewTransform;
                e[U] = t, t.updateTransform(), e.updateTransform(), e[rr] && r.copy(this[rr] || (this[rr] = []), e[rr]), this[rr] ? (this.invTransform = this.invTransform || [], r.invert(this.invTransform, this[rr])) : this.invTransform = null, this.decomposeTransform()
            },
            getViewRect: function () {
                return this._viewRect
            },
            getViewRectAfterRoam: function () {
                var t = this[Qi]().clone();
                return t[J](this[rr]), t
            },
            dataToPoint: function (t) {
                var e = this[rr];
                return e ? l([], t, e) : [t[0], t[1]]
            },
            pointToData: function (t) {
                var e = this.invTransform;
                return e ? l([], t, e) : [t[0], t[1]]
            }
        }, o.mixin(i, a), i
    }),e("echarts/coord/geo/fix/nanhai", [gr, "../Region"], function (t) {
        for (var e = t("../Region"), i = [126, 25], n = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], r = 0; r < n[zn]; r++)for (var a = 0; a < n[r][zn]; a++)n[r][a][0] /= 10.5, n[r][a][1] /= -14, n[r][a][0] += i[0], n[r][a][1] += i[1];
        return function (t) {
            "china" === t.map && t.regions.push(new e("", n, i))
        }
    }),e("echarts/coord/geo/fix/textCoord", [gr, vr], function (t) {
        var e = t(vr), i = {"": [32, 80], "": [0, -10], "": [10, 5], "": [-10, 10], "": [5, 5]};
        return function (t) {
            e.each(t.regions, function (t) {
                var e = i[t.name];
                if (e) {
                    var n = t[ji];
                    n[0] += e[0] / 10.5, n[1] += -e[1] / 14
                }
            })
        }
    }),e("echarts/coord/geo/fix/geoCoord", [gr, vr], function (t) {
        var e = t(vr), i = {Russia: [100, 60], "United States of America": [-99, 38]};
        return function (t) {
            e.each(t.regions, function (t) {
                var e = i[t.name];
                if (e) {
                    var n = t[ji];
                    n[0] = e[0], n[1] = e[1]
                }
            })
        }
    }),e("zrender/Element", [gr, "./core/guid", "./mixin/Eventful", "./mixin/Transformable", "./mixin/Animatable", "./core/util"], function (t) {
        var e = t("./core/guid"), i = t("./mixin/Eventful"), n = t("./mixin/Transformable"), r = t("./mixin/Animatable"), a = t("./core/util"), o = function (t) {
            n.call(this, t), i.call(this, t), r.call(this, t), this.id = t.id || e()
        };
        return o[ir] = {
            type: "element", name: "", __zr: null, ignore: !1, clipPath: null, drift: function (t, e) {
                switch (this[_]) {
                    case Ae:
                        e = 0;
                        break;
                    case f:
                        t = 0
                }
                var i = this[rr];
                i || (i = this[rr] = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty()
            }, beforeUpdate: function () {
            }, afterUpdate: function () {
            }, update: function () {
                this.updateTransform()
            }, traverse: function () {
            }, attrKV: function (t, e) {
                if (t === Ui || "scale" === t || "origin" === t) {
                    if (e) {
                        var i = this[t];
                        i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]
                    }
                } else this[t] = e
            }, hide: function () {
                this[Wn] = !0, this.__zr && this.__zr.refresh()
            }, show: function () {
                this[Wn] = !1, this.__zr && this.__zr.refresh()
            }, attr: function (t, e) {
                if (typeof t === er)this.attrKV(t, e); else if (a[Bn](t))for (var i in t)t.hasOwnProperty(i) && this.attrKV(i, t[i]);
                return this.dirty(), this
            }, setClipPath: function (t) {
                var e = this.__zr;
                e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty()
            }, removeClipPath: function () {
                var t = this.clipPath;
                t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty())
            }, addSelfToZr: function (t) {
                this.__zr = t;
                var e = this.animators;
                if (e)for (var i = 0; i < e[zn]; i++)t[Je].addAnimator(e[i]);
                this.clipPath && this.clipPath.addSelfToZr(t)
            }, removeSelfFromZr: function (t) {
                this.__zr = null;
                var e = this.animators;
                if (e)for (var i = 0; i < e[zn]; i++)t[Je].removeAnimator(e[i]);
                this.clipPath && this.clipPath.removeSelfFromZr(t)
            }
        }, a.mixin(o, r), a.mixin(o, n), a.mixin(o, i), o
    }),e("echarts/coord/polar/AxisModel", [gr, vr, c, "../axisModelCreator", "../axisModelCommonMixin"], function (t) {
        function e(t, e) {
            return e.type || (e.data ? be : "value")
        }

        var i = t(vr), n = t(c), r = t("../axisModelCreator"), a = n[On]({type: "polarAxis", axis: null});
        i.merge(a[ir], t("../axisModelCommonMixin"));
        var o = {
            angle: {polarIndex: 0, startAngle: 90, clockwise: !0, splitNumber: 12, axisLabel: {rotate: !1}},
            radius: {polarIndex: 0, splitNumber: 5}
        };
        r("angle", a, e, o.angle), r(Oe, a, e, o[Oe])
    }),e("echarts/data/helper/completeDimensions", [gr, vr], function (t) {
        function e(t, e, a, o) {
            if (!e)return t;
            var s = n(e[0]), l = r[gn](s) && s[zn] || 1;
            a = a || [], o = o || "extra";
            for (var c = 0; l > c; c++)if (!t[c]) {
                var u = a[c] || o + (c - a[zn]);
                t[c] = i(e, c) ? {type: "ordinal", name: u} : u
            }
            return t
        }

        function i(t, e) {
            for (var i = 0, a = t[zn]; a > i; i++) {
                var o = n(t[i]);
                if (!r[gn](o))return !1;
                var o = o[e];
                if (null != o && isFinite(o))return !1;
                if (r[an](o) && "-" !== o)return !0
            }
            return !1
        }

        function n(t) {
            return r[gn](t) ? t : r[Bn](t) ? t.value : t
        }

        var r = t(vr);
        return e
    }),e("zrender/mixin/Transformable", [gr, "../core/matrix", "../core/vector"], function (t) {
        function e(t) {
            return t > a || -a > t
        }

        var i = t("../core/matrix"), n = t("../core/vector"), r = i.identity, a = 5e-5, o = function (t) {
            t = t || {}, t[Ui] || (this[Ui] = [0, 0]), null == t[Ye] && (this[Ye] = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
        }, s = o[ir];
        s[rr] = null, s.needLocalTransform = function () {
            return e(this[Ye]) || e(this[Ui][0]) || e(this[Ui][1]) || e(this.scale[0] - 1) || e(this.scale[1] - 1)
        }, s.updateTransform = function () {
            var t = this[U], e = t && t[rr], n = this.needLocalTransform(), a = this[rr];
            return n || e ? (a = a || i[Zn](), n ? this.getLocalTransform(a) : r(a), e && (n ? i.mul(a, t[rr], a) : i.copy(a, t[rr])), this[rr] = a, this.invTransform = this.invTransform || i[Zn](), void i.invert(this.invTransform, a)) : void(a && r(a))
        }, s.getLocalTransform = function (t) {
            t = t || [], r(t);
            var e = this.origin, n = this.scale, a = this[Ye], o = this[Ui];
            return e && (t[4] -= e[0], t[5] -= e[1]), i.scale(t, t, n), a && i[l](t, t, a), e && (t[4] += e[0], t[5] += e[1]), t[4] += o[0], t[5] += o[1], t
        }, s.setTransform = function (t) {
            var e = this[rr];
            e && t[rr](e[0], e[1], e[2], e[3], e[4], e[5])
        };
        var c = [];
        return s.decomposeTransform = function () {
            if (this[rr]) {
                var t = this[U], n = this[rr];
                t && t[rr] && (i.mul(c, t.invTransform, n), n = c);
                var r = n[0] * n[0] + n[1] * n[1], a = n[2] * n[2] + n[3] * n[3], o = this[Ui], s = this.scale;
                e(r - 1) && (r = Math.sqrt(r)), e(a - 1) && (a = Math.sqrt(a)), n[0] < 0 && (r = -r), n[3] < 0 && (a = -a), o[0] = n[4], o[1] = n[5], s[0] = r, s[1] = a, this[Ye] = Math.atan2(-n[1] / a, n[0] / r)
            }
        }, s.getGlobalScale = function () {
            var t = this[rr];
            if (!t)return [1, 1];
            var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]), i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);
            return t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), [e, i]
        }, s.transformCoordToLocal = function (t, e) {
            var i = [t, e], r = this.invTransform;
            return r && n[J](i, i, r), i
        }, s.transformCoordToGlobal = function (t, e) {
            var i = [t, e], r = this[rr];
            return r && n[J](i, i, r), i
        }, o
    }),e("echarts/chart/gauge/PointerPath", [gr, "zrender/graphic/Path"], function (t) {
        return t("zrender/graphic/Path")[On]({
            type: "echartsGaugePointer",
            shape: {angle: 0, width: 10, r: 10, x: 0, y: 0},
            buildPath: function (t, e) {
                var i = Math.cos, r = Math.sin, a = e.r, o = e.width, s = e.angle, l = e.x - i(s) * o * (o >= a / 3 ? 1 : 2), c = e.y - r(s) * o * (o >= a / 3 ? 1 : 2);
                s = e.angle - Math.PI / 2, t[d](l, c), t[n](e.x + i(s) * o, e.y + r(s) * o), t[n](e.x + i(e.angle) * a, e.y + r(e.angle) * a), t[n](e.x - i(s) * o, e.y - r(s) * o), t[n](l, c)
            }
        })
    }),e("echarts/coord/axisModelCreator", [gr, "./axisDefault", vr, "../model/Component", "../util/layout"], function (t) {
        var e = t("./axisDefault"), i = t(vr), n = t("../model/Component"), r = t("../util/layout"), a = ["value", be, "time", "log"];
        return function (t, o, s, l) {
            i.each(a, function (n) {
                o[On]({
                    type: t + "Axis." + n, mergeDefaultAndTheme: function (e, a) {
                        var o = this.layoutMode, l = o ? r.getLayoutParams(e) : {}, c = a.getTheme();
                        i.merge(e, c.get(n + "Axis")), i.merge(e, this.getDefaultOption()), e.type = s(t, e), o && r.mergeLayoutParam(e, l, o)
                    }, defaultOption: i.mergeAll([{}, e[n + "Axis"], l], !0)
                })
            }), n.registerSubTypeDefaulter(t + "Axis", i.curry(s, t))
        }
    }),e("echarts/coord/axisModelCommonMixin", [gr, vr, "./axisHelper"], function (t) {
        function e(t) {
            return r[Bn](t) && null != t.value ? t.value : t
        }

        function i() {
            return this.get("type") === be && r.map(this.get("data"), e)
        }

        function n() {
            return a[pe](this.axis, this.get("axisLabel.formatter"))
        }

        var r = t(vr), a = t("./axisHelper");
        return {getFormattedLabels: n, getCategories: i}
    }),e("echarts/chart/heatmap/HeatmapLayer", [gr, vr], function (t) {
        function e() {
            var t = r.createCanvas();
            this[tr] = t, this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {}
        }

        var n = 256, r = t(vr);
        return e[ir] = {
            update: function (t, e, i, r, a, o) {
                var s = this._getBrush(), l = this._getGradient(t, a, "inRange"), c = this._getGradient(t, a, "outOfRange"), u = this.pointSize + this.blurSize, h = this[tr], d = h[Zi]("2d"), f = t[zn];
                h.width = e, h[Fn] = i;
                for (var p = 0; f > p; ++p) {
                    var v = t[p], g = v[0], m = v[1], y = v[2], x = r(y);
                    d.globalAlpha = x, d.drawImage(s, g - u, m - u)
                }
                for (var _ = d.getImageData(0, 0, h.width, h[Fn]), w = _.data, b = 0, M = w[zn], S = this.minOpacity, A = this.maxOpacity, C = A - S; M > b;) {
                    var x = w[b + 3] / 256, T = 4 * Math.floor(x * (n - 1));
                    if (x > 0) {
                        var L = o(x) ? l : c;
                        x > 0 && (x = x * C + S), w[b++] = L[T], w[b++] = L[T + 1], w[b++] = L[T + 2], w[b++] = L[T + 3] * x * 256
                    } else b += 4
                }
                return d.putImageData(_, 0, 0), h
            }, _getBrush: function () {
                var t = this._brushCanvas || (this._brushCanvas = r.createCanvas()), e = this.pointSize + this.blurSize, n = 2 * e;
                t.width = n, t[Fn] = n;
                var a = t[Zi]("2d");
                return a.clearRect(0, 0, n, n), a.shadowOffsetX = n, a.shadowBlur = this.blurSize, a.shadowColor = "#000", a[o](), a.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0), a[i](), a.fill(), t
            }, _getGradient: function (t, e, i) {
                for (var n = this._gradientPixels, r = n[i] || (n[i] = new Uint8ClampedArray(1024)), a = [], o = 0, s = 0; 256 > s; s++)e[i](s / 255, !0, a), r[o++] = a[0], r[o++] = a[1], r[o++] = a[2], r[o++] = a[3];
                return r
            }
        }, e
    }),e("echarts/coord/cartesian/Cartesian", [gr, vr], function (t) {
        function e(t) {
            return this._axes[t]
        }

        var i = t(vr), n = function (t) {
            this._axes = {}, this._dimList = [], this.name = t || ""
        };
        return n[ir] = {
            constructor: n, type: "cartesian", getAxis: function (t) {
                return this._axes[t]
            }, getAxes: function () {
                return i.map(this._dimList, e, this)
            }, getAxesByScale: function (t) {
                return t = t[nr](), i[fr](this.getAxes(), function (e) {
                    return e.scale.type === t
                })
            }, addAxis: function (t) {
                var e = t.dim;
                this._axes[e] = t, this._dimList.push(e)
            }, dataToCoord: function (t) {
                return this._dataCoordConvert(t, te)
            }, coordToData: function (t) {
                return this._dataCoordConvert(t, "coordToData")
            }, _dataCoordConvert: function (t, e) {
                for (var i = this._dimList, n = t instanceof Array ? [] : {}, r = 0; r < i[zn]; r++) {
                    var a = i[r], o = this._axes[a];
                    n[a] = o[e](t[a])
                }
                return n
            }
        }, n
    }),e("zrender/core/guid", [], function () {
        var t = 2311;
        return function () {
            return "zr_" + t++
        }
    }),e("zrender/mixin/Animatable", [gr, "../animation/Animator", p, "../core/log"], function (t) {
        var e = t("../animation/Animator"), i = t(p), n = i[an], r = i.isFunction, a = i[Bn], o = t("../core/log"), s = function () {
            this.animators = []
        };
        return s[ir] = {
            constructor: s, animate: function (t, n) {
                var r, a = !1, s = this, l = this.__zr;
                if (t) {
                    var c = t.split("."), u = s;
                    a = "shape" === c[0];
                    for (var h = 0, d = c[zn]; d > h; h++)u && (u = u[c[h]]);
                    u && (r = u)
                } else r = s;
                if (!r)return void o('Property "' + t + '" is not existed in element ' + s.id);
                var f = s.animators, p = new e(r, n);
                return p.during(function () {
                    s.dirty(a)
                }).done(function () {
                    f[Ln](i[vn](f, p), 1)
                }), f.push(p), l && l[Je].addAnimator(p), p
            }, stopAnimation: function (t) {
                for (var e = this.animators, i = e[zn], n = 0; i > n; n++)e[n].stop(t);
                return e[zn] = 0, this
            }, animateTo: function (t, e, i, a, o) {
                function s() {
                    c--, c || o && o()
                }

                n(i) ? (o = a, a = i, i = 0) : r(a) ? (o = a, a = "linear", i = 0) : r(i) ? (o = i, i = 0) : r(e) ? (o = e, e = 500) : e || (e = 500), this[Un](), this._animateToShallow("", this, t, e, i, a, o);
                var l = this.animators.slice(), c = l[zn];
                c || o && o();
                for (var u = 0; u < l[zn]; u++)l[u].done(s).start(a)
            }, _animateToShallow: function (t, e, n, r, o) {
                var s = {}, l = 0;
                for (var c in n)if (null != e[c])a(n[c]) && !i.isArrayLike(n[c]) ? this._animateToShallow(t ? t + "." + c : c, e[c], n[c], r, o) : (s[c] = n[c], l++); else if (null != n[c])if (t) {
                    var u = {};
                    u[t] = {}, u[t][c] = n[c], this.attr(u)
                } else this.attr(c, n[c]);
                return l > 0 && this[hi](t, !1).when(null == r ? 500 : r, s).delay(o || 0), this
            }
        }, s
    }),e("zrender/animation/Animator", [gr, "./Clip", "../tool/color", p], function (t) {
        function e(t, e) {
            return t[e]
        }

        function i(t, e, i) {
            t[e] = i
        }

        function n(t, e, i) {
            return (e - t) * i + t
        }

        function r(t, e, i) {
            return i > .5 ? e : t
        }

        function a(t, e, i, r, a) {
            var o = t[zn];
            if (1 == a)for (var s = 0; o > s; s++)r[s] = n(t[s], e[s], i); else for (var l = t[0][zn], s = 0; o > s; s++)for (var c = 0; l > c; c++)r[s][c] = n(t[s][c], e[s][c], i)
        }

        function o(t, e, i) {
            var n = t[zn], r = e[zn];
            if (n !== r) {
                var a = n > r;
                if (a)t[zn] = r; else for (var o = n; r > o; o++)t.push(1 === i ? e[o] : y.call(e[o]))
            }
            for (var s = t[0] && t[0][zn], o = 0; o < t[zn]; o++)if (1 === i)isNaN(t[o]) && (t[o] = e[o]); else for (var l = 0; s > l; l++)isNaN(t[o][l]) && (t[o][l] = e[o][l])
        }

        function s(t, e, i) {
            if (t === e)return !0;
            var n = t[zn];
            if (n !== e[zn])return !1;
            if (1 === i) {
                for (var r = 0; n > r; r++)if (t[r] !== e[r])return !1
            } else for (var a = t[0][zn], r = 0; n > r; r++)for (var o = 0; a > o; o++)if (t[r][o] !== e[r][o])return !1;
            return !0
        }

        function l(t, e, i, n, r, a, o, s, l) {
            var u = t[zn];
            if (1 == l)for (var h = 0; u > h; h++)s[h] = c(t[h], e[h], i[h], n[h], r, a, o); else for (var d = t[0][zn], h = 0; u > h; h++)for (var f = 0; d > f; f++)s[h][f] = c(t[h][f], e[h][f], i[h][f], n[h][f], r, a, o)
        }

        function c(t, e, i, n, r, a, o) {
            var s = .5 * (i - t), l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
        }

        function u(t) {
            if (m(t)) {
                var e = t[zn];
                if (m(t[0])) {
                    for (var i = [], n = 0; e > n; n++)i.push(y.call(t[n]));
                    return i
                }
                return y.call(t)
            }
            return t
        }

        function h(t) {
            return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
        }

        function d(t, e, i, u, d) {
            var p = t._getter, g = t._setter, y = "spline" === e, x = u[zn];
            if (x) {
                var _, w = u[0].value, b = m(w), M = !1, S = !1, A = b && m(w[0]) ? 2 : 1;
                u.sort(function (t, e) {
                    return t.time - e.time
                }), _ = u[x - 1].time;
                for (var C = [], T = [], L = u[0].value, k = !0, D = 0; x > D; D++) {
                    C.push(u[D].time / _);
                    var I = u[D].value;
                    if (b && s(I, L, A) || !b && I === L || (k = !1), L = I, typeof I == er) {
                        var P = v.parse(I);
                        P ? (I = P, M = !0) : S = !0
                    }
                    T.push(I)
                }
                if (!k) {
                    for (var z = T[x - 1], D = 0; x - 1 > D; D++)b ? o(T[D], z, A) : !isNaN(T[D]) || isNaN(z) || S || M || (T[D] = z);
                    b && o(p(t._target, d), z, A);
                    var V, R, O, E, B, N, G = 0, Z = 0;
                    if (M)var F = [0, 0, 0, 0];
                    var H = function (t, e) {
                        var i;
                        if (Z > e) {
                            for (V = Math.min(G + 1, x - 1), i = V; i >= 0 && !(C[i] <= e); i--);
                            i = Math.min(i, x - 2)
                        } else {
                            for (i = G; x > i && !(C[i] > e); i++);
                            i = Math.min(i - 1, x - 2)
                        }
                        G = i, Z = e;
                        var o = C[i + 1] - C[i];
                        if (0 !== o)if (R = (e - C[i]) / o, y)if (E = T[i], O = T[0 === i ? i : i - 1], B = T[i > x - 2 ? x - 1 : i + 1], N = T[i > x - 3 ? x - 1 : i + 2], b)l(O, E, B, N, R, R * R, R * R * R, p(t, d), A); else {
                            var s;
                            if (M)s = l(O, E, B, N, R, R * R, R * R * R, F, 1), s = h(F); else {
                                if (S)return r(E, B, R);
                                s = c(O, E, B, N, R, R * R, R * R * R)
                            }
                            g(t, d, s)
                        } else if (b)a(T[i], T[i + 1], R, p(t, d), A); else {
                            var s;
                            if (M)a(T[i], T[i + 1], R, F, 1), s = h(F); else {
                                if (S)return r(T[i], T[i + 1], R);
                                s = n(T[i], T[i + 1], R)
                            }
                            g(t, d, s)
                        }
                    }, W = new f({
                        target: t._target,
                        life: _,
                        loop: t._loop,
                        delay: t._delay,
                        onframe: H,
                        ondestroy: i
                    });
                    return e && "spline" !== e && (W.easing = e), W
                }
            }
        }

        var f = t("./Clip"), v = t("../tool/color"), g = t(p), m = g.isArrayLike, y = Array[ir].slice, x = function (t, n, r, a) {
            this._tracks = {}, this._target = t, this._loop = n || !1, this._getter = r || e, this._setter = a || i, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
        };
        return x[ir] = {
            when: function (t, e) {
                var i = this._tracks;
                for (var n in e) {
                    if (!i[n]) {
                        i[n] = [];
                        var r = this._getter(this._target, n);
                        if (null == r)continue;
                        0 !== t && i[n].push({time: 0, value: u(r)})
                    }
                    i[n].push({time: t, value: e[n]})
                }
                return this
            }, during: function (t) {
                return this._onframeList.push(t), this
            }, _doneCallback: function () {
                this._tracks = {}, this._clipList[zn] = 0;
                for (var t = this._doneList, e = t[zn], i = 0; e > i; i++)t[i].call(this)
            }, start: function (t) {
                var e, i = this, n = 0, r = function () {
                    n--, n || i._doneCallback()
                };
                for (var a in this._tracks) {
                    var o = d(this, t, r, this._tracks[a], a);
                    o && (this._clipList.push(o), n++, this[Je] && this[Je].addClip(o), e = o)
                }
                if (e) {
                    var s = e.onframe;
                    e.onframe = function (t, e) {
                        s(t, e);
                        for (var n = 0; n < i._onframeList[zn]; n++)i._onframeList[n](t, e)
                    }
                }
                return n || this._doneCallback(), this
            }, stop: function (t) {
                for (var e = this._clipList, i = this[Je], n = 0; n < e[zn]; n++) {
                    var r = e[n];
                    t && r.onframe(this._target, 1), i && i.removeClip(r)
                }
                e[zn] = 0
            }, delay: function (t) {
                return this._delay = t, this
            }, done: function (t) {
                return t && this._doneList.push(t), this
            }, getClips: function () {
                return this._clipList
            }
        }, x
    }),e("zrender/core/log", [gr, "../config"], function (t) {
        var e = t("../config");
        return function () {
            if (0 !== e.debugMode)if (1 == e.debugMode)for (var t in arguments)throw new Error(arguments[t]); else if (e.debugMode > 1)for (var t in arguments)console.log(arguments[t])
        }
    }),e("echarts/coord/axisDefault", [gr, vr], function (t) {
        var e = t(vr), i = {
            show: !0,
            zlevel: 0,
            z: 0,
            inverse: !1,
            name: "",
            nameLocation: "end",
            nameTextStyle: {},
            nameGap: 15,
            silent: !0,
            axisLine: {show: !0, onZero: !0, lineStyle: {color: "#333", width: 1, type: "solid"}},
            axisTick: {show: !0, inside: !1, length: 5, lineStyle: {color: "#333", width: 1}},
            axisLabel: {show: !0, inside: !1, rotate: 0, margin: 8, textStyle: {color: "#333", fontSize: 12}},
            splitLine: {show: !0, lineStyle: {color: ["#ccc"], width: 1, type: "solid"}},
            splitArea: {show: !1, areaStyle: {color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]}}
        }, n = e.merge({
            boundaryGap: !0,
            axisTick: {interval: "auto"},
            axisLabel: {interval: "auto"}
        }, i), r = e[Vn]({boundaryGap: [0, 0], splitNumber: 5}, i), a = e[Vn]({
            scale: !0,
            min: "dataMin",
            max: "dataMax"
        }, r), o = e[Vn]({}, r);
        return o.scale = !0, {categoryAxis: n, valueAxis: r, timeAxis: a, logAxis: o}
    }),e("zrender/animation/Clip", [gr, "./easing"], function (t) {
        function e(t) {
            this._target = t[Sn], this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart
        }

        var i = t("./easing");
        return e[ir] = {
            constructor: e, step: function (t) {
                this._initialized || (this._startTime = (new Date).getTime() + this._delay, this._initialized = !0);
                var e = (t - this._startTime) / this._life;
                if (!(0 > e)) {
                    e = Math.min(e, 1);
                    var n = this.easing, r = typeof n == er ? i[n] : n, a = typeof r === fn ? r(e) : e;
                    return this.fire("frame", a), 1 == e ? this.loop ? (this.restart(), "restart") : (this._needsRemove = !0, "destroy") : null
                }
            }, restart: function () {
                var t = (new Date).getTime(), e = (t - this._startTime) % this._life;
                this._startTime = (new Date).getTime() - e + this.gap, this._needsRemove = !1
            }, fire: function (t, e) {
                t = "on" + t, this[t] && this[t](this._target, e)
            }
        }, e
    }),e("echarts/component/dataZoom/DataZoomModel", [gr, vr, sr, Ri, Ei, "./AxisProxy"], function (t) {
        function e(t) {
            var e = {};
            return l(["start", "end", "startValue", "endValue"], function (i) {
                e[i] = t[i]
            }), e
        }

        function i(t, e, i, n) {
            null != i[e] && null == i[t] && (n[t] = null)
        }

        var n = t(vr), r = t(sr), a = t(Ri), o = t(Ei), s = t("./AxisProxy"), l = n.each, c = o.eachAxisDim, h = a[un]({
            type: "dataZoom",
            dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", Dn],
            defaultOption: {
                zlevel: 0,
                z: 4,
                orient: null,
                xAxisIndex: null,
                yAxisIndex: null,
                angleAxisIndex: null,
                radiusAxisIndex: null,
                filterMode: "filter",
                throttle: 100,
                start: 0,
                end: 100,
                startValue: null,
                endValue: null
            },
            init: function (t, i, n) {
                this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel;
                var r = e(t);
                this[P](t, n), this.doInit(r)
            },
            mergeOption: function (t) {
                var i = e(t);
                n.merge(this[Pi], t, !0), this.doInit(i)
            },
            doInit: function (t) {
                var e = this[Pi];
                r[Xn] || (e.realtime = !1), i("start", "startValue", t, e), i("end", "endValue", t, e), this.textStyleModel = this[Jn](nn), this._resetTarget(), this._giveAxisProxies()
            },
            _giveAxisProxies: function () {
                var t = this._axisProxies;
                this.eachTargetAxis(function (e, i, n, r) {
                    var a = this.dependentModels[e.axis][i], o = a.__dzAxisProxy || (a.__dzAxisProxy = new s(e.name, i, this, r));
                    t[e.name + "_" + i] = o
                }, this)
            },
            _resetTarget: function () {
                var t = this[Pi], e = this._judgeAutoMode();
                c(function (e) {
                    var i = e.axisIndex;
                    t[i] = o[b](t[i])
                }, this), "axisIndex" === e ? this._autoSetAxisIndex() : e === u && this._autoSetOrient()
            },
            _judgeAutoMode: function () {
                var t = this[Pi], e = !1;
                c(function (i) {
                    null != t[i.axisIndex] && (e = !0)
                }, this);
                var i = t[u];
                return null == i && e ? u : e ? void 0 : (null == i && (t[u] = Ae), "axisIndex")
            },
            _autoSetAxisIndex: function () {
                var t = !0, e = this.get(u, !0), i = this[Pi];
                if (t) {
                    var r = e === f ? {dim: "y", axisIndex: "yAxisIndex", axis: "yAxis"} : {
                        dim: "x",
                        axisIndex: "xAxisIndex",
                        axis: "xAxis"
                    };
                    this.dependentModels[r.axis][zn] && (i[r.axisIndex] = [0], t = !1)
                }
                t && c(function (e) {
                    if (t) {
                        var n = [], r = this.dependentModels[e.axis];
                        if (r[zn] && !n[zn])for (var a = 0, o = r[zn]; o > a; a++)r[a].get("type") === be && n.push(a);
                        i[e.axisIndex] = n, n[zn] && (t = !1)
                    }
                }, this), t && this[j][In](function (t) {
                    this._isSeriesHasAllAxesTypeOf(t, "value") && c(function (e) {
                        var r = i[e.axisIndex], a = t.get(e.axisIndex);
                        n[vn](r, a) < 0 && r.push(a)
                    })
                }, this)
            },
            _autoSetOrient: function () {
                var t;
                this.eachTargetAxis(function (e) {
                    !t && (t = e.name)
                }, this), this[Pi][u] = "y" === t ? f : Ae
            },
            _isSeriesHasAllAxesTypeOf: function (t, e) {
                var i = !0;
                return c(function (n) {
                    var r = t.get(n.axisIndex), a = this.dependentModels[n.axis][r];
                    a && a.get("type") === e || (i = !1)
                }, this), i
            },
            getFirstTargetAxisModel: function () {
                var t;
                return c(function (e) {
                    if (null == t) {
                        var i = this.get(e.axisIndex);
                        i[zn] && (t = this.dependentModels[e.axis][i[0]])
                    }
                }, this), t
            },
            eachTargetAxis: function (t, e) {
                var i = this[j];
                c(function (n) {
                    l(this.get(n.axisIndex), function (r) {
                        t.call(e, n, r, this, i)
                    }, this)
                }, this)
            },
            getAxisProxy: function (t, e) {
                return this._axisProxies[t + "_" + e]
            },
            setRawRange: function (t) {
                l(["start", "end", "startValue", "endValue"], function (e) {
                    this[Pi][e] = t[e]
                }, this)
            },
            getPercentRange: function () {
                var t = this.findRepresentativeAxisProxy();
                return t ? t.getDataPercentWindow() : void 0
            },
            getValueRange: function (t, e) {
                if (null != t || null != e)return this.getAxisProxy(t, e).getDataValueWindow();
                var i = this.findRepresentativeAxisProxy();
                return i ? i.getDataValueWindow() : void 0
            },
            findRepresentativeAxisProxy: function () {
                var t = this._axisProxies;
                for (var e in t)if (t.hasOwnProperty(e) && t[e].hostedBy(this))return t[e];
                for (var e in t)if (t.hasOwnProperty(e) && !t[e].hostedBy(this))return t[e]
            }
        });
        return h
    }),e("echarts/component/dataZoom/AxisProxy", [gr, vr, Be], function (t) {
        function e(t, e) {
            var i = [1 / 0, -1 / 0];
            return s(e, function (e) {
                var n = e[ur]();
                n && s(e[le](t), function (t) {
                    var e = n[Re](t);
                    e[0] < i[0] && (i[0] = e[0]), e[1] > i[1] && (i[1] = e[1])
                })
            }, this), i
        }

        function i(t, e, i) {
            var r = i.getAxisModel(), a = r.axis.scale, c = [0, 100], u = [t.start, t.end], h = [];
            return e = e.slice(), n(e, r, a), s(["startValue", "endValue"], function (e) {
                h.push(null != t[e] ? a.parse(t[e]) : null)
            }), s([0, 1], function (t) {
                var i = h[t], n = u[t];
                null != n || null == i ? (null == n && (n = c[t]), i = a.parse(o[ze](n, c, e, !0))) : n = o[ze](i, e, c, !0), h[t] = i, u[t] = n
            }), {valueWindow: l(h), percentWindow: l(u)}
        }

        function n(t, e, i) {
            return s(["min", "max"], function (n, r) {
                var a = e.get(n, !0);
                null != a && (a + "")[nr]() !== "data" + n && (t[r] = i.parse(a))
            }), e.get("scale", !0) || (t[0] > 0 && (t[0] = 0), t[1] < 0 && (t[1] = 0)), t
        }

        function r(t, e) {
            var i = t.getAxisModel(), n = t._percentWindow, r = t._valueWindow;
            if (n) {
                var a = e || 0 === n[0] && 100 === n[1], s = !e && o.getPixelPrecision(r, [0, 500]), l = !(e || 20 > s && s >= 0), c = e || a || l;
                i.setRange && i.setRange(c ? null : +r[0][Di](s), c ? null : +r[1][Di](s))
            }
        }

        var a = t(vr), o = t(Be), s = a.each, l = o.asc, c = function (t, e, i, n) {
            this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this[j] = n, this._dataZoomModel = i
        };
        return c[ir] = {
            constructor: c, hostedBy: function (t) {
                return this._dataZoomModel === t
            }, getDataExtent: function () {
                return this._dataExtent.slice()
            }, getDataValueWindow: function () {
                return this._valueWindow.slice()
            }, getDataPercentWindow: function () {
                return this._percentWindow.slice()
            }, getTargetSeriesModels: function () {
                var t = [];
                return this[j][In](function (e) {
                    this._axisIndex === e.get(this._dimName + "AxisIndex") && t.push(e)
                }, this), t
            }, getAxisModel: function () {
                return this[j][ve](this._dimName + "Axis", this._axisIndex)
            }, getOtherAxisModel: function () {
                var t, e, i = this._dimName, n = this[j], r = this.getAxisModel(), a = "x" === i || "y" === i;
                a ? (e = "gridIndex", t = "x" === i ? "y" : "x") : (e = Y, t = "angle" === i ? Oe : "angle");
                var o;
                return n[qn](t + "Axis", function (t) {
                    (t.get(e) || 0) === (r.get(e) || 0) && (o = t)
                }), o
            }, reset: function (t) {
                if (t === this._dataZoomModel) {
                    var n = this._dataExtent = e(this._dimName, this.getTargetSeriesModels()), a = i(t[Pi], n, this);
                    this._valueWindow = a.valueWindow, this._percentWindow = a.percentWindow, r(this)
                }
            }, restore: function (t) {
                t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, r(this, !0))
            }, filterData: function (t) {
                function e(t) {
                    return t >= a[0] && t <= a[1]
                }

                if (t === this._dataZoomModel) {
                    var i = this._dimName, n = this.getTargetSeriesModels(), r = t.get("filterMode"), a = this._valueWindow, o = this.getOtherAxisModel();
                    t.get("$fromToolbox") && o && o.get("type") === be && (r = "empty"), s(n, function (t) {
                        var n = t[ur]();
                        n && s(t[le](i), function (i) {
                            "empty" === r ? t.setData(n.map(i, function (t) {
                                return e(t) ? t : 0 / 0
                            })) : n.filterSelf(i, e)
                        })
                    })
                }
            }
        }, c
    }),e("zrender/animation/easing", [], function () {
        var t = {
            linear: function (t) {
                return t
            }, quadraticIn: function (t) {
                return t * t
            }, quadraticOut: function (t) {
                return t * (2 - t)
            }, quadraticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
            }, cubicIn: function (t) {
                return t * t * t
            }, cubicOut: function (t) {
                return --t * t * t + 1
            }, cubicInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
            }, quarticIn: function (t) {
                return t * t * t * t
            }, quarticOut: function (t) {
                return 1 - --t * t * t * t
            }, quarticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
            }, quinticIn: function (t) {
                return t * t * t * t * t
            }, quinticOut: function (t) {
                return --t * t * t * t * t + 1
            }, quinticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
            }, sinusoidalIn: function (t) {
                return 1 - Math.cos(t * Math.PI / 2)
            }, sinusoidalOut: function (t) {
                return Math.sin(t * Math.PI / 2)
            }, sinusoidalInOut: function (t) {
                return .5 * (1 - Math.cos(Math.PI * t))
            }, exponentialIn: function (t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1)
            }, exponentialOut: function (t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
            }, exponentialInOut: function (t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
            }, circularIn: function (t) {
                return 1 - Math.sqrt(1 - t * t)
            }, circularOut: function (t) {
                return Math.sqrt(1 - --t * t)
            }, circularInOut: function (t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            }, elasticIn: function (t) {
                var e, i = .1, n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n)))
            }, elasticOut: function (t) {
                var e, i = .1, n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1)
            }, elasticInOut: function (t) {
                var e, i = .1, n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1)
            }, backIn: function (t) {
                var e = 1.70158;
                return t * t * ((e + 1) * t - e)
            }, backOut: function (t) {
                var e = 1.70158;
                return --t * t * ((e + 1) * t + e) + 1
            }, backInOut: function (t) {
                var e = 2.5949095;
                return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
            }, bounceIn: function (e) {
                return 1 - t.bounceOut(1 - e)
            }, bounceOut: function (t) {
                return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            }, bounceInOut: function (e) {
                return .5 > e ? .5 * t.bounceIn(2 * e) : .5 * t.bounceOut(2 * e - 1) + .5
            }
        };
        return t
    }),e("zrender/contain/quadratic", [gr, "../core/curve"], function (t) {
        var e = t("../core/curve");
        return {
            containStroke: function (t, i, n, r, a, o, s, l, c) {
                if (0 === s)return !1;
                var u = s;
                if (c > i + u && c > r + u && c > o + u || i - u > c && r - u > c && o - u > c || l > t + u && l > n + u && l > a + u || t - u > l && n - u > l && a - u > l)return !1;
                var h = e.quadraticProjectPoint(t, i, n, r, a, o, l, c, null);
                return u / 2 >= h
            }
        }
    }),e("zrender/contain/cubic", [gr, "../core/curve"], function (t) {
        var e = t("../core/curve");
        return {
            containStroke: function (t, i, n, r, a, o, s, l, c, u, h) {
                if (0 === c)return !1;
                var d = c;
                if (h > i + d && h > r + d && h > o + d && h > l + d || i - d > h && r - d > h && o - d > h && l - d > h || u > t + d && u > n + d && u > a + d && u > s + d || t - d > u && n - d > u && a - d > u && s - d > u)return !1;
                var f = e.cubicProjectPoint(t, i, n, r, a, o, s, l, u, h, null);
                return d / 2 >= f
            }
        }
    }),e("zrender/contain/line", [], function () {
        return {
            containStroke: function (t, e, i, n, r, a, o) {
                if (0 === r)return !1;
                var s = r, l = 0, c = t;
                if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a)return !1;
                if (t === i)return Math.abs(a - t) <= s / 2;
                l = (e - n) / (t - i), c = (t * n - i * e) / (t - i);
                var u = l * a - o + c, h = u * u / (l * l + 1);
                return s / 2 * s / 2 >= h
            }
        }
    }),e("zrender/contain/arc", [gr, "./util"], function (t) {
        var e = t("./util").normalizeRadian, i = 2 * Math.PI;
        return {
            containStroke: function (t, n, r, a, o, s, l, c, u) {
                if (0 === l)return !1;
                var h = l;
                c -= t, u -= n;
                var d = Math.sqrt(c * c + u * u);
                if (d - h > r || r > d + h)return !1;
                if (Math.abs(a - o) % i < 1e-4)return !0;
                if (s) {
                    var f = a;
                    a = e(o), o = e(f)
                } else a = e(a), o = e(o);
                a > o && (o += i);
                var p = Math.atan2(u, c);
                return 0 > p && (p += i), p >= a && o >= p || p + i >= a && o >= p + i
            }
        }
    }),e("zrender/contain/util", [gr], function () {
        var t = 2 * Math.PI;
        return {
            normalizeRadian: function (e) {
                return e %= t, 0 > e && (e += t), e
            }
        }
    }),e("zrender/contain/windingLine", [], function () {
        return function (t, e, i, n, r, a) {
            if (a > e && a > n || e > a && n > a)return 0;
            if (n === e)return 0;
            var o = e > n ? 1 : -1, s = (a - e) / (n - e), l = s * (i - t) + t;
            return l > r ? o : 0
        }
    }),e("zrender/graphic/helper/roundRect", [gr], function () {
        return {
            buildPath: function (t, e) {
                var i, r, a, o, s = e.x, l = e.y, c = e.width, u = e[Fn], h = e.r;
                0 > c && (s += c, c = -c), 0 > u && (l += u, u = -u), typeof h === sn ? i = r = a = o = h : h instanceof Array ? 1 === h[zn] ? i = r = a = o = h[0] : 2 === h[zn] ? (i = a = h[0], r = o = h[1]) : 3 === h[zn] ? (i = h[0], r = o = h[1], a = h[2]) : (i = h[0], r = h[1], a = h[2], o = h[3]) : i = r = a = o = 0;
                var f;
                i + r > c && (f = i + r, i *= c / f, r *= c / f), a + o > c && (f = a + o, a *= c / f, o *= c / f), r + a > u && (f = r + a, r *= u / f, a *= u / f), i + o > u && (f = i + o, i *= u / f, o *= u / f), t[d](s + i, l), t[n](s + c - r, l), 0 !== r && t.quadraticCurveTo(s + c, l, s + c, l + r), t[n](s + c, l + u - a), 0 !== a && t.quadraticCurveTo(s + c, l + u, s + c - a, l + u), t[n](s + o, l + u), 0 !== o && t.quadraticCurveTo(s, l + u, s, l + u - o), t[n](s, l + i), 0 !== i && t.quadraticCurveTo(s, l, s + i, l)
            }
        }
    }),e("zrender/core/LRU", [gr], function () {
        var t = function () {
            this.head = null, this.tail = null, this._len = 0
        }, e = t[ir];
        e.insert = function (t) {
            var e = new i(t);
            return this.insertEntry(e), e
        }, e.insertEntry = function (t) {
            this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t, this._len++
        }, e[En] = function (t) {
            var e = t.prev, i = t.next;
            e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--
        }, e.len = function () {
            return this._len
        };
        var i = function (t) {
            this.value = t, this.next, this.prev
        }, n = function (e) {
            this._list = new t, this._map = {}, this._maxSize = e || 10
        }, r = n[ir];
        return r.put = function (t, e) {
            var i = this._list, n = this._map;
            if (null == n[t]) {
                var r = i.len();
                if (r >= this._maxSize && r > 0) {
                    var a = i.head;
                    i[En](a), delete n[a.key]
                }
                var o = i.insert(e);
                o.key = t, n[t] = o
            }
        }, r.get = function (t) {
            var e = this._map[t], i = this._list;
            return null != e ? (e !== i.tail && (i[En](e), i.insertEntry(e)), e.value) : void 0
        }, r.clear = function () {
            this._list.clear(), this._map = {}
        }, n
    }),e("zrender/animation/Animation", [gr, p, "../core/event", "./Animator"], function (t) {
        var e = t(p), i = t("../core/event").Dispatcher, n = typeof window !== v && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) {
                setTimeout(t, 16)
            }, r = t("./Animator"), a = function (t) {
            t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () {
                }, this._clips = [], this._running = !1, this._time = 0, i.call(this)
        };
        return a[ir] = {
            constructor: a, addClip: function (t) {
                this._clips.push(t)
            }, addAnimator: function (t) {
                t[Je] = this;
                for (var e = t.getClips(), i = 0; i < e[zn]; i++)this.addClip(e[i])
            }, removeClip: function (t) {
                var i = e[vn](this._clips, t);
                i >= 0 && this._clips[Ln](i, 1)
            }, removeAnimator: function (t) {
                for (var e = t.getClips(), i = 0; i < e[zn]; i++)this.removeClip(e[i]);
                t[Je] = null
            }, _update: function () {
                for (var t = (new Date).getTime(), e = t - this._time, i = this._clips, n = i[zn], r = [], a = [], o = 0; n > o; o++) {
                    var s = i[o], l = s.step(t);
                    l && (r.push(l), a.push(s))
                }
                for (var o = 0; n > o;)i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
                n = r[zn];
                for (var o = 0; n > o; o++)a[o].fire(r[o]);
                this._time = t, this.onframe(e), this[Pn]("frame", e), this.stage[Gn] && this.stage[Gn]()
            }, start: function () {
                function t() {
                    e._running && (n(t), e._update())
                }

                var e = this;
                this._running = !0, this._time = (new Date).getTime(), n(t)
            }, stop: function () {
                this._running = !1
            }, clear: function () {
                this._clips = []
            }, animate: function (t, e) {
                e = e || {};
                var i = new r(t, e.loop, e.getter, e.setter);
                return i
            }
        }, e.mixin(a, i), a
    }),e("zrender/Handler", [gr, "./core/env", "./core/event", "./core/util", "./mixin/Draggable", "./core/GestureMgr", "./mixin/Eventful"], function (t) {
        function e(t, e, i) {
            return {
                type: t,
                event: i,
                target: e,
                cancelBubble: !1,
                offsetX: i.zrX,
                offsetY: i.zrY,
                gestureEvent: i.gestureEvent,
                pinchX: i.pinchX,
                pinchY: i.pinchY,
                pinchScale: i.pinchScale,
                wheelDelta: i.zrDelta
            }
        }

        function i(t, e, i) {
            var n = t._gestureMgr;
            "start" === i && n.clear();
            var r = n.recognize(e, t.findHover(e.zrX, e.zrY, null));
            if ("end" === i && n.clear(), r) {
                var a = r.type;
                e.gestureEvent = a, t._dispatchProxy(r[Sn], a, r.event)
            }
        }

        function n(t) {
            function e(t, e) {
                return function () {
                    return e._touching ? void 0 : t.apply(e, arguments)
                }
            }

            for (var i = m[Gi](y), n = 0; n < i[zn]; n++) {
                var r = i[n];
                t._handlers[r] = d.bind(M[r], t)
            }
            for (var n = 0; n < g[zn]; n++) {
                var r = g[n];
                t._handlers[r] = e(M[r], t)
            }
        }

        function r(t, e, i) {
            if (t[t.rectHover ? "rectContain" : mi](e, i)) {
                for (var n = t; n;) {
                    if (n.silent || n.clipPath && !n.clipPath[mi](e, i))return !1;
                    n = n[U]
                }
                return !0
            }
            return !1
        }

        function a(t) {
            t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function () {
                t._touching = !1
            }, 700)
        }

        function o() {
            return !1
        }

        function s() {
            return c.touchEventsSupported
        }

        function l(t) {
            return "mousewheel" === t && c.browser.firefox ? "DOMMouseScroll" : t
        }

        var c = t("./core/env"), u = t("./core/event"), d = t("./core/util"), f = t("./mixin/Draggable"), p = t("./core/GestureMgr"), v = t("./mixin/Eventful"), g = ["click", "dblclick", "mousewheel", An];
        !o() && g.push("mouseup", "mousedown", h);
        var m = ["touchstart", "touchend", "touchmove"], y = ["pointerdown", "pointerup", "pointermove"], x = 300, _ = u.addEventListener, w = u.removeEventListener, b = u.normalizeEvent, M = {
            mousemove: function (t) {
                t = b(this.root, t);
                var e = t.zrX, i = t.zrY, n = this.findHover(e, i, null), r = this._hovered;
                this._hovered = n, this.root.style.cursor = n ? n.cursor : this._defaultCursorStyle, r && n !== r && r.__zr && this._dispatchProxy(r, An, t), this._dispatchProxy(n, h, t), n && n !== r && this._dispatchProxy(n, Cn, t)
            }, mouseout: function (t) {
                t = b(this.root, t);
                var e = t.toElement || t.relatedTarget;
                if (e != this.root)for (; e && 9 != e.nodeType;) {
                    if (e === this.root)return;
                    e = e[B]
                }
                this._dispatchProxy(this._hovered, An, t), this[Pn]("globalout", {event: t})
            }, touchstart: function (t) {
                t = b(this.root, t), this._lastTouchMoment = new Date, i(this, t, "start"), M[h].call(this, t), M.mousedown.call(this, t), a(this)
            }, touchmove: function (t) {
                t = b(this.root, t), i(this, t, "change"), M[h].call(this, t), a(this)
            }, touchend: function (t) {
                t = b(this.root, t), i(this, t, "end"), M.mouseup.call(this, t), +new Date - this._lastTouchMoment < x && M.click.call(this, t), a(this)
            }
        };
        d.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"], function (t) {
            M[t] = function (e) {
                e = b(this.root, e);
                var i = this.findHover(e.zrX, e.zrY, null);
                if ("mousedown" === t)this._downel = i, this._upel = i; else if ("mosueup" === t)this._upel = i; else if ("click" === t && this._downel !== this._upel)return;
                this._dispatchProxy(i, t, e)
            }
        });
        var S = function (t, e, i) {
            function r(e, i) {
                d.each(e, function (e) {
                    _(t, l(e), i._handlers[e])
                }, i)
            }

            v.call(this), this.root = t, this.storage = e, this.painter = i, this._hovered, this._lastTouchMoment, this._lastX, this._lastY, this._defaultCursorStyle = "default", this._gestureMgr = new p, this._handlers = [], this._touching = !1, this._touchTimer, n(this), o() ? r(y, this) : s() && r(m, this), r(g, this), f.call(this)
        };
        return S[ir] = {
            constructor: S, resize: function () {
                this._hovered = null
            }, dispatch: function (t, e) {
                var i = this._handlers[t];
                i && i.call(this, e)
            }, dispose: function () {
                for (var t = this.root, e = g[Gi](m), i = 0; i < e[zn]; i++) {
                    var n = e[i];
                    w(t, l(n), this._handlers[n])
                }
                this.root = this.storage = this.painter = null
            }, setDefaultCursorStyle: function (t) {
                this._defaultCursorStyle = t
            }, _dispatchProxy: function (t, i, n) {
                for (var r = "on" + i, a = e(i, t, n), o = t; o && (o[r] && (a.cancelBubble = o[r].call(o, a)), o[Pn](i, a), o = o[U], !a.cancelBubble););
                a.cancelBubble || (this[Pn](i, a), this.painter && this.painter.eachOtherLayer(function (t) {
                    typeof t[r] == fn && t[r].call(t, a), t[Pn] && t[Pn](i, a)
                }))
            }, findHover: function (t, e, i) {
                for (var n = this.storage.getDisplayList(), a = n[zn] - 1; a >= 0; a--)if (!n[a].silent && n[a] !== i && !n[a][Wn] && r(n[a], t, e))return n[a]
            }
        }, d.mixin(S, v), d.mixin(S, f), S
    }),e("zrender/core/event", [gr, "../mixin/Eventful"], function (t) {
        function e(t) {
            return t.getBoundingClientRect ? t.getBoundingClientRect() : {left: 0, top: 0}
        }

        function i(t, i) {
            if (i = i || window.event, null != i.zrX)return i;
            var n = i.type, r = n && n[vn]("touch") >= 0;
            if (r) {
                var a = "touchend" != n ? i.targetTouches[0] : i.changedTouches[0];
                if (a) {
                    var o = e(t);
                    i.zrX = a.clientX - o.left, i.zrY = a.clientY - o.top
                }
            } else {
                var s = e(t);
                i.zrX = i.clientX - s.left, i.zrY = i.clientY - s.top, i.zrDelta = i.wheelDelta ? i.wheelDelta / 120 : -(i.detail || 0) / 3
            }
            return i
        }

        function n(t, e, i) {
            o ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
        }

        function r(t, e, i) {
            o ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
        }

        var a = t("../mixin/Eventful"), o = typeof window !== v && !!window.addEventListener, s = o ? function (t) {
            t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
        } : function (t) {
            t.returnValue = !1, t.cancelBubble = !0
        };
        return {normalizeEvent: i, addEventListener: n, removeEventListener: r, stop: s, Dispatcher: a}
    }),e("zrender/mixin/Draggable", [gr], function () {
        function t() {
            this.on("mousedown", this._dragStart, this), this.on(h, this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this)
        }

        return t[ir] = {
            constructor: t, _dragStart: function (t) {
                var e = t[Sn];
                e && e[_] && (this._draggingTarget = e, e.dragging = !0, this._x = t[F], this._y = t[Z], this._dispatchProxy(e, "dragstart", t.event))
            }, _drag: function (t) {
                var e = this._draggingTarget;
                if (e) {
                    var i = t[F], n = t[Z], r = i - this._x, a = n - this._y;
                    this._x = i, this._y = n, e.drift(r, a, t), this._dispatchProxy(e, "drag", t.event);
                    var o = this.findHover(i, n, e), s = this._dropTarget;
                    this._dropTarget = o, e !== o && (s && o !== s && this._dispatchProxy(s, "dragleave", t.event), o && o !== s && this._dispatchProxy(o, "dragenter", t.event))
                }
            }, _dragEnd: function (t) {
                var e = this._draggingTarget;
                e && (e.dragging = !1), this._dispatchProxy(e, "dragend", t.event), this._dropTarget && this._dispatchProxy(this._dropTarget, "drop", t.event), this._draggingTarget = null, this._dropTarget = null
            }
        }, t
    }),e("zrender/graphic/helper/poly", [gr, "./smoothSpline", "./smoothBezier"], function (t) {
        var e = t("./smoothSpline"), a = t("./smoothBezier");
        return {
            buildPath: function (t, o, s) {
                var l = o[V], c = o.smooth;
                if (l && l[zn] >= 2) {
                    if (c && "spline" !== c) {
                        var u = a(l, c, s, o.smoothConstraint);
                        t[d](l[0][0], l[0][1]);
                        for (var h = l[zn], f = 0; (s ? h : h - 1) > f; f++) {
                            var p = u[2 * f], v = u[2 * f + 1], g = l[(f + 1) % h];
                            t[r](p[0], p[1], v[0], v[1], g[0], g[1])
                        }
                    } else {
                        "spline" === c && (l = e(l, s)), t[d](l[0][0], l[0][1]);
                        for (var f = 1, m = l[zn]; m > f; f++)t[n](l[f][0], l[f][1])
                    }
                    s && t[i]()
                }
            }
        }
    }),e("zrender/Storage", [gr, "./core/util", "./container/Group"], function (t) {
        function e(t, e) {
            return t[xn] === e[xn] ? t.z === e.z ? t.z2 === e.z2 ? t.__renderidx - e.__renderidx : t.z2 - e.z2 : t.z - e.z : t[xn] - e[xn]
        }

        var i = t("./core/util"), n = t("./container/Group"), r = function () {
            this._elements = {}, this._roots = [], this._displayList = [], this._displayListLen = 0
        };
        return r[ir] = {
            constructor: r, getDisplayList: function (t, e) {
                return e = e || !1, t && this.updateDisplayList(e), this._displayList
            }, updateDisplayList: function (t) {
                this._displayListLen = 0;
                for (var i = this._roots, n = this._displayList, r = 0, a = i[zn]; a > r; r++)this._updateAndAddDisplayable(i[r], null, t);
                n[zn] = this._displayListLen;
                for (var r = 0, a = n[zn]; a > r; r++)n[r].__renderidx = r;
                n.sort(e)
            }, _updateAndAddDisplayable: function (t, e, i) {
                if (!t[Wn] || i) {
                    t.beforeUpdate(), t[Gn](), t.afterUpdate();
                    var n = t.clipPath;
                    if (n && (n[U] = t, n.updateTransform(), e ? (e = e.slice(), e.push(n)) : e = [n]), "group" == t.type) {
                        for (var r = t._children, a = 0; a < r[zn]; a++) {
                            var o = r[a];
                            o[s] = t[s] || o[s], this._updateAndAddDisplayable(o, e, i)
                        }
                        t[s] = !1
                    } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t
                }
            }, addRoot: function (t) {
                this._elements[t.id] || (t instanceof n && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t))
            }, delRoot: function (t) {
                if (null == t) {
                    for (var e = 0; e < this._roots[zn]; e++) {
                        var r = this._roots[e];
                        r instanceof n && r.delChildrenFromStorage(this)
                    }
                    return this._elements = {}, this._roots = [], this._displayList = [], void(this._displayListLen = 0)
                }
                if (t instanceof Array)for (var e = 0, a = t[zn]; a > e; e++)this.delRoot(t[e]); else {
                    var o;
                    o = typeof t == er ? this._elements[t] : t;
                    var s = i[vn](this._roots, o);
                    s >= 0 && (this.delFromMap(o.id), this._roots[Ln](s, 1), o instanceof n && o.delChildrenFromStorage(this))
                }
            }, addToMap: function (t) {
                return t instanceof n && (t.__storage = this), t.dirty(), this._elements[t.id] = t, this
            }, get: function (t) {
                return this._elements[t]
            }, delFromMap: function (t) {
                var e = this._elements, i = e[t];
                return i && (delete e[t], i instanceof n && (i.__storage = null)), this
            }, dispose: function () {
                this._elements = this._renderList = this._roots = null
            }
        }, r
    }),e("zrender/Painter", [gr, "./config", "./core/util", "./core/log", "./core/BoundingRect", "./Layer", "./graphic/Image"], function (t) {
        function e(t) {
            return parseInt(t, 10)
        }

        function i(t) {
            return t ? t.isBuildin ? !0 : typeof t[$n] !== fn || typeof t.refresh !== fn ? !1 : !0 : !1
        }

        function n(t) {
            t.__unusedCount++
        }

        function r(t) {
            t[s] = !1, 1 == t.__unusedCount && t.clear()
        }

        function l(t, e, i) {
            return g.copy(t[Qi]()), t[rr] && g[J](t[rr]), m.width = e, m[Fn] = i, !g.intersect(m)
        }

        function c(t, e) {
            if (!t || !e || t[zn] !== e[zn])return !0;
            for (var i = 0; i < t[zn]; i++)if (t[i] !== e[i])return !0
        }

        function u(t, e) {
            for (var i = 0; i < t[zn]; i++) {
                var n, r = t[i];
                r[rr] && (n = r[rr], e[rr](n[0], n[1], n[2], n[3], n[4], n[5]));
                var s = r.path;
                s[o](e), r[a](s, r.shape), e.clip(), r[rr] && (n = r.invTransform, e[rr](n[0], n[1], n[2], n[3], n[4], n[5]))
            }
        }

        var h = t("./config"), d = t("./core/util"), f = t("./core/log"), p = t("./core/BoundingRect"), v = t("./Layer"), g = new p(0, 0, 0, 0), m = new p(0, 0, 0, 0), y = function (t, e, i) {
            var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
            i = i || {}, this.dpr = i.devicePixelRatio || h.devicePixelRatio, this._singleCanvas = n, this.root = t;
            var r = t.style;
            if (r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = "none", r["user-select"] = "none", r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e, n) {
                var a = t.width, o = t[Fn];
                this._width = a, this._height = o;
                var s = new v(t, this, 1);
                s.initContext(), this._layers = {0: s}, this._zlevelList = [0]
            } else {
                var a = this._getWidth(), o = this._getHeight();
                this._width = a, this._height = o;
                var l = document[Fi]("div");
                this._domRoot = l;
                var c = l.style;
                c[Ui] = "relative", c.overflow = "hidden", c.width = this._width + "px", c[Fn] = this._height + "px", t.appendChild(l), this._layers = {}, this._zlevelList = []
            }
            this._layerConfig = {}, this.pathToImage = this._createPathToImage()
        };
        return y[ir] = {
            constructor: y, isSingleCanvas: function () {
                return this._singleCanvas
            }, getViewportRoot: function () {
                return this._singleCanvas ? this._layers[0].dom : this._domRoot
            }, refresh: function (t) {
                var e = this.storage.getDisplayList(!0), i = this._zlevelList;
                this._paintList(e, t);
                for (var n = 0; n < i[zn]; n++) {
                    var r = i[n], a = this._layers[r];
                    !a.isBuildin && a.refresh && a.refresh()
                }
                return this
            }, _paintList: function (t, e) {
                null == e && (e = !1), this._updateLayerStatus(t);
                var i, a, o, h = this._width, d = this._height;
                this.eachBuildinLayer(n);
                for (var p = null, v = 0, g = t[zn]; g > v; v++) {
                    var m = t[v], y = this._singleCanvas ? 0 : m[xn];
                    if (a !== y && (a = y, i = this.getLayer(a), i.isBuildin || f("ZLevel " + a + " has been used by unkown layer " + i.id), o = i.ctx, i.__unusedCount = 0, (i[s] || e) && i.clear()), (i[s] || e) && !m[q] && 0 !== m.style[Hi] && m.scale[0] && m.scale[1] && (!m.culling || !l(m, h, d))) {
                        var x = m.__clipPaths;
                        c(x, p) && (p && o.restore(), x && (o.save(), u(x, o)), p = x), m.beforeBrush && m.beforeBrush(o), m.brush(o, !1), m.afterBrush && m.afterBrush(o)
                    }
                    m[s] = !1
                }
                p && o.restore(), this.eachBuildinLayer(r)
            }, getLayer: function (t) {
                if (this._singleCanvas)return this._layers[0];
                var e = this._layers[t];
                return e || (e = new v("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && d.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e
            }, insertLayer: function (t, e) {
                var n = this._layers, r = this._zlevelList, a = r[zn], o = null, s = -1, l = this._domRoot;
                if (n[t])return void f("ZLevel " + t + " has been used already");
                if (!i(e))return void f("Layer of zlevel " + t + " is not valid");
                if (a > 0 && t > r[0]) {
                    for (s = 0; a - 1 > s && !(r[s] < t && r[s + 1] > t); s++);
                    o = n[r[s]]
                }
                if (r[Ln](s + 1, 0, t), o) {
                    var c = o.dom;
                    c.nextSibling ? l.insertBefore(e.dom, c.nextSibling) : l.appendChild(e.dom)
                } else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
                n[t] = e
            }, eachLayer: function (t, e) {
                var i, n, r = this._zlevelList;
                for (n = 0; n < r[zn]; n++)i = r[n], t.call(e, this._layers[i], i)
            }, eachBuildinLayer: function (t, e) {
                var i, n, r, a = this._zlevelList;
                for (r = 0; r < a[zn]; r++)n = a[r], i = this._layers[n], i.isBuildin && t.call(e, i, n)
            }, eachOtherLayer: function (t, e) {
                var i, n, r, a = this._zlevelList;
                for (r = 0; r < a[zn]; r++)n = a[r], i = this._layers[n], i.isBuildin || t.call(e, i, n)
            }, getLayers: function () {
                return this._layers
            }, _updateLayerStatus: function (t) {
                var e = this._layers, i = {};
                this.eachBuildinLayer(function (t, e) {
                    i[e] = t.elCount, t.elCount = 0
                });
                for (var n = 0, r = t[zn]; r > n; n++) {
                    var a = t[n], o = this._singleCanvas ? 0 : a[xn], l = e[o];
                    if (l) {
                        if (l.elCount++, l[s])continue;
                        l[s] = a[s]
                    }
                }
                this.eachBuildinLayer(function (t, e) {
                    i[e] !== t.elCount && (t[s] = !0)
                })
            }, clear: function () {
                return this.eachBuildinLayer(this._clearLayer), this
            }, _clearLayer: function (t) {
                t.clear()
            }, configLayer: function (t, e) {
                if (e) {
                    var i = this._layerConfig;
                    i[t] ? d.merge(i[t], e, !0) : i[t] = e;
                    var n = this._layers[t];
                    n && d.merge(n, i[t], !0)
                }
            }, delLayer: function (t) {
                var e = this._layers, i = this._zlevelList, n = e[t];
                n && (n.dom[B].removeChild(n.dom), delete e[t], i[Ln](d[vn](i, t), 1))
            }, resize: function (t, e) {
                var i = this._domRoot;
                if (i.style.display = "none", t = t || this._getWidth(), e = e || this._getHeight(), i.style.display = "", this._width != t || e != this._height) {
                    i.style.width = t + "px", i.style[Fn] = e + "px";
                    for (var n in this._layers)this._layers[n][$n](t, e);
                    this.refresh(!0)
                }
                return this._width = t, this._height = e, this
            }, clearLayer: function (t) {
                var e = this._layers[t];
                e && e.clear()
            }, dispose: function () {
                this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
            }, getRenderedCanvas: function (t) {
                if (t = t || {}, this._singleCanvas)return this._layers[0].dom;
                var e = new v("image", this, t.pixelRatio || this.dpr);
                e.initContext();
                var i = e.ctx;
                e.clearColor = t[jn], e.clear();
                for (var n = this.storage.getDisplayList(!0), r = 0; r < n[zn]; r++) {
                    var a = n[r];
                    a[q] || (a.beforeBrush && a.beforeBrush(i), a.brush(i, !1), a.afterBrush && a.afterBrush(i))
                }
                return e.dom
            }, getWidth: function () {
                return this._width
            }, getHeight: function () {
                return this._height
            }, _getWidth: function () {
                var t = this.root, i = document.defaultView.getComputedStyle(t);
                return (t.clientWidth || e(i.width) || e(t.style.width)) - (e(i.paddingLeft) || 0) - (e(i.paddingRight) || 0) | 0
            }, _getHeight: function () {
                var t = this.root, i = document.defaultView.getComputedStyle(t);
                return (t.clientHeight || e(i[Fn]) || e(t.style[Fn])) - (e(i.paddingTop) || 0) - (e(i.paddingBottom) || 0) | 0
            }, _pathToImage: function (e, i, n, r, a) {
                var o = document[Fi](tr), s = o[Zi]("2d");
                o.width = n * a, o[Fn] = r * a, s.clearRect(0, 0, n * a, r * a);
                var l = {position: i[Ui], rotation: i[Ye], scale: i.scale};
                i[Ui] = [0, 0, 0], i[Ye] = 0, i.scale = [1, 1], i && i.brush(s);
                var c = t("./graphic/Image"), u = new c({id: e, style: {x: 0, y: 0, image: o}});
                return null != l[Ui] && (u[Ui] = i[Ui] = l[Ui]), null != l[Ye] && (u[Ye] = i[Ye] = l[Ye]), null != l.scale && (u.scale = i.scale = l.scale), u
            }, _createPathToImage: function () {
                var t = this;
                return function (e, i, n, r) {
                    return t._pathToImage(e, i, n, r, t.dpr)
                }
            }
        }, y
    }),e("zrender/graphic/helper/smoothSpline", [gr, "../../core/vector"], function (t) {
        function e(t, e, i, n, r, a, o) {
            var s = .5 * (i - t), l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
        }

        var i = t("../../core/vector");
        return function (t, n) {
            for (var r = t[zn], a = [], o = 0, s = 1; r > s; s++)o += i.distance(t[s - 1], t[s]);
            var l = o / 2;
            l = r > l ? r : l;
            for (var s = 0; l > s; s++) {
                var c, u, h, d = s / (l - 1) * (n ? r : r - 1), f = Math.floor(d), p = d - f, v = t[f % r];
                n ? (c = t[(f - 1 + r) % r], u = t[(f + 1) % r], h = t[(f + 2) % r]) : (c = t[0 === f ? f : f - 1], u = t[f > r - 2 ? r - 1 : f + 1], h = t[f > r - 3 ? r - 1 : f + 2]);
                var g = p * p, m = p * g;
                a.push([e(c[0], v[0], u[0], h[0], p, g, m), e(c[1], v[1], u[1], h[1], p, g, m)])
            }
            return a
        }
    }),e("zrender/core/GestureMgr", [gr], function () {
        function t(t) {
            var e = t[1][0] - t[0][0], i = t[1][1] - t[0][1];
            return Math.sqrt(e * e + i * i)
        }

        function e(t) {
            return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
        }

        var i = function () {
            this._track = []
        };
        i[ir] = {
            constructor: i, recognize: function (t, e) {
                return this._doTrack(t, e), this._recognize(t)
            }, clear: function () {
                return this._track[zn] = 0, this
            }, _doTrack: function (t, e) {
                var i = t.touches;
                if (i) {
                    for (var n = {points: [], touches: [], target: e, event: t}, r = 0, a = i[zn]; a > r; r++) {
                        var o = i[r];
                        n[V].push([o.clientX, o.clientY]), n.touches.push(o)
                    }
                    this._track.push(n)
                }
            }, _recognize: function (t) {
                for (var e in n)if (n.hasOwnProperty(e)) {
                    var i = n[e](this._track, t);
                    if (i)return i
                }
            }
        };
        var n = {
            pinch: function (i, n) {
                var r = i[zn];
                if (r) {
                    var a = (i[r - 1] || {})[V], o = (i[r - 2] || {})[V] || a;
                    if (o && o[zn] > 1 && a && a[zn] > 1) {
                        var s = t(a) / t(o);
                        !isFinite(s) && (s = 1), n.pinchScale = s;
                        var l = e(a);
                        return n.pinchX = l[0], n.pinchY = l[1], {type: "pinch", target: i[0][Sn], event: n}
                    }
                }
            }
        };
        return i
    }),e("echarts/coord/geo/Region", [gr, "zrender/contain/polygon", X, "zrender/core/bbox", ar], function (t) {
        function e(t, e, i) {
            if (this.name = t, this.contours = e, i)i = [i[0], i[1]]; else {
                var n = this[Qi]();
                i = [n.x + n.width / 2, n.y + n[Fn] / 2]
            }
            this[ji] = i
        }

        var i = t("zrender/contain/polygon"), n = t(X), r = t("zrender/core/bbox"), a = t(ar);
        return e[ir] = {
            constructor: e, getBoundingRect: function () {
                var t = this._rect;
                if (t)return t;
                for (var e = Number.MAX_VALUE, i = [e, e], o = [-e, -e], s = [], l = [], c = this.contours, u = 0; u < c[zn]; u++)r.fromPoints(c[u], s, l), a.min(i, i, s), a.max(o, o, l);
                return 0 === u && (i[0] = i[1] = o[0] = o[1] = 0), this._rect = new n(i[0], i[1], o[0] - i[0], o[1] - i[1])
            }, contain: function (t) {
                var e = this[Qi](), n = this.contours;
                if (e[mi](t[0], t[1]))for (var r = 0, a = n[zn]; a > r; r++)if (i[mi](n[r], t[0], t[1]))return !0;
                return !1
            }, transformTo: function (t, e, i, r) {
                var o = this[Qi](), s = o.width / o[Fn];
                i ? r || (r = i / s) : i = s * r;
                for (var l = new n(t, e, i, r), c = o.calculateTransform(l), u = this.contours, h = 0; h < u[zn]; h++)for (var d = 0; d < u[h][zn]; d++)a[J](u[h][d], u[h][d], c);
                o = this._rect, o.copy(l), this[ji] = [o.x + o.width / 2, o.y + o[Fn] / 2]
            }
        }, e
    }),e("zrender/contain/polygon", [gr, "./windingLine"], function (t) {
        function e(t, e) {
            return Math.abs(t - e) < r
        }

        function i(t, i, r) {
            var a = 0, o = t[0];
            if (!o)return !1;
            for (var s = 1; s < t[zn]; s++) {
                var l = t[s];
                a += n(o[0], o[1], l[0], l[1], i, r), o = l
            }
            var c = t[0];
            return e(o[0], c[0]) && e(o[1], c[1]) || (a += n(o[0], o[1], c[0], c[1], i, r)), 0 !== a
        }

        var n = t("./windingLine"), r = 1e-8;
        return {contain: i}
    }),e("echarts/coord/cartesian/axisLabelInterval", [gr, vr, "../axisHelper"], function (t) {
        var e = t(vr), i = t("../axisHelper");
        return function (t) {
            var n = t.model, r = n[Jn](A), a = r.get(Q);
            return t.type !== be || "auto" !== a ? "auto" === a ? 0 : a : i.getAxisLabelInterval(e.map(t.scale[oe](), t[te], t), n[pe](), r[Jn](nn)[tn](), t.isHorizontal())
        }
    }),e("zrender/Layer", [gr, "./core/util", "./config"], function (t) {
        function e() {
            return !1
        }

        function i(t, e, i, n) {
            var r = document[Fi](e), a = i[Kn](), o = i[Yn](), s = r.style;
            return s[Ui] = "absolute", s.left = 0, s.top = 0, s.width = a + "px", s[Fn] = o + "px", r.width = a * n, r[Fn] = o * n, r.setAttribute("data-zr-dom-id", t), r
        }

        var n = t("./core/util"), r = t("./config"), a = function (t, a, o) {
            var s;
            o = o || r.devicePixelRatio, typeof t === er ? s = i(t, tr, a, o) : n[Bn](t) && (s = t, t = s.id), this.id = t, this.dom = s;
            var l = s.style;
            l && (s.onselectstart = e, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)"), this.domBack = null, this.ctxBack = null, this.painter = a, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = o
        };
        return a[ir] = {
            constructor: a, elCount: 0, __dirty: !0, initContext: function () {
                this.ctx = this.dom[Zi]("2d");
                var t = this.dpr;
                1 != t && this.ctx.scale(t, t)
            }, createBackBuffer: function () {
                var t = this.dpr;
                this.domBack = i("back-" + this.id, tr, this.painter, t), this.ctxBack = this.domBack[Zi]("2d"), 1 != t && this.ctxBack.scale(t, t)
            }, resize: function (t, e) {
                var i = this.dpr, n = this.dom, r = n.style, a = this.domBack;
                r.width = t + "px", r[Fn] = e + "px", n.width = t * i, n[Fn] = e * i, 1 != i && this.ctx.scale(i, i), a && (a.width = t * i, a[Fn] = e * i, 1 != i && this.ctxBack.scale(i, i))
            }, clear: function (t) {
                var e = this.dom, i = this.ctx, n = e.width, r = e[Fn], a = this.clearColor, o = this.motionBlur && !t, s = this.lastFrameAlpha, l = this.dpr;
                if (o && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / l, r / l)), i.clearRect(0, 0, n / l, r / l), a && (i.save(), i.fillStyle = this.clearColor, i.fillRect(0, 0, n / l, r / l), i.restore()), o) {
                    var c = this.domBack;
                    i.save(), i.globalAlpha = s, i.drawImage(c, 0, 0, n / l, r / l), i.restore()
                }
            }
        }, a
    }),e("zrender/graphic/helper/smoothBezier", [gr, "../../core/vector"], function (t) {
        var e = t("../../core/vector"), i = e.min, n = e.max, r = e.scale, a = e.distance, o = e.add;
        return function (t, s, l, c) {
            var u, h, d, f, p = [], v = [], g = [], m = [];
            if (c) {
                d = [1 / 0, 1 / 0], f = [-1 / 0, -1 / 0];
                for (var y = 0, x = t[zn]; x > y; y++)i(d, d, t[y]), n(f, f, t[y]);
                i(d, d, c[0]), n(f, f, c[1])
            }
            for (var y = 0, x = t[zn]; x > y; y++) {
                var _ = t[y];
                if (l)u = t[y ? y - 1 : x - 1], h = t[(y + 1) % x]; else {
                    if (0 === y || y === x - 1) {
                        p.push(e.clone(t[y]));
                        continue
                    }
                    u = t[y - 1], h = t[y + 1]
                }
                e.sub(v, h, u), r(v, v, s);
                var w = a(_, u), b = a(_, h), M = w + b;
                0 !== M && (w /= M, b /= M), r(g, v, -w), r(m, v, b);
                var S = o([], _, g), A = o([], _, m);
                c && (n(S, S, d), i(S, S, f), n(A, A, d), i(A, A, f)), p.push(S), p.push(A)
            }
            return l && p.push(p.shift()), p
        }
    }),e("echarts/chart/helper/LinePath", [gr, vi, ar], function (t) {
        function e(t) {
            return null == t.cpx1 || null == t.cpy1
        }

        var i = t(vi), n = t(ar), r = i.Line[ir], o = i.BezierCurve[ir];
        return i.extendShape({
            type: "ec-line",
            style: {stroke: "#000", fill: null},
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null},
            buildPath: function (t, i) {
                (e(i) ? r : o)[a](t, i)
            },
            pointAt: function (t) {
                return e(this.shape) ? r.pointAt.call(this, t) : o.pointAt.call(this, t)
            },
            tangentAt: function (t) {
                var i = this.shape, r = e(i) ? [i.x2 - i.x1, i.y2 - i.y1] : o.tangentAt.call(this, t);
                return n[gi](r, r)
            }
        })
    }),e("echarts/util/symbol", [gr, "./graphic", X], function (t) {
        var e = t("./graphic"), o = t(X), s = e.extendShape({
            type: "triangle",
            shape: {cx: 0, cy: 0, width: 0, height: 0},
            buildPath: function (t, e) {
                var r = e.cx, a = e.cy, o = e.width / 2, s = e[Fn] / 2;
                t[d](r, a - s), t[n](r + o, a + s), t[n](r - o, a + s), t[i]()
            }
        }), l = e.extendShape({
            type: "diamond", shape: {cx: 0, cy: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var r = e.cx, a = e.cy, o = e.width / 2, s = e[Fn] / 2;
                t[d](r, a - s), t[n](r + o, a), t[n](r, a + s), t[n](r - o, a), t[i]()
            }
        }), c = e.extendShape({
            type: "pin", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var n = e.x, a = e.y, o = e.width / 5 * 3, s = Math.max(o, e[Fn]), l = o / 2, c = l * l / (s - l), u = a - s + l + c, h = Math.asin(c / l), d = Math.cos(h) * l, f = Math.sin(h), p = Math.cos(h);
                t.arc(n, u, l, Math.PI - h, 2 * Math.PI + h);
                var v = .6 * l, g = .7 * l;
                t[r](n + d - f * v, u + c + p * v, n, a - g, n, a), t[r](n, a - g, n - d + f * v, u + c + p * v, n - d, u + c), t[i]()
            }
        }), u = e.extendShape({
            type: "arrow", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
                var r = e[Fn], a = e.width, o = e.x, s = e.y, l = a / 3 * 2;
                t[d](o, s), t[n](o + l, s + r), t[n](o, s + r / 4 * 3), t[n](o - l, s + r), t[n](o, s), t[i]()
            }
        }), h = {
            line: e.Line,
            rect: e.Rect,
            roundRect: e.Rect,
            square: e.Rect,
            circle: e[y],
            diamond: l,
            pin: c,
            arrow: u,
            triangle: s
        }, f = {
            line: function (t, e, i, n, r) {
                r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2
            }, rect: function (t, e, i, n, r) {
                r.x = t, r.y = e, r.width = i, r[Fn] = n
            }, roundRect: function (t, e, i, n, r) {
                r.x = t, r.y = e, r.width = i, r[Fn] = n, r.r = Math.min(i, n) / 4
            }, square: function (t, e, i, n, r) {
                var a = Math.min(i, n);
                r.x = t, r.y = e, r.width = a, r[Fn] = a
            }, circle: function (t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2
            }, diamond: function (t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[Fn] = n
            }, pin: function (t, e, i, n, r) {
                r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[Fn] = n
            }, arrow: function (t, e, i, n, r) {
                r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[Fn] = n
            }, triangle: function (t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[Fn] = n
            }
        }, p = {};
        for (var v in h)p[v] = new h[v];
        var g = e.extendShape({
            type: "symbol",
            shape: {symbolType: "", x: 0, y: 0, width: 0, height: 0},
            beforeBrush: function () {
                var t = this.style, e = this.shape;
                "pin" === e.symbolType && t.textPosition === si && (t.textPosition = ["50%", "40%"], t[en] = ji, t.textVerticalAlign = Xi)
            },
            buildPath: function (t, e) {
                var i = e.symbolType, n = p[i];
                "none" !== e.symbolType && (n || (i = "rect", n = p[i]), f[i](e.x, e.y, e.width, e[Fn], n.shape), n[a](t, n.shape))
            }
        }), m = function (t) {
            if ("image" !== this.type) {
                var e = this.style, i = this.shape;
                i && "line" === i.symbolType ? e[Ne] = t : this.__isEmptyBrush ? (e[Ne] = t, e.fill = "#fff") : (e.fill && (e.fill = t), e[Ne] && (e[Ne] = t)), this.dirty()
            }
        }, x = {
            createSymbol: function (t, i, n, r, a, s) {
                var l = 0 === t[vn]("empty");
                l && (t = t.substr(5, 1)[nr]() + t.substr(6));
                var c;
                return c = 0 === t[vn]("image://") ? new e.Image({
                    style: {
                        image: t.slice(8),
                        x: i,
                        y: n,
                        width: r,
                        height: a
                    }
                }) : 0 === t[vn]("path://") ? e.makePath(t.slice(7), {}, new o(i, n, r, a)) : new g({
                    shape: {
                        symbolType: t,
                        x: i,
                        y: n,
                        width: r,
                        height: a
                    }
                }), c.__isEmptyBrush = l, c.setColor = m, c.setColor(s), c
            }
        };
        return x
    }),e("echarts/coord/cartesian/AxisModel", [gr, c, vr, "../axisModelCreator", "../axisModelCommonMixin"], function (t) {
        function e(t, e) {
            return e.type || (e.data ? be : "value")
        }

        var i = t(c), n = t(vr), r = t("../axisModelCreator"), a = i[On]({
            type: "cartesian2dAxis",
            axis: null,
            init: function () {
                a[Vi](this, "init", arguments), this._resetRange()
            },
            mergeOption: function () {
                a[Vi](this, zi, arguments), this._resetRange()
            },
            restoreData: function () {
                a[Vi](this, "restoreData", arguments), this._resetRange()
            },
            setRange: function (t, e) {
                this[Pi].rangeStart = t, this[Pi].rangeEnd = e
            },
            getMin: function () {
                var t = this[Pi];
                return null != t.rangeStart ? t.rangeStart : t.min
            },
            getMax: function () {
                var t = this[Pi];
                return null != t.rangeEnd ? t.rangeEnd : t.max
            },
            getNeedCrossZero: function () {
                var t = this[Pi];
                return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale
            },
            _resetRange: function () {
                this[Pi].rangeStart = this[Pi].rangeEnd = null
            }
        });
        n.merge(a[ir], t("../axisModelCommonMixin"));
        var o = {gridIndex: 0};
        return r("x", a, e, o), r("y", a, e, o), a
    }),e("echarts/chart/bar/barItemStyle", [gr, "../../model/mixin/makeStyleMapper"], function (t) {
        return {getBarItemStyle: t("../../model/mixin/makeStyleMapper")([["fill", "color"], [Ne, Ge], [m, "borderWidth"], [Ne, "barBorderColor"], [m, "barBorderWidth"], [Hi], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]])}
    }),e("echarts/component/axis/AxisView", [gr, vr, vi, "./AxisBuilder", Ri], function (t) {
        function e(t, e) {
            function i(t) {
                var e = n[he](t);
                return e.toGlobalCoord(e[te](0))
            }

            var n = t[Ni], r = e.axis, a = {}, o = r[Ui], s = r.onZero ? "onZero" : o, c = r.dim, u = n[Ci](), h = [u.x, u.x + u.width, u.y, u.y + u[Fn]], d = {
                x: {
                    top: h[2],
                    bottom: h[3]
                }, y: {left: h[0], right: h[1]}
            };
            d.x.onZero = Math.max(Math.min(i("y"), d.x[Hn]), d.x.top), d.y.onZero = Math.max(Math.min(i("x"), d.y.right), d.y.left), a[Ui] = ["y" === c ? d.y[s] : h[0], "x" === c ? d.x[s] : h[3]];
            var f = {x: 0, y: 1};
            a[Ye] = Math.PI / 2 * f[c];
            var p = {top: -1, bottom: 1, left: -1, right: 1};
            a.labelDirection = a.tickDirection = a.nameDirection = p[o], r.onZero && (a.labelOffset = d[c][o] - d[c].onZero), e[Jn](C).get(si) && (a.tickDirection = -a.tickDirection), e[Jn](A).get(si) && (a.labelDirection = -a.labelDirection);
            var v = e[Jn](A).get(l);
            return a.labelRotation = "top" === s ? -v : v, a.labelInterval = r.getLabelInterval(), a.z2 = 1, a
        }

        var i = t(vr), n = t(vi), r = t("./AxisBuilder"), a = r.ifIgnoreOnTick, o = r.getInterval, s = [T, A, C, "axisName"], c = ["splitLine", "splitArea"], u = t(Ri)[cn]({
            type: "axis",
            render: function (t, n) {
                if (this.group[rn](), t.get("show")) {
                    var a = n[ve]("grid", t.get("gridIndex")), o = e(a, t), l = new r(t, o);
                    i.each(s, l.add, l), this.group.add(l.getGroup()), i.each(c, function (e) {
                        t.get(e + ".show") && this["_" + e](t, a, o.labelInterval)
                    }, this)
                }
            },
            _splitLine: function (t, e, r) {
                var s = t.axis, l = t[Jn]("splitLine"), c = l[Jn](lr), u = c.get("width"), h = c.get("color"), d = o(l, r);
                h = i[gn](h) ? h : [h];
                for (var f = e[Ni][Ci](), p = s.isHorizontal(), v = [], g = 0, m = s.getTicksCoords(), y = [], x = [], _ = 0; _ < m[zn]; _++)if (!a(s, _, d)) {
                    var w = s.toGlobalCoord(m[_]);
                    p ? (y[0] = w, y[1] = f.y, x[0] = w, x[1] = f.y + f[Fn]) : (y[0] = f.x, y[1] = w, x[0] = f.x + f.width, x[1] = w);
                    var b = g++ % h[zn];
                    v[b] = v[b] || [], v[b].push(new n.Line(n.subPixelOptimizeLine({
                        shape: {
                            x1: y[0],
                            y1: y[1],
                            x2: x[0],
                            y2: x[1]
                        }, style: {lineWidth: u}, silent: !0
                    })))
                }
                for (var M = c[Ue](), _ = 0; _ < v[zn]; _++)this.group.add(n.mergePath(v[_], {
                    style: i[Vn]({stroke: h[_ % h[zn]]}, M),
                    silent: !0
                }))
            },
            _splitArea: function (t, e, r) {
                var s = t.axis, l = t[Jn]("splitArea"), c = l[Jn]("areaStyle"), u = c.get("color"), h = e[Ni][Ci](), d = s.getTicksCoords(), f = s.toGlobalCoord(d[0]), p = s.toGlobalCoord(d[0]), v = [], g = 0, m = o(l, r);
                u = i[gn](u) ? u : [u];
                for (var y = 1; y < d[zn]; y++)if (!a(s, y, m)) {
                    var x, _, w, b, M = s.toGlobalCoord(d[y]);
                    s.isHorizontal() ? (x = f, _ = h.y, w = M - x, b = h[Fn]) : (x = h.x, _ = p, w = h.width, b = M - _);
                    var S = g++ % u[zn];
                    v[S] = v[S] || [], v[S].push(new n.Rect({
                        shape: {x: x, y: _, width: w, height: b},
                        silent: !0
                    })), f = x + w, p = _ + b
                }
                for (var A = c[z](), y = 0; y < v[zn]; y++)this.group.add(n.mergePath(v[y], {
                    style: i[Vn]({fill: u[y % u[zn]]}, A),
                    silent: !0
                }))
            }
        });
        u[On]({type: "xAxis"}), u[On]({type: "yAxis"})
    }),e("echarts/component/axis/AxisBuilder", [gr, vr, vi, re, Be], function (t) {
        function e(t) {
            var e = {componentType: t[w]};
            return e[t[w] + "Index"] = t.componentIndex, e
        }

        function i(t, e, i) {
            var n, r, a = c(e - t[Ye]);
            return u(a) ? (r = i > 0 ? "top" : Hn, n = ji) : u(a - h) ? (r = i > 0 ? Hn : "top", n = ji) : (r = Xi, n = a > 0 && h > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), {
                rotation: a,
                textAlign: n,
                verticalAlign: r
            }
        }

        function n(t, e, i) {
            var n, r, a = c(-t[Ye]), o = i[0] > i[1], s = "start" === e && !o || "start" !== e && o;
            return u(a - h / 2) ? (r = s ? Hn : "top", n = ji) : u(a - 1.5 * h) ? (r = s ? "top" : Hn, n = ji) : (r = Xi, n = 1.5 * h > a && a > h / 2 ? s ? "left" : "right" : s ? "right" : "left"), {
                rotation: a,
                textAlign: n,
                verticalAlign: r
            }
        }

        var r = t(vr), a = t(vi), o = t(re), s = t(Be), c = s.remRadian, u = s.isRadianAroundZero, h = Math.PI, d = function (t, e) {
            this.opt = e, this.axisModel = t, r[Vn](e, {
                labelOffset: 0,
                nameDirection: 1,
                tickDirection: 1,
                labelDirection: 1,
                silent: !0
            }), this.group = new a.Group({position: e[Ui].slice(), rotation: e[Ye]})
        };
        d[ir] = {
            constructor: d, hasBuilder: function (t) {
                return !!f[t]
            }, add: function (t) {
                f[t].call(this)
            }, getGroup: function () {
                return this.group
            }
        };
        var f = {
            axisLine: function () {
                var t = this.opt, e = this.axisModel;
                if (e.get("axisLine.show")) {
                    var i = this.axisModel.axis[we]();
                    this.group.add(new a.Line({
                        shape: {x1: i[0], y1: 0, x2: i[1], y2: 0},
                        style: r[On]({lineCap: "round"}, e[Jn]("axisLine.lineStyle")[Ue]()),
                        strokeContainThreshold: t.strokeContainThreshold,
                        silent: !!t.axisLineSilent,
                        z2: 1
                    }))
                }
            }, axisTick: function () {
                var t = this.axisModel;
                if (t.get("axisTick.show")) {
                    for (var e = t.axis, i = t[Jn](C), n = this.opt, r = i[Jn](lr), o = i.get(zn), s = v(i, n.labelInterval), l = e.getTicksCoords(), c = [], u = 0; u < l[zn]; u++)if (!p(e, u, s)) {
                        var h = l[u];
                        c.push(new a.Line(a.subPixelOptimizeLine({
                            shape: {x1: h, y1: 0, x2: h, y2: n.tickDirection * o},
                            style: {lineWidth: r.get("width")},
                            silent: !0
                        })))
                    }
                    this.group.add(a.mergePath(c, {style: r[Ue](), z2: 2, silent: !0}))
                }
            }, axisLabel: function () {
                function t(t, e) {
                    var i = t && t[Qi]().clone(), n = e && e[Qi]().clone();
                    return i && n ? (i[J](t.getLocalTransform()), n[J](e.getLocalTransform()), i.intersect(n)) : void 0
                }

                var n = this.axisModel;
                if (n.get("axisLabel.show")) {
                    var r = this.opt, s = n.axis, c = n[Jn](A), u = c[Jn](nn), d = c.get("margin"), f = s.scale[oe](), v = n[pe](), g = r.labelRotation;
                    null == g && (g = c.get(l) || 0), g = g * h / 180;
                    for (var m = i(r, g, r.labelDirection), y = n.get("data"), x = [], _ = n.get("silent"), w = 0; w < f[zn]; w++)if (!p(s, w, r.labelInterval)) {
                        var b = u;
                        y && y[w] && y[w][nn] && (b = new o(y[w][nn], u, n[j]));
                        var M = b[$i](), S = s[te](f[w]), C = [S, r.labelOffset + r.labelDirection * d], T = s.scale[ae](f[w]), L = new a.Text({
                            style: {
                                text: v[w],
                                textAlign: b.get("align", !0) || m[en],
                                textVerticalAlign: b.get("baseline", !0) || m.verticalAlign,
                                textFont: b[tn](),
                                fill: typeof M === fn ? M(T) : M
                            }, position: C, rotation: m[Ye], silent: _, z2: 10
                        });
                        L.eventData = e(n), L.eventData.targetType = A, L.eventData.value = T, x.push(L), this.group.add(L)
                    }
                    if (s.type !== be) {
                        if (n.getMin ? n.getMin() : n.get("min")) {
                            var k = x[0], D = x[1];
                            t(k, D) && (k[Wn] = !0)
                        }
                        if (n.getMax ? n.getMax() : n.get("max")) {
                            var I = x[x[zn] - 1], P = x[x[zn] - 2];
                            t(P, I) && (I[Wn] = !0)
                        }
                    }
                }
            }, axisName: function () {
                var t = this.opt, r = this.axisModel, o = this.opt.axisName;
                if (null == o && (o = r.get("name")), o) {
                    var s, l = r.get("nameLocation"), c = t.nameDirection, u = r[Jn]("nameTextStyle"), h = r.get("nameGap") || 0, d = this.axisModel.axis[we](), f = d[0] > d[1] ? -1 : 1, p = ["start" === l ? d[0] - f * h : "end" === l ? d[1] + f * h : (d[0] + d[1]) / 2, l === Xi ? t.labelOffset + c * h : 0];
                    s = l === Xi ? i(t, t[Ye], c) : n(t, l, d);
                    var v = new a.Text({
                        style: {
                            text: o,
                            textFont: u[tn](),
                            fill: u[$i]() || r.get("axisLine.lineStyle.color"),
                            textAlign: s[en],
                            textVerticalAlign: s.verticalAlign
                        }, position: p, rotation: s[Ye], silent: r.get("silent"), z2: 1
                    });
                    v.eventData = e(r), v.eventData.targetType = "axisName", v.eventData.name = o, this.group.add(v)
                }
            }
        }, p = d.ifIgnoreOnTick = function (t, e, i) {
            var n, r = t.scale;
            return r.type === se && (typeof i === fn ? (n = r[oe]()[e], !i(n, r[ae](n))) : e % (i + 1))
        }, v = d.getInterval = function (t, e) {
            var i = t.get(Q);
            return (null == i || "auto" == i) && (i = e), i
        };
        return d
    }),e("echarts/preprocessor/helper/compatStyle", [gr, vr], function (t) {
        function e(t) {
            var e = t && t[ln];
            e && i.each(n, function (n) {
                var r = e[Li], a = e[Ti];
                r && r[n] && (t[n] = t[n] || {}, t[n][Li] ? i.merge(t[n][Li], r[n]) : t[n][Li] = r[n], r[n] = null), a && a[n] && (t[n] = t[n] || {}, t[n][Ti] ? i.merge(t[n][Ti], a[n]) : t[n][Ti] = a[n], a[n] = null)
            })
        }

        var i = t(vr), n = ["areaStyle", lr, "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
        return function (t) {
            if (t) {
                e(t), e(t.markPoint), e(t.markLine);
                var n = t.data;
                if (n) {
                    for (var r = 0; r < n[zn]; r++)e(n[r]);
                    var a = t.markPoint;
                    if (a && a.data)for (var o = a.data, r = 0; r < o[zn]; r++)e(o[r]);
                    var s = t.markLine;
                    if (s && s.data)for (var l = s.data, r = 0; r < l[zn]; r++)i[gn](l[r]) ? (e(l[r][0]), e(l[r][1])) : e(l[r])
                }
            }
        }
    }),e("echarts/chart/pie/labelLayout", [gr, "zrender/contain/text"], function (t) {
        function e(t, e, i, n, r, a, o) {
            function s(e, i, n) {
                for (var r = e; i > r; r++)if (t[r].y += n, r > e && i > r + 1 && t[r + 1].y > t[r].y + t[r][Fn])return void l(r, n / 2);
                l(i - 1, n / 2)
            }

            function l(e, i) {
                for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1][Fn])); n--);
            }

            function c(t, e, i, n, r, a) {
                for (var o = a > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t[zn]; l > s; s++)if (t[s][Ui] !== ji) {
                    var c = Math.abs(t[s].y - n), u = t[s].len, h = t[s].len2, d = r + u > c ? Math.sqrt((r + u + h) * (r + u + h) - c * c) : Math.abs(t[s].x - i);
                    e && d >= o && (d = o - 10), !e && o >= d && (d = o + 10), t[s].x = i + d * a, o = d
                }
            }

            t.sort(function (t, e) {
                return t.y - e.y
            });
            for (var u, h = 0, d = t[zn], f = [], p = [], v = 0; d > v; v++)u = t[v].y - h, 0 > u && s(v, d, -u, r), h = t[v].y + t[v][Fn];
            0 > o - h && l(d - 1, h - o);
            for (var v = 0; d > v; v++)t[v].y >= i ? p.push(t[v]) : f.push(t[v]);
            c(f, !1, e, i, n, r), c(p, !0, e, i, n, r)
        }

        function i(t, i, n, r, a, o) {
            for (var s = [], l = [], c = 0; c < t[zn]; c++)t[c].x < i ? s.push(t[c]) : l.push(t[c]);
            e(l, i, n, r, 1, a, o), e(s, i, n, r, -1, a, o);
            for (var c = 0; c < t[zn]; c++) {
                var u = t[c].linePoints;
                if (u) {
                    var h = u[1][0] - u[2][0];
                    u[2][0] = t[c].x < i ? t[c].x + 3 : t[c].x - 3, u[1][1] = u[2][1] = t[c].y, u[1][0] = u[2][0] + h
                }
            }
        }

        var n = t("zrender/contain/text");
        return function (t, e, r, a) {
            var o, s, c = t[ur](), u = [], h = !1;
            c.each(function (i) {
                var r, a, d, f, p = c[fi](i), v = c[Ai](i), g = v[Jn](Xe), m = g.get(Ui) || v.get("label.emphasis.position"), y = v[Jn]("labelLine.normal"), x = y.get(zn), _ = y.get("length2"), w = (p[di] + p.endAngle) / 2, b = Math.cos(w), M = Math.sin(w);
                o = p.cx, s = p.cy;
                var S = m === si || "inner" === m;
                if (m === ji)r = p.cx, a = p.cy, f = ji; else {
                    var A = (S ? (p.r + p.r0) / 2 * b : p.r * b) + o, C = (S ? (p.r + p.r0) / 2 * M : p.r * M) + s;
                    if (r = A + 3 * b, a = C + 3 * M, !S) {
                        var T = A + b * (x + e - p.r), L = C + M * (x + e - p.r), k = T + (0 > b ? -1 : 1) * _, D = L;
                        r = k + (0 > b ? -5 : 5), a = D, d = [[A, C], [T, L], [k, D]]
                    }
                    f = S ? ji : b > 0 ? "left" : "right"
                }
                var I = g[Jn](nn)[tn](), P = g.get(l) ? 0 > b ? -w + Math.PI : -w : 0, z = t[ai](i, Li) || c[xi](i), V = n[Qi](z, I, f, "top");
                h = !!P, p.label = {
                    x: r,
                    y: a,
                    position: m,
                    height: V[Fn],
                    len: x,
                    len2: _,
                    linePoints: d,
                    textAlign: f,
                    verticalAlign: "middle",
                    font: I,
                    rotation: P
                }, S || u.push(p.label)
            }), !h && t.get("avoidLabelOverlap") && i(u, o, s, e, r, a)
        }
    }),e("echarts/chart/line/poly", [gr, "zrender/graphic/Path", ar], function (t) {
        function e(t) {
            return isNaN(t[0]) || isNaN(t[1])
        }

        function a(t, i, a, o, s, m, y, x, _, w, b) {
            for (var M = 0, S = a, A = 0; o > A; A++) {
                var C = i[S];
                if (S >= s || 0 > S)break;
                if (e(C)) {
                    if (b) {
                        S += m;
                        continue
                    }
                    break
                }
                if (S === a)t[m > 0 ? d : n](C[0], C[1]), f(v, C); else if (_ > 0) {
                    var T = S + m, L = i[T];
                    if (b)for (; L && e(i[T]);)T += m, L = i[T];
                    var k = .5, D = i[M], L = i[T];
                    if (!L || e(L))f(g, C); else {
                        e(L) && !b && (L = C), l.sub(p, L, D);
                        var I, P;
                        if ("x" === w || "y" === w) {
                            var z = "x" === w ? 0 : 1;
                            I = Math.abs(C[z] - D[z]), P = Math.abs(C[z] - L[z])
                        } else I = l.dist(C, D), P = l.dist(C, L);
                        k = P / (P + I), h(g, C, p, -_ * (1 - k))
                    }
                    c(v, v, x), u(v, v, y), c(g, g, x), u(g, g, y), t[r](v[0], v[1], g[0], g[1], C[0], C[1]), h(v, C, p, _ * k)
                } else t[n](C[0], C[1]);
                M = S, S += m
            }
            return A
        }

        function o(t, e) {
            var i = [1 / 0, 1 / 0], n = [-1 / 0, -1 / 0];
            if (e)for (var r = 0; r < t[zn]; r++) {
                var a = t[r];
                a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1])
            }
            return {min: e ? i : n, max: e ? n : i}
        }

        var s = t("zrender/graphic/Path"), l = t(ar), c = l.min, u = l.max, h = l.scaleAndAdd, f = l.copy, p = [], v = [], g = [];
        return {
            Polyline: s[On]({
                type: "ec-polyline",
                shape: {points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1},
                style: {fill: null, stroke: "#000"},
                buildPath: function (t, i) {
                    var n = i[V], r = 0, s = n[zn], l = o(n, i.smoothConstraint);
                    if (i.connectNulls) {
                        for (; s > 0 && e(n[s - 1]); s--);
                        for (; s > r && e(n[r]); r++);
                    }
                    for (; s > r;)r += a(t, n, r, s, s, 1, l.min, l.max, i.smooth, i.smoothMonotone, i.connectNulls) + 1
                }
            }),
            Polygon: s[On]({
                type: "ec-polygon",
                shape: {
                    points: [],
                    stackedOnPoints: [],
                    smooth: 0,
                    stackedOnSmooth: 0,
                    smoothConstraint: !0,
                    smoothMonotone: null,
                    connectNulls: !1
                },
                buildPath: function (t, n) {
                    var r = n[V], s = n.stackedOnPoints, l = 0, c = r[zn], u = n.smoothMonotone, h = o(r, n.smoothConstraint), d = o(s, n.smoothConstraint);
                    if (n.connectNulls) {
                        for (; c > 0 && e(r[c - 1]); c--);
                        for (; c > l && e(r[l]); l++);
                    }
                    for (; c > l;) {
                        var f = a(t, r, l, c, c, 1, h.min, h.max, n.smooth, u, n.connectNulls);
                        a(t, s, l + f - 1, f, c, -1, d.min, d.max, n.stackedOnSmooth, u, n.connectNulls), l += f + 1, t[i]()
                    }
                }
            })
        }
    }),e("echarts/chart/helper/LargeSymbolDraw", [gr, vi, E, vr], function (t) {
        function e() {
            this.group = new i.Group, this._symbolEl = new o({silent: !0})
        }

        var i = t(vi), n = t(E), r = t(vr), o = i.extendShape({
            shape: {points: null, sizes: null},
            symbolProxy: null,
            buildPath: function (t, e) {
                for (var i = e[V], n = e.sizes, r = this.symbolProxy, o = r.shape, s = 0; s < i[zn]; s++) {
                    var l = i[s], c = n[s];
                    c[0] < 4 ? t.rect(l[0] - c[0] / 2, l[1] - c[1] / 2, c[0], c[1]) : (o.x = l[0] - c[0] / 2, o.y = l[1] - c[1] / 2, o.width = c[0], o[Fn] = c[1], r[a](t, o))
                }
            }
        }), s = e[ir];
        return s[li] = function (t) {
            this.group[rn]();
            var e = this._symbolEl, i = t[ri];
            e[ii]({
                points: t[K](t[fi]), sizes: t[K](function (e) {
                    var i = t[Mi](e, xe);
                    return r[gn](i) || (i = [i, i]), i
                })
            }), e.symbolProxy = n[O](t[G](_e), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor, e[ti](i[Jn](ie)[Wi](["color"]));
            var a = t[G]("color");
            a && e.setColor(a), this.group.add(this._symbolEl)
        }, s[Nn] = function (t) {
            var e = t[ur]();
            this._symbolEl[ii]({points: e[K](e[fi])})
        }, s[En] = function () {
            this.group[rn]()
        }, e
    }),e("echarts/chart/helper/Symbol", [gr, vr, E, vi, Be], function (t) {
        function e(t) {
            return r[gn](t) || (t = [+t, +t]), t
        }

        function i(t, e) {
            o.Group.call(this), this[li](t, e)
        }

        function n(t, e) {
            this[U].drift(t, e)
        }

        var r = t(vr), a = t(E), o = t(vi), s = t(Be), l = i[ir];
        l._createSymbol = function (t, i, r) {
            this[rn]();
            var s = i[ri], l = i[Mi](r, "color"), c = a[O](t, -.5, -.5, 1, 1, l);
            c.attr({z2: 100, culling: !0, scale: [0, 0]}), c.drift = n;
            var u = e(i[Mi](r, xe));
            o[Ze](c, {scale: u}, s, r), this._symbolType = t, this.add(c)
        }, l.stopSymbolAnimation = function (t) {
            this[ni](0)[Un](t)
        }, l.getScale = function () {
            return this[ni](0).scale
        }, l.highlight = function () {
            this[ni](0)[Pn](Ti)
        }, l.downplay = function () {
            this[ni](0)[Pn](Li)
        }, l.setZ = function (t, e) {
            var i = this[ni](0);
            i[xn] = t, i.z = e
        }, l.setDraggable = function (t) {
            var e = this[ni](0);
            e[_] = t, e.cursor = t ? "move" : "pointer"
        }, l[li] = function (t, i) {
            var n = t[Mi](i, _e) || dr, r = t[ri], a = e(t[Mi](i, xe));
            if (n !== this._symbolType)this._createSymbol(n, t, i); else {
                var s = this[ni](0);
                o[ei](s, {scale: a}, r, i)
            }
            this._updateCommon(t, i, a), this._seriesModel = r
        };
        var c = [ln, Li], u = [ln, Ti], h = ["label", Li], d = ["label", Ti];
        return l._updateCommon = function (t, i, n) {
            var a = this[ni](0), l = t[ri], f = t[Ai](i), p = f[Jn](c), v = t[Mi](i, "color");
            "image" !== a.type && a[ti]({strokeNoScale: !0});
            var g = a.style, m = f[Jn](u)[Wi]();
            a[Ye] = (f[N]("symbolRotate") || 0) * Math.PI / 180 || 0;
            var y = f[N]("symbolOffset");
            if (y) {
                var x = a[Ui];
                x[0] = s[Ee](y[0], n[0]), x[1] = s[Ee](y[1], n[1])
            }
            a.setColor(v), r[On](g, p[Wi](["color"]));
            var _ = t[Mi](i, Hi);
            null != _ && (g[Hi] = _);
            for (var w, b, M = f[Jn](h), S = f[Jn](d), A = t[Te].slice(); A[zn] && (w = A.pop(), b = t.getDimensionInfo(w).type, b === se || "time" === b););
            null != w && M.get("show") ? (o.setText(g, M, v), g.text = r[oi](l[ai](i, Li), t.get(w, i))) : g.text = "", null != w && S[N]("show") ? (o.setText(m, S, v), m.text = r[oi](l[ai](i, Ti), t.get(w, i))) : m.text = "";
            var C = e(t[Mi](i, xe));
            if (a.off(Cn).off(An).off(Ti).off(Li), o[Ke](a, m), f[N]("hoverAnimation")) {
                var T = function () {
                    var t = C[1] / C[0];
                    this.animateTo({scale: [Math.max(1.1 * C[0], C[0] + 3), Math.max(1.1 * C[1], C[1] + 3 * t)]}, 400, "elasticOut")
                }, L = function () {
                    this.animateTo({scale: C}, 400, "elasticOut")
                };
                a.on(Cn, T).on(An, L).on(Ti, T).on(Li, L)
            }
        }, l.fadeOut = function (t) {
            var e = this[ni](0);
            e.off(Cn).off(An).off(Ti).off(Li), e.style.text = "", o[ei](e, {scale: [0, 0]}, this._seriesModel, this[Mn], t)
        }, r[on](i, o.Group), i
    }),e("echarts/chart/helper/whiskerBoxCommon", [gr, Bi, Oi, "../helper/WhiskerBoxDraw", vr], function (t) {
        function e(t) {
            return null == t.value ? t : t.value
        }

        var i = t(Bi), n = t(Oi), r = t("../helper/WhiskerBoxDraw"), a = t(vr), o = {
            _baseAxisDim: null,
            getInitialData: function (t, r) {
                var a, o, s = r[ve]("xAxis", this.get("xAxisIndex")), l = r[ve]("yAxis", this.get("yAxisIndex")), c = s.get("type"), u = l.get("type");
                c === be ? (t[Ce] = Ae, a = s.getCategories(), o = !0) : u === be ? (t[Ce] = f, a = l.getCategories(), o = !0) : t[Ce] = t[Ce] || Ae, this._baseAxisDim = t[Ce] === Ae ? "x" : "y";
                var h = t.data, d = this[Te] = ["base"][Gi](this.valueDimensions);
                n(d, h);
                var p = new i(d, this);
                return p[Ii](h, a ? a.slice() : null, function (t, i, n, r) {
                    var a = e(t);
                    return o ? "base" === i ? n : a[r - 1] : a[r]
                }), p
            },
            coordDimToDataDim: function (t) {
                var e = this.valueDimensions.slice(), i = ["base"], n = {
                    horizontal: {x: i, y: e},
                    vertical: {x: e, y: i}
                };
                return n[this.get(Ce)][t]
            },
            dataDimToCoordDim: function (t) {
                var e;
                return a.each(["x", "y"], function (i) {
                    var n = this[le](i);
                    a[vn](n, t) >= 0 && (e = i)
                }, this), e
            },
            getBaseAxis: function () {
                var t = this._baseAxisDim;
                return this[j][ve](t + "Axis", this.get(t + "AxisIndex")).axis
            }
        }, s = {
            init: function () {
                var t = this._whiskerBoxDraw = new r(this.getStyleUpdater());
                this.group.add(t.group)
            }, render: function (t) {
                this._whiskerBoxDraw[li](t[ur]())
            }, remove: function () {
                this._whiskerBoxDraw[En]()
            }
        };
        return {seriesModelMixin: o, viewMixin: s}
    }),e("echarts/coord/radar/RadarModel", [gr, "../axisDefault", re, vr, "../axisModelCommonMixin", Ri], function (t) {
        function e(t, e) {
            return a[Vn]({show: e}, t)
        }

        var i = t("../axisDefault"), n = i.valueAxis, r = t(re), a = t(vr), o = t("../axisModelCommonMixin"), s = t(Ri)[un]({
            type: "radar",
            optionUpdated: function () {
                var t = this.get(ue), e = this.get(S), i = this.get("scale"), n = this.get(T), s = this.get(C), l = this.get(A), c = this.get("name.textStyle"), u = this.get("name.show"), h = this.get("name.formatter"), d = this.get("nameGap"), f = a.map(this.get("indicator") || [], function (f) {
                    return null != f.max && f.max > 0 ? f.min = 0 : null != f.min && f.min < 0 && (f.max = 0), f = a.merge(a.clone(f), {
                        boundaryGap: t,
                        splitNumber: e,
                        scale: i,
                        axisLine: n,
                        axisTick: s,
                        axisLabel: l,
                        name: f.text,
                        nameLocation: "end",
                        nameGap: d,
                        nameTextStyle: c
                    }, !1), u || (f.name = ""), typeof h === er ? f.name = h[mn]("{value}", f.name) : typeof h === fn && (f.name = h(f.name, f)), a[On](new r(f, null, this[j]), o)
                }, this);
                this.getIndicatorModels = function () {
                    return f
                }
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                center: ["50%", "50%"],
                radius: "75%",
                startAngle: 90,
                name: {show: !0},
                boundaryGap: [0, 0],
                splitNumber: 5,
                nameGap: 15,
                scale: !1,
                shape: "polygon",
                axisLine: a.merge({lineStyle: {color: "#bbb"}}, n[T]),
                axisLabel: e(n[A], !1),
                axisTick: e(n[C], !1),
                splitLine: e(n.splitLine, !0),
                splitArea: e(n.splitArea, !0),
                indicator: []
            }
        });
        return s
    }),e("echarts/chart/line/lineAnimationDiff", [gr], function () {
        function t(t) {
            return t >= 0 ? 1 : -1
        }

        function e(e, i, n) {
            for (var r, a = e[Me](), o = e[ee](a), s = a.onZero ? 0 : o.scale[we]()[0], l = o.dim, c = "x" === l || l === Oe ? 1 : 0, u = i.stackedOn, h = i.get(l, n); u && t(u.get(l, n)) === t(h);) {
                r = u;
                break
            }
            var d = [];
            return d[c] = i.get(a.dim, n), d[1 - c] = r ? r.get(l, n, !0) : s, e[Se](d)
        }

        function i(t, e) {
            var i = [];
            return e.diff(t).add(function (t) {
                i.push({cmd: "+", idx: t})
            })[Gn](function (t, e) {
                i.push({cmd: "=", idx: e, idx1: t})
            })[En](function (t) {
                i.push({cmd: "-", idx: t})
            })[qe](), i
        }

        return function (t, n, r, a, o, s) {
            for (var l = i(t, n), c = [], u = [], h = [], d = [], f = [], p = [], v = [], g = s[Te], m = 0; m < l[zn]; m++) {
                var y = l[m], x = !0;
                switch (y.cmd) {
                    case"=":
                        var _ = t[fi](y.idx), w = n[fi](y.idx1);
                        (isNaN(_[0]) || isNaN(_[1])) && (_ = w.slice()), c.push(_), u.push(w), h.push(r[y.idx]), d.push(a[y.idx1]), v.push(n[Si](y.idx1));
                        break;
                    case"+":
                        var b = y.idx;
                        c.push(o[Se]([n.get(g[0], b, !0), n.get(g[1], b, !0)])), u.push(n[fi](b).slice()), h.push(e(o, n, b)), d.push(a[b]), v.push(n[Si](b));
                        break;
                    case"-":
                        var b = y.idx, M = t[Si](b);
                        M !== b ? (c.push(t[fi](b)), u.push(s[Se]([t.get(g[0], b, !0), t.get(g[1], b, !0)])), h.push(r[b]), d.push(e(s, t, b)), v.push(M)) : x = !1
                }
                x && (f.push(y), p.push(p[zn]))
            }
            p.sort(function (t, e) {
                return v[t] - v[e]
            });
            for (var S = [], A = [], C = [], T = [], L = [], m = 0; m < p[zn]; m++) {
                var b = p[m];
                S[m] = c[b], A[m] = u[b], C[m] = h[b], T[m] = d[b], L[m] = f[b]
            }
            return {current: S, next: A, stackedOnCurrent: C, stackedOnNext: T, status: L}
        }
    }),e("echarts/chart/helper/SymbolDraw", [gr, vi, "./Symbol"], function (t) {
        function e(t) {
            this.group = new n.Group, this._symbolCtor = t || r
        }

        function i(t, e, i) {
            var n = t[fi](e);
            return !(!n || isNaN(n[0]) || isNaN(n[1]) || i && i(e) || "none" === t[Mi](e, _e))
        }

        var n = t(vi), r = t("./Symbol"), a = e[ir];
        return a[li] = function (t, e) {
            var r = this.group, a = t[ri], o = this._data, s = this._symbolCtor;
            t.diff(o).add(function (n) {
                var a = t[fi](n);
                if (i(t, n, e)) {
                    var o = new s(t, n);
                    o.attr(Ui, a), t[He](n, o), r.add(o)
                }
            })[Gn](function (l, c) {
                var u = o[pi](c), h = t[fi](l);
                return i(t, l, e) ? (u ? (u[li](t, l), n[ei](u, {position: h}, a)) : (u = new s(t, l), u.attr(Ui, h)), r.add(u), void t[He](l, u)) : void r[En](u)
            })[En](function (t) {
                var e = o[pi](t);
                e && e.fadeOut(function () {
                    r[En](e)
                })
            })[qe](), this._data = t
        }, a[Nn] = function () {
            var t = this._data;
            t && t[ne](function (e, i) {
                e.attr(Ui, t[fi](i))
            })
        }, a[En] = function (t) {
            var e = this.group, i = this._data;
            i && (t ? i[ne](function (t) {
                t.fadeOut(function () {
                    e[En](t)
                })
            }) : e[rn]())
        }, e
    }),e("echarts/coord/parallel/parallelCreator", [gr, "./Parallel", ge], function (t) {
        function e(t, e) {
            var n = [];
            return t[qn](g, function (r, a) {
                var o = new i(r, t, e);
                o.name = "parallel_" + a, o[$n](r, e), r[Ni] = o, o.model = r, n.push(o)
            }), t[In](function (t) {
                if (t.get(Ni) === g) {
                    var e = t.get("parallelIndex");
                    t[Ni] = n[e]
                }
            }), n
        }

        var i = t("./Parallel");
        t(ge)[dn](g, {create: e})
    }),e("echarts/data/Tree", [gr, vr, "../model/Model", "./List", "./helper/linkList", "./helper/completeDimensions"], function (t) {
        function e(t, e) {
            this.root, this.data, this._nodes = [], this[ri] = t, this.levelModels = n.map(e || [], function (e) {
                return new r(e, t, t[j])
            })
        }

        function i(t, e) {
            var i = e.children;
            t[B] !== e && (i.push(t), t[B] = e)
        }

        var n = t(vr), r = t("../model/Model"), a = t("./List"), o = t("./helper/linkList"), s = t("./helper/completeDimensions"), l = function (t, e) {
            this.name = t || "", this.depth = 0, this[Fn] = 0, this[B] = null, this[Mn] = -1, this.children = [], this.viewChildren = [], this.hostTree = e
        };
        return l[ir] = {
            constructor: l, isRemoved: function () {
                return this[Mn] < 0
            }, eachNode: function (t, e, i) {
                typeof t === fn && (i = e, e = t, t = null), t = t || {}, n[an](t) && (t = {order: t});
                var r, a = t.order || "preorder", o = this[t.attr || "children"];
                "preorder" === a && (r = e.call(i, this));
                for (var s = 0; !r && s < o[zn]; s++)o[s].eachNode(t, e, i);
                "postorder" === a && e.call(i, this)
            }, updateDepthAndHeight: function (t) {
                var e = 0;
                this.depth = t;
                for (var i = 0; i < this.children[zn]; i++) {
                    var n = this.children[i];
                    n.updateDepthAndHeight(t + 1), n[Fn] > e && (e = n[Fn])
                }
                this[Fn] = e + 1
            }, getNodeById: function (t) {
                if (this.getId() === t)return this;
                for (var e = 0, i = this.children, n = i[zn]; n > e; e++) {
                    var r = i[e].getNodeById(t);
                    if (r)return r
                }
            }, contains: function (t) {
                if (t === this)return !0;
                for (var e = 0, i = this.children, n = i[zn]; n > e; e++) {
                    var r = i[e].contains(t);
                    if (r)return r
                }
            }, getAncestors: function (t) {
                for (var e = [], i = t ? this : this[B]; i;)e.push(i), i = i[B];
                return e[k](), e
            }, getValue: function (t) {
                var e = this.hostTree.data;
                return e.get(e.getDimension(t || "value"), this[Mn])
            }, setLayout: function (t, e) {
                this[Mn] >= 0 && this.hostTree.data[Ve](this[Mn], t, e)
            }, getLayout: function () {
                return this.hostTree.data[fi](this[Mn])
            }, getModel: function (t) {
                if (!(this[Mn] < 0)) {
                    var e = this.hostTree, i = e.data[Ai](this[Mn]), n = this.getLevelModel();
                    return i[Jn](t, (n || e[ri])[Jn](t))
                }
            }, getLevelModel: function () {
                return (this.hostTree.levelModels || [])[this.depth]
            }, setVisual: function (t, e) {
                this[Mn] >= 0 && this.hostTree.data[wi](this[Mn], t, e)
            }, getVisual: function (t, e) {
                return this.hostTree.data[Mi](this[Mn], t, e)
            }, getRawIndex: function () {
                return this.hostTree.data[Si](this[Mn])
            }, getId: function () {
                return this.hostTree.data.getId(this[Mn])
            }
        }, e[ir] = {
            constructor: e, type: "tree", eachNode: function (t, e, i) {
                this.root.eachNode(t, e, i)
            }, getNodeByDataIndex: function (t) {
                var e = this.data[Si](t);
                return this._nodes[e]
            }, getNodeByName: function (t) {
                return this.root.getNodeByName(t)
            }, update: function () {
                for (var t = this.data, e = this._nodes, i = 0, n = e[zn]; n > i; i++)e[i][Mn] = -1;
                for (var i = 0, n = t.count(); n > i; i++)e[t[Si](i)][Mn] = i
            }, clearLayouts: function () {
                this.data.clearItemLayouts()
            }
        }, e.createTree = function (t, n, r) {
            function c(t, e) {
                h.push(t);
                var n = new l(t.name, u);
                e ? i(n, e) : u.root = n, u._nodes.push(n);
                var r = t.children;
                if (r)for (var a = 0; a < r[zn]; a++)c(r[a], n)
            }

            var u = new e(n, r), h = [];
            c(t), u.root.updateDepthAndHeight(0);
            var d = s([{name: "value"}], h), f = new a(d, n);
            return f[Ii](h), o({mainData: f, struct: u, structAttr: "tree"}), u[Gn](), u
        }, e
    }),e("echarts/component/radar/RadarView", [gr, "../axis/AxisBuilder", vr, vi, Ri], function (t) {
        var e = t("../axis/AxisBuilder"), i = t(vr), n = t(vi), r = [T, A, C, "axisName"];
        return t(Ri)[cn]({
            type: "radar", render: function (t) {
                var e = this.group;
                e[rn](), this._buildAxes(t), this._buildSplitLineAndArea(t)
            }, _buildAxes: function (t) {
                var n = t[Ni], a = n.getIndicatorAxes(), o = i.map(a, function (t) {
                    var i = new e(t.model, {
                        position: [n.cx, n.cy],
                        rotation: t.angle,
                        labelDirection: -1,
                        tickDirection: -1,
                        nameDirection: 1
                    });
                    return i
                });
                i.each(o, function (t) {
                    i.each(r, t.add, t), this.group.add(t.getGroup())
                }, this)
            }, _buildSplitLineAndArea: function (t) {
                function e(t, e, i) {
                    var n = i % e[zn];
                    return t[n] = t[n] || [], n
                }

                var r = t[Ni], a = t.get(S), o = r.getIndicatorAxes();
                if (o[zn]) {
                    var s = t.get("shape"), l = t[Jn]("splitLine"), c = t[Jn]("splitArea"), u = l[Jn](lr), h = c[Jn]("areaStyle"), d = l.get("show"), f = c.get("show"), p = u.get("color"), v = h.get("color");
                    p = i[gn](p) ? p : [p], v = i[gn](v) ? v : [v];
                    var g = [], m = [];
                    if (s === dr)for (var x = o[0].getTicksCoords(), _ = r.cx, w = r.cy, b = 0; b < x[zn]; b++) {
                        if (d) {
                            var M = e(g, p, b);
                            g[M].push(new n[y]({shape: {cx: _, cy: w, r: x[b]}}))
                        }
                        if (f && b < x[zn] - 1) {
                            var M = e(m, v, b);
                            m[M].push(new n.Ring({shape: {cx: _, cy: w, r0: x[b], r: x[b + 1]}}))
                        }
                    } else for (var A = i.map(o, function (t, e) {
                        var n = t.getTicksCoords();
                        return i.map(n, function (t) {
                            return r.coordToPoint(t, e)
                        })
                    }), C = [], b = 0; a >= b; b++) {
                        for (var T = [], L = 0; L < o[zn]; L++)T.push(A[L][b]);
                        if (T.push(T[0].slice()), d) {
                            var M = e(g, p, b);
                            g[M].push(new n[ci]({shape: {points: T}}))
                        }
                        if (f && C) {
                            var M = e(m, v, b - 1);
                            m[M].push(new n[R]({shape: {points: T[Gi](C)}}))
                        }
                        C = T.slice()[k]()
                    }
                    var D = u[Ue](), I = h[z]();
                    i.each(m, function (t, e) {
                        this.group.add(n.mergePath(t, {
                            style: i[Vn]({stroke: "none", fill: v[e % v[zn]]}, I),
                            silent: !0
                        }))
                    }, this), i.each(g, function (t, e) {
                        this.group.add(n.mergePath(t, {
                            style: i[Vn]({fill: "none", stroke: p[e % p[zn]]}, D),
                            silent: !0
                        }))
                    }, this)
                }
            }
        })
    }),e("echarts/coord/radar/Radar", [gr, vr, "./IndicatorAxis", "../../scale/Interval", Be, "../axisHelper", ge], function (t) {
        function e(t, e, a) {
            this[Qn] = t, this[Te] = [], this._indicatorAxes = i.map(t.getIndicatorModels(), function (t, e) {
                var i = "indicator_" + e, a = new n(i, new r);
                return a.name = t.get("name"), a.model = t, t.axis = a, this[Te].push(i), a
            }, this), this[$n](t, a), this.cx, this.cy, this.r, this[di]
        }

        var i = t(vr), n = t("./IndicatorAxis"), r = t("../../scale/Interval"), a = t(Be), o = t("../axisHelper");
        return e[ir].getIndicatorAxes = function () {
            return this._indicatorAxes
        }, e[ir][Se] = function (t, e) {
            var i = this._indicatorAxes[e];
            return this.coordToPoint(i[te](t), e)
        }, e[ir].coordToPoint = function (t, e) {
            var i = this._indicatorAxes[e], n = i.angle, r = this.cx + t * Math.cos(n), a = this.cy - t * Math.sin(n);
            return [r, a]
        }, e[ir].pointToData = function (t) {
            var e = t[0] - this.cx, i = t[1] - this.cy, n = Math.sqrt(e * e + i * i);
            e /= n, i /= n;
            for (var r, a = Math.atan2(-i, e), o = 1 / 0, s = -1, l = 0; l < this._indicatorAxes[zn]; l++) {
                var c = this._indicatorAxes[l], u = Math.abs(a - c.angle);
                o > u && (r = c, s = l, o = u)
            }
            return [s, +(r && r.coodToData(n))]
        }, e[ir][$n] = function (t, e) {
            var n = t.get(ji), r = e[Kn](), o = e[Yn](), s = Math.min(r, o) / 2;
            this.cx = a[Ee](n[0], r), this.cy = a[Ee](n[1], o), this[di] = t.get(di) * Math.PI / 180, this.r = a[Ee](t.get(Oe), s), i.each(this._indicatorAxes, function (t, e) {
                t[de](0, this.r);
                var i = this[di] + e * Math.PI * 2 / this._indicatorAxes[zn];
                i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i
            }, this)
        }, e[ir][Gn] = function (t) {
            function e(t) {
                var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)), i = t / e;
                return 2 === i ? i = 5 : i *= 2, i * e
            }

            var n = this._indicatorAxes, r = this[Qn];
            i.each(n, function (t) {
                t.scale[de](1 / 0, -1 / 0)
            }), t[hr]("radar", function (e) {
                if ("radar" === e.get(Ni) && t[ve]("radar", e.get("radarIndex")) === r) {
                    var a = e[ur]();
                    i.each(n, function (t) {
                        t.scale.unionExtent(a[Re](t.dim))
                    })
                }
            }, this);
            var s = r.get(S);
            i.each(n, function (t) {
                var i = o.getScaleExtent(t, t.model);
                o.niceScaleExtent(t, t.model);
                var n = t.model, r = t.scale, l = n.get("min"), c = n.get("max"), u = r.getInterval();
                if (null != l && null != c)r.setInterval((c - l) / s); else if (null != l) {
                    var h;
                    do h = l + u * s, r[de](+l, h), r.setInterval(u), u = e(u); while (h < i[1] && isFinite(h) && isFinite(i[1]))
                } else if (null != c) {
                    var d;
                    do d = c - u * s, r[de](d, +c), r.setInterval(u), u = e(u); while (d > i[0] && isFinite(d) && isFinite(i[0]))
                } else {
                    var f = r[oe]()[zn] - 1;
                    f > s && (u = e(u));
                    var p = Math.round((i[0] + i[1]) / 2 / u) * u, v = Math.round(s / 2);
                    r[de](a.round(p - v * u), a.round(p + (s - v) * u)), r.setInterval(u)
                }
            })
        }, e[Te] = [], e[Zn] = function (t, i) {
            var n = [];
            return t[qn]("radar", function (r) {
                var a = new e(r, t, i);
                n.push(a), r[Ni] = a
            }), t[hr]("radar", function (t) {
                "radar" === t.get(Ni) && (t[Ni] = n[t.get("radarIndex") || 0])
            }), n
        }, t(ge)[dn]("radar", e), e
    }),e("echarts/coord/parallel/parallelPreprocessor", [gr, vr, Ei], function (t) {
        function e(t) {
            if (!t[g]) {
                var e = !1;
                n.each(t[Dn], function (t) {
                    t && t.type === g && (e = !0)
                }), e && (t[g] = [{}])
            }
        }

        function i(t) {
            var e = r[b](t.parallelAxis);
            n.each(e, function (e) {
                if (n[Bn](e)) {
                    var i = e.parallelIndex || 0, a = r[b](t[g])[i];
                    a && a.parallelAxisDefault && n.merge(e, a.parallelAxisDefault, !1)
                }
            })
        }

        var n = t(vr), r = t(Ei);
        return function (t) {
            e(t), i(t)
        }
    }),e("echarts/component/helper/MapDraw", [gr, "./RoamController", vi, vr], function (t) {
        function e(t) {
            var e = t[Wi](), i = t.get("areaColor");
            return i && (e.fill = i), e
        }

        function i(t, e, i, r) {
            e.off("click"), t.get("selectedMode") && e.on("click", function (a) {
                for (var o = a[Sn]; !o.__region;)o = o[U];
                if (o) {
                    var s = o.__region, l = {
                        type: ("geo" === t[w] ? "geo" : "map") + "ToggleSelect",
                        name: s.name,
                        from: r.uid
                    };
                    l[t[w] + "Id"] = t.id, i[Rn](l), n(t, e)
                }
            })
        }

        function n(t, e) {
            e[We](function (e) {
                e.__region && e[Pn](t.isSelected(e.__region.name) ? Ti : Li)
            })
        }

        function r(t, e) {
            var i = new o.Group;
            this._controller = new a(t.getZr(), e ? i : null, null), this.group = i, this._updateGroup = e
        }

        var a = t("./RoamController"), o = t(vi), s = t(vr);
        return r[ir] = {
            constructor: r, draw: function (t, r, a, l, c) {
                var u = t[ur] && t[ur](), h = t[Ni], d = this.group, f = h.scale, p = {position: h[Ui], scale: f};
                !d[ni](0) || c ? d.attr(p) : o[ei](d, p, t), d[rn]();
                var v = [ln, Li], g = [ln, Ti], m = ["label", Li], y = ["label", Ti];
                s.each(h.regions, function (i) {
                    var n = new o.Group, r = new o.CompoundPath({shape: {paths: []}});
                    n.add(r);
                    var a, l = t.getRegionModel(i.name) || t, c = l[Jn](v), h = l[Jn](g), p = e(c, f), _ = e(h, f), w = l[Jn](m), b = l[Jn](y);
                    if (u) {
                        a = u[x](i.name);
                        var M = u[Mi](a, "color", !0);
                        M && (p.fill = M)
                    }
                    var S = w[Jn](nn), A = b[Jn](nn);
                    s.each(i.contours, function (t) {
                        var e = new o[R]({shape: {points: t}});
                        r.shape.paths.push(e)
                    }), r[qi](p), r.style.strokeNoScale = !0, r.culling = !0;
                    var C = w.get("show"), T = b.get("show"), L = u && isNaN(u.get("value", a)), k = u && u[fi](a);
                    if (!u || L && (C || T) || k && k.showLabel) {
                        var D = u ? a : i.name, I = t[ai](D, Li), P = t[ai](D, Ti), z = new o.Text({
                            style: {
                                text: C ? I || i.name : "",
                                fill: S[$i](),
                                textFont: S[tn](),
                                textAlign: "center",
                                textVerticalAlign: "middle"
                            },
                            hoverStyle: {text: T ? P || i.name : "", fill: A[$i](), textFont: A[tn]()},
                            position: i[ji].slice(),
                            scale: [1 / f[0], 1 / f[1]],
                            z2: 10,
                            silent: !0
                        });
                        n.add(z)
                    }
                    if (u)u[He](a, n); else {
                        var l = t.getRegionModel(i.name);
                        r.eventData = {
                            componentType: "geo",
                            geoIndex: t.componentIndex,
                            name: i.name,
                            region: l && l[Pi] || {}
                        }
                    }
                    n.__region = i, o[Ke](n, _), d.add(n)
                }), this._updateController(t, r, a), i(t, d, a, l), n(t, d)
            }, remove: function () {
                this.group[rn](), this._controller[kn]()
            }, _updateController: function (t, e, i) {
                function n() {
                    var e = {type: "geoRoam", componentType: o};
                    return e[o + "Id"] = t.id, e
                }

                var r = t[Ni], a = this._controller;
                a[L] = t.get("scaleLimit"), a.zoom = r.getZoom(), a[W](t.get("roam") || !1);
                var o = t[w];
                a.off("pan").on("pan", function (t, e) {
                    i[Rn](s[On](n(), {dx: t, dy: e}))
                }), a.off("zoom").on("zoom", function (t, e, r) {
                    if (i[Rn](s[On](n(), {zoom: t, originX: e, originY: r})), this._updateGroup) {
                        var a = this.group, o = a.scale;
                        a[yn](function (t) {
                            "text" === t.type && t.attr("scale", [1 / o[0], 1 / o[1]])
                        })
                    }
                }, this), a.rectProvider = function () {
                    return r.getViewRectAfterRoam()
                }
            }
        }, r
    }),e("echarts/component/axis/AngleAxisView", [gr, vr, vi, re, Ri], function (t) {
        function e(t, e, i, n) {
            var r = t.coordToPoint([e, n]), a = t.coordToPoint([i, n]);
            return {x1: r[0], y1: r[1], x2: a[0], y2: a[1]}
        }

        var i = t(vr), n = t(vi), r = t(re), a = [T, A, C, "splitLine", "splitArea"];
        t(Ri)[cn]({
            type: "angleAxis", render: function (t, e) {
                if (this.group[rn](), t.get("show")) {
                    var n = e[ve]("polar", t.get(Y)), r = t.axis, o = n[Ni], s = o.getRadiusAxis()[we](), l = r.getTicksCoords();
                    r.type !== be && l.pop(), i.each(a, function (e) {
                        t.get(e + ".show") && this["_" + e](t, o, l, s)
                    }, this)
                }
            }, _axisLine: function (t, e, i, r) {
                var a = t[Jn]("axisLine.lineStyle"), o = new n[y]({
                    shape: {cx: e.cx, cy: e.cy, r: r[1]},
                    style: a[Ue](),
                    z2: 1,
                    silent: !0
                });
                o.style.fill = null, this.group.add(o)
            }, _axisTick: function (t, r, a, o) {
                var s = t[Jn](C), l = (s.get(si) ? -1 : 1) * s.get(zn), c = i.map(a, function (t) {
                    return new n.Line({shape: e(r, o[1], o[1] + l, t)})
                });
                this.group.add(n.mergePath(c, {style: s[Jn](lr)[Ue]()}))
            }, _axisLabel: function (t, e, i, a) {
                for (var o = t.axis, s = t.get("data"), l = t[Jn](A), c = l[Jn](nn), u = t[pe](), h = l.get("margin"), d = o.getLabelsCoords(), f = 0; f < i[zn]; f++) {
                    var p = a[1], v = e.coordToPoint([p + h, d[f]]), g = e.cx, m = e.cy, y = Math.abs(v[0] - g) / p < .3 ? ji : v[0] > g ? "left" : "right", x = Math.abs(v[1] - m) / p < .3 ? Xi : v[1] > m ? "top" : Hn, _ = c;
                    s && s[f] && s[f][nn] && (_ = new r(s[f][nn], c)), this.group.add(new n.Text({
                        style: {
                            x: v[0],
                            y: v[1],
                            fill: _[$i](),
                            text: u[f],
                            textAlign: y,
                            textVerticalAlign: x,
                            textFont: _[tn]()
                        }, silent: !0
                    }))
                }
            }, _splitLine: function (t, r, a, o) {
                var s = t[Jn]("splitLine"), l = s[Jn](lr), c = l.get("color"), u = 0;
                c = c instanceof Array ? c : [c];
                for (var h = [], d = 0; d < a[zn]; d++) {
                    var f = u++ % c[zn];
                    h[f] = h[f] || [], h[f].push(new n.Line({shape: e(r, o[0], o[1], a[d])}))
                }
                for (var d = 0; d < h[zn]; d++)this.group.add(n.mergePath(h[d], {
                    style: i[Vn]({stroke: c[d % c[zn]]}, l[Ue]()),
                    silent: !0,
                    z: t.get("z")
                }))
            }, _splitArea: function (t, e, r, a) {
                var o = t[Jn]("splitArea"), s = o[Jn]("areaStyle"), l = s.get("color"), c = 0;
                l = l instanceof Array ? l : [l];
                for (var u = [], h = Math.PI / 180, d = -r[0] * h, f = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), v = t.get(Fe), g = 1; g < r[zn]; g++) {
                    var m = c++ % l[zn];
                    u[m] = u[m] || [], u[m].push(new n[ui]({
                        shape: {
                            cx: e.cx,
                            cy: e.cy,
                            r0: f,
                            r: p,
                            startAngle: d,
                            endAngle: -r[g] * h,
                            clockwise: v
                        }, silent: !0
                    })), d = -r[g] * h
                }
                for (var g = 0; g < u[zn]; g++)this.group.add(n.mergePath(u[g], {
                    style: i[Vn]({fill: l[g % l[zn]]}, s[z]()),
                    silent: !0
                }))
            }
        })
    }),e("echarts/component/helper/listComponent", [gr, me, Ie, vi], function (t) {
        function e(t, e, n) {
            i.positionGroup(t, e[Ji](), {width: n[Kn](), height: n[Yn]()}, e.get(Yi))
        }

        var i = t(me), n = t(Ie), r = t(vi);
        return {
            layout: function (t, n, r) {
                var a = i[Ki](n[Ji](), {width: r[Kn](), height: r[Yn]()}, n.get(Yi));
                i.box(n.get(u), t, n.get("itemGap"), a.width, a[Fn]), e(t, n, r)
            }, addBackground: function (t, e) {
                var i = n.normalizeCssArray(e.get(Yi)), a = t[Qi](), o = e[Wi](["color", Hi]);
                o.fill = e.get(jn);
                var s = new r.Rect({
                    shape: {
                        x: a.x - i[3],
                        y: a.y - i[0],
                        width: a.width + i[1] + i[3],
                        height: a[Fn] + i[0] + i[2]
                    }, style: o, silent: !0, z2: -1
                });
                r.subPixelOptimizeRect(s), t.add(s)
            }
        }
    }),e("echarts/component/tooltip/TooltipContent", [gr, vr, "zrender/tool/color", "zrender/core/event", Ie, sr], function (t) {
        function e(t) {
            var e = "cubic-bezier(0.23, 1, 0.32, 1)", i = "left " + t + "s " + e + ",top " + t + "s " + e;
            return o.map(p, function (t) {
                return t + "transition:" + i
            }).join(";")
        }

        function i(t) {
            var e = [], i = t.get("fontSize"), n = t[$i]();
            return n && e.push("color:" + n), e.push("font:" + t[tn]()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), u(["decoration", "align"], function (i) {
                var n = t.get(i);
                n && e.push("text-" + i + ":" + n)
            }), e.join(";")
        }

        function n(t) {
            t = t;
            var n = [], r = t.get("transitionDuration"), a = t.get(jn), o = t[Jn](nn), l = t.get(Yi);
            return r && n.push(e(r)), a && (f[Xn] ? n.push("background-Color:" + a) : (n.push("background-Color:#" + s.toHex(a)), n.push("filter:alpha(opacity=70)"))), u(["width", "color", Oe], function (e) {
                var i = "border-" + e, r = d(i), a = t.get(r);
                null != a && n.push(i + ":" + a + ("color" === e ? "" : "px"))
            }), n.push(i(o)), null != l && n.push("padding:" + c.normalizeCssArray(l).join("px ") + "px"), n.join(";") + ";"
        }

        function r(t, e) {
            var i = document[Fi]("div"), n = e.getZr();
            this.el = i, this._x = e[Kn]() / 2, this._y = e[Yn]() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout;
            var r = this;
            i.onmouseenter = function () {
                r.enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0
            }, i.onmousemove = function (e) {
                if (!r.enterable) {
                    var i = n.handler;
                    l.normalizeEvent(t, e), i.dispatch(h, e)
                }
            }, i.onmouseleave = function () {
                r.enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1
            }, a(i, t)
        }

        function a(t, e) {
            function i(t) {
                n(t[Sn]) && t.preventDefault()
            }

            function n(i) {
                for (; i && i !== e;) {
                    if (i === t)return !0;
                    i = i[B]
                }
            }

            l.addEventListener(e, "touchstart", i), l.addEventListener(e, "touchmove", i), l.addEventListener(e, "touchend", i)
        }

        var o = t(vr), s = t("zrender/tool/color"), l = t("zrender/core/event"), c = t(Ie), u = o.each, d = c.toCamelCase, f = t(sr), p = ["", "-webkit-", "-moz-", "-o-"], v = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
        return r[ir] = {
            constructor: r, enterable: !0, update: function () {
                var t = this._container, e = t.currentStyle || document.defaultView.getComputedStyle(t), i = t.style;
                "absolute" !== i[Ui] && "absolute" !== e[Ui] && (i[Ui] = "relative")
            }, show: function (t) {
                clearTimeout(this._hideTimeout), this.el.style.cssText = v + n(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), this._show = !0
            }, setContent: function (t) {
                var e = this.el;
                e.innerHTML = t, e.style.display = t ? "block" : "none"
            }, moveTo: function (t, e) {
                var i = this.el.style;
                i.left = t + "px", i.top = e + "px", this._x = t, this._y = e
            }, hide: function () {
                this.el.style.display = "none", this._show = !1
            }, hideLater: function (t) {
                !this._show || this._inContent && this.enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(o.bind(this.hide, this), t)) : this.hide())
            }, isShow: function () {
                return this._show
            }
        }, r
    }),e("echarts/component/marker/markerHelper", [gr, vr, Be], function (t) {
        function e(t, e, i) {
            var n = -1;
            do n = Math.max(r.getPrecision(t.get(e, i)), n), t = t.stackedOn; while (t);
            return n
        }

        function i(t, i, n, r, a, o) {
            var s = [], l = d(i, r, t), c = i.indexOfNearest(r, l, !0);
            s[a] = i.get(n, c, !0), s[o] = i.get(r, c, !0);
            var u = e(i, r, c);
            return u >= 0 && (s[o] = +s[o][Di](u)), s
        }

        var n = t(vr), r = t(Be), a = n[vn], o = n.curry, s = {
            min: o(i, "min"),
            max: o(i, "max"),
            average: o(i, "average")
        }, l = function (t, e) {
            var i = t[ur](), r = t[Ni];
            if (e && (isNaN(parseFloat(e.x)) || isNaN(parseFloat(e.y))) && !n[gn](e.coord) && r) {
                var o = c(e, i, r, t);
                if (e = n.clone(e), e.type && s[e.type] && o.baseAxis && o.valueAxis) {
                    var l = r[Te], u = a(l, o.baseAxis.dim), h = a(l, o.valueAxis.dim);
                    e.coord = s[e.type](i, o.baseDataDim, o.valueDataDim, u, h), e.value = e.coord[h]
                } else e.coord = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis]
            }
            return e
        }, c = function (t, e, i, n) {
            var r = {};
            return null != t.valueIndex || null != t.valueDim ? (r.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = i[he](n.dataDimToCoordDim(r.valueDataDim)), r.baseAxis = i[ee](r.valueAxis), r.baseDataDim = n[le](r.baseAxis.dim)[0]) : (r.baseAxis = n[Me](), r.valueAxis = i[ee](r.baseAxis), r.baseDataDim = n[le](r.baseAxis.dim)[0], r.valueDataDim = n[le](r.valueAxis.dim)[0]), r
        }, u = function (t, e) {
            return t && t.containData && e.coord && (null == e.x || null == e.y) ? t.containData(e.coord) : !0
        }, h = function (t, e, i, n) {
            return 2 > n ? t.coord && t.coord[n] : t.value
        }, d = function (t, e, i) {
            return "average" === i ? t.getSum(e, !0) / t.count() : t[Re](e, !0)["max" === i ? 1 : 0]
        };
        return {dataTransform: l, dataFilter: u, dimValueGetter: h, getAxisInfo: c, numCalculate: d}
    }),e("echarts/component/timeline/TimelineModel", [gr, c, Bi, vr, Ei], function (t) {
        var e = t(c), i = t(Bi), n = t(vr), r = t(Ei), a = e[On]({
            type: "timeline",
            layoutMode: "box",
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                axisType: "time",
                realtime: !0,
                left: "20%",
                top: null,
                right: "20%",
                bottom: 0,
                width: null,
                height: 40,
                padding: 5,
                controlPosition: "left",
                autoPlay: !1,
                rewind: !1,
                loop: !0,
                playInterval: 2e3,
                currentIndex: 0,
                itemStyle: {normal: {}, emphasis: {}},
                label: {normal: {textStyle: {color: "#000"}}, emphasis: {}},
                data: []
            },
            init: function (t, e, i) {
                this._data, this._names, this[P](t, i), this._initData()
            },
            mergeOption: function () {
                a[Vi](this, zi, arguments), this._initData()
            },
            setCurrentIndex: function (t) {
                null == t && (t = this[Pi].currentIndex);
                var e = this._data.count();
                this[Pi].loop ? t = (t % e + e) % e : (t >= e && (t = e - 1), 0 > t && (t = 0)), this[Pi].currentIndex = t
            },
            getCurrentIndex: function () {
                return this[Pi].currentIndex
            },
            isIndexMax: function () {
                return this.getCurrentIndex() >= this._data.count() - 1
            },
            setPlayState: function (t) {
                this[Pi].autoPlay = !!t
            },
            getPlayState: function () {
                return !!this[Pi].autoPlay
            },
            _initData: function () {
                var t = this[Pi], e = t.data || [], a = t.axisType, o = this._names = [];
                if (a === be) {
                    var s = [];
                    n.each(e, function (t, e) {
                        var i, a = r.getDataItemValue(t);
                        n[Bn](t) ? (i = n.clone(t), i.value = e) : i = e, s.push(i), n[an](a) || null != a && !isNaN(a) || (a = ""), o.push(a + "")
                    }), e = s
                }
                var l = {category: "ordinal", time: "time"}[a] || sn, c = this._data = new i([{
                    name: "value",
                    type: l
                }], this);
                c[Ii](e, o)
            },
            getData: function () {
                return this._data
            },
            getCategories: function () {
                return this.get("axisType") === be ? this._names.slice() : void 0
            }
        });
        return a
    }),e("echarts/util/throttle", [], function () {
        var t = {}, e = "\x00__throttleOriginMethod", i = "\x00__throttleRate";
        return t.throttle = function (t, e, i, n) {
            function r(r) {
                function f() {
                    u = (new Date).getTime(), h = null, (d ? t : t[r]).apply(o, s || [])
                }

                var p = function () {
                    l = (new Date).getTime(), o = this, s = arguments, a = l - (n ? c : u) - e, clearTimeout(h), n ? i ? h = setTimeout(f, e) : a >= 0 && f() : a >= 0 ? f() : i && (h = setTimeout(f, -a)), c = l
                };
                return p.clear = function () {
                    h && (clearTimeout(h), h = null)
                }, p
            }

            var a, o, s, l = (new Date).getTime(), c = 0, u = 0, h = null, d = typeof t === fn;
            if (e = e || 0, d)return r();
            for (var f = [], p = 0; p < t[zn]; p++)f[p] = r(p);
            return f
        }, t.fixRate = function (e, i) {
            return null != i ? t.throttle(e, i, !0, !1) : e
        }, t.debounce = function (e, i) {
            return null != i ? t.throttle(e, i, !0, !0) : e
        }, t.createOrUpdate = function (n, r, a, o) {
            var s = n[r];
            if (s && null != a && o) {
                var l = s[e] || s, c = s[i];
                c !== a && (s = n[r] = t[o](l, a), s[e] = l, s[i] = a)
            }
        }, t.clear = function (t, i) {
            var n = t[i];
            n && n[e] && (t[i] = n[e])
        }, t
    }),e("echarts/component/helper/sliderMove", [gr], function () {
        return function (t, e, i, n, r) {
            function a(t, e, i) {
                var n = e[zn] ? e.slice() : [e, e];
                return e[0] > e[1] && n[k](), 0 > t && n[0] + t < i[0] && (t = i[0] - n[0]), t > 0 && n[1] + t > i[1] && (t = i[1] - n[1]), t
            }

            return t ? ("rigid" === n ? (t = a(t, e, i), e[0] += t, e[1] += t) : (t = a(t, e[r], i), e[r] += t, "push" === n && e[0] > e[1] && (e[1 - r] = e[r])), e) : e
        }
    }),e("echarts/chart/helper/createGraphFromNodeEdge", [gr, Bi, "../../data/Graph", "../../data/helper/linkList", Oi, ge, vr, "./createListFromArray"], function (t) {
        var e = t(Bi), i = t("../../data/Graph"), n = t("../../data/helper/linkList"), r = t(Oi), a = t(ge), o = t(vr), s = t("./createListFromArray");
        return function (t, l, c, u, h) {
            for (var d = new i(u), f = 0; f < t[zn]; f++)d.addNode(o[oi](t[f].id, t[f].name, f), f);
            for (var p = [], v = [], f = 0; f < l[zn]; f++) {
                var g = l[f], m = g.source, y = g[Sn];
                d.addEdge(m, y, f) && (v.push(g), p.push(o[oi](g.id, m + " > " + y)))
            }
            var x, _ = c.get(Ni);
            if (_ === ce || "polar" === _)x = s(t, c, c[j]); else {
                var w = a.get(_), b = r((w && "view" !== w.type ? w[Te] || [] : [])[Gi](["value"]), t);
                x = new e(b, c), x[Ii](t)
            }
            var M = new e(["value"], c);
            return M[Ii](v, p), h && h(x, M), n({
                mainData: x,
                struct: d,
                structAttr: "graph",
                datas: {node: x, edge: M},
                datasAttr: {node: "data", edge: "edgeData"}
            }), d[Gn](), d
        }
    }),e("echarts/chart/helper/WhiskerBoxDraw", [gr, vr, vi, "zrender/graphic/Path"], function (t) {
        function e(t, e, i, n) {
            s.Group.call(this), this.bodyIndex, this.whiskerIndex, this.styleUpdater = i, this._createContent(t, e, n), this[li](t, e, n), this._seriesModel
        }

        function i(t, e, i) {
            return o.map(t, function (t) {
                return t = t.slice(), t[e] = i.initBaseline, t
            })
        }

        function r(t) {
            var e = {};
            return o.each(t, function (t, i) {
                e["ends" + i] = t
            }), e
        }

        function a(t) {
            this.group = new s.Group, this.styleUpdater = t
        }

        var o = t(vr), s = t(vi), l = t("zrender/graphic/Path"), c = l[On]({
            type: "whiskerInBox",
            shape: {},
            buildPath: function (t, e) {
                for (var i in e)if (0 === i[vn]("ends")) {
                    var r = e[i];
                    t[d](r[0][0], r[0][1]), t[n](r[1][0], r[1][1])
                }
            }
        }), u = e[ir];
        u._createContent = function (t, e, n) {
            var a = t[fi](e), l = a.chartLayout === Ae ? 1 : 0, u = 0;
            this.add(new s[R]({
                shape: {points: n ? i(a.bodyEnds, l, a) : a.bodyEnds},
                style: {strokeNoScale: !0},
                z2: 100
            })), this.bodyIndex = u++;
            var h = o.map(a.whiskerEnds, function (t) {
                return n ? i(t, l, a) : t
            });
            this.add(new c({shape: r(h), style: {strokeNoScale: !0}, z2: 100})), this.whiskerIndex = u++
        }, u[li] = function (t, e, i) {
            var n = this._seriesModel = t[ri], a = t[fi](e), o = s[i ? Ze : ei];
            o(this[ni](this.bodyIndex), {shape: {points: a.bodyEnds}}, n, e), o(this[ni](this.whiskerIndex), {shape: r(a.whiskerEnds)}, n, e), this.styleUpdater.call(null, this, t, e)
        }, o[on](e, s.Group);
        var h = a[ir];
        return h[li] = function (t) {
            var i = this.group, n = this._data, r = this.styleUpdater;
            t.diff(n).add(function (n) {
                if (t.hasValue(n)) {
                    var a = new e(t, n, r, !0);
                    t[He](n, a), i.add(a)
                }
            })[Gn](function (a, o) {
                var s = n[pi](o);
                return t.hasValue(a) ? (s ? s[li](t, a) : s = new e(t, a, r), i.add(s), void t[He](a, s)) : void i[En](s)
            })[En](function (t) {
                var e = n[pi](t);
                e && i[En](e)
            })[qe](), this._data = t
        }, h[En] = function () {
            var t = this.group, e = this._data;
            this._data = null, e && e[ne](function (e) {
                e && t[En](e)
            })
        }, a
    }),e("echarts/coord/parallel/ParallelModel", [gr, vr, c, "./AxisModel"], function (t) {
        var e = t(vr), i = t(c);
        t("./AxisModel"), i[On]({
            type: "parallel",
            dependencies: ["parallelAxis"],
            coordinateSystem: null,
            dimensions: null,
            parallelAxisIndex: null,
            defaultOption: {
                zlevel: 0,
                z: 0,
                left: 80,
                top: 60,
                right: 80,
                bottom: 60,
                layout: "horizontal",
                parallelAxisDefault: null
            },
            init: function () {
                i[ir].init.apply(this, arguments), this[zi]({})
            },
            mergeOption: function (t) {
                var i = this[Pi];
                t && e.merge(i, t, !0), this._initDimensions()
            },
            contains: function (t, e) {
                var i = t.get("parallelIndex");
                return null != i && e[ve](g, i) === this
            },
            _initDimensions: function () {
                var t = this[Te] = [], i = this.parallelAxisIndex = [], n = e[fr](this.dependentModels.parallelAxis, function (t) {
                    return t.get("parallelIndex") === this.componentIndex
                });
                e.each(n, function (e) {
                    t.push("dim" + e.get("dim")), i.push(e.componentIndex)
                })
            }
        })
    }),e("echarts/component/parallelAxis", [gr, "../coord/parallel/parallelCreator", "./axis/parallelAxisAction", "./axis/ParallelAxisView"], function (t) {
        t("../coord/parallel/parallelCreator"), t("./axis/parallelAxisAction"), t("./axis/ParallelAxisView")
    }),e("echarts/coord/parallel/Parallel", [gr, me, "../../coord/axisHelper", vr, "./ParallelAxis", or, ar], function (t) {
        function e(t, e, i) {
            this._axesMap = {}, this._axesLayout = {}, this[Te] = t[Te], this._rect, this[Qn] = t, this._init(t, e, i)
        }

        var i = t(me), n = t("../../coord/axisHelper"), r = t(vr), a = t("./ParallelAxis"), o = t(or), s = t(ar), c = r.each, u = Math.PI;
        return e[ir] = {
            type: "parallel", constructor: e, _init: function (t, e) {
                var i = t[Te], r = t.parallelAxisIndex;
                c(i, function (t, i) {
                    var o = r[i], s = e[ve]("parallelAxis", o), l = this._axesMap[t] = new a(t, n.createScaleByModel(s), [0, 0], s.get("type"), o), c = l.type === be;
                    l.onBand = c && s.get(ue), l[fe] = s.get(fe), s.axis = l, l.model = s
                }, this)
            }, update: function (t) {
                this._updateAxesFromSeries(this[Qn], t)
            }, _updateAxesFromSeries: function (t, e) {
                e[In](function (i) {
                    if (t.contains(i, e)) {
                        var r = i[ur]();
                        c(this[Te], function (t) {
                            var e = this._axesMap[t];
                            e.scale.unionExtent(r[Re](t)), n.niceScaleExtent(e, e.model)
                        }, this)
                    }
                }, this)
            }, resize: function (t, e) {
                this._rect = i[Ki](t[Ji](), {width: e[Kn](), height: e[Yn]()}), this._layoutAxes(t)
            }, getRect: function () {
                return this._rect
            }, _layoutAxes: function (t) {
                var e = this._rect, i = t.get(Ce), n = this._axesMap, r = this[Te], a = [e.width, e[Fn]], s = i === Ae ? 0 : 1, h = a[s], d = a[1 - s], f = [0, d];
                c(n, function (t) {
                    var e = t[fe] ? 1 : 0;
                    t[de](f[e], f[1 - e])
                }), c(r, function (t, n) {
                    var a = h * n / (r[zn] - 1), s = {
                        horizontal: {x: a, y: d},
                        vertical: {x: 0, y: a}
                    }, c = {horizontal: u / 2, vertical: 0}, f = [s[i].x + e.x, s[i].y + e.y], p = c[i], v = o[Zn]();
                    o[l](v, v, p), o.translate(v, v, f), this._axesLayout[t] = {
                        position: f,
                        rotation: p,
                        transform: v,
                        tickDirection: 1,
                        labelDirection: 1
                    }
                }, this)
            }, getAxis: function (t) {
                return this._axesMap[t]
            }, dataToPoint: function (t, e) {
                return this.axisCoordToPoint(this._axesMap[e][te](t), e)
            }, eachActiveState: function (t, e, i) {
                for (var n = this[Te], r = this._axesMap, a = !1, o = 0, s = n[zn]; s > o; o++)r[n[o]].model.getActiveState() !== Li && (a = !0);
                for (var l = 0, c = t.count(); c > l; l++) {
                    var u, h = t.getValues(n, l);
                    if (a) {
                        u = "active";
                        for (var o = 0, s = n[zn]; s > o; o++) {
                            var d = n[o], f = r[d].model.getActiveState(h[o], o);
                            if ("inactive" === f) {
                                u = "inactive";
                                break
                            }
                        }
                    } else u = Li;
                    e.call(i, u, l)
                }
            }, axisCoordToPoint: function (t, e) {
                var i = this._axesLayout[e], n = [t, 0];
                return s[J](n, n, i[rr]), n
            }, getAxisLayout: function (t) {
                return r.clone(this._axesLayout[t])
            }
        }, e
    }),e("echarts/data/helper/linkList", [gr, vr], function (t) {
        function e(t) {
            var e = t.mainData, a = t.datas;
            a || (a = {main: e}, t.datasAttr = {main: "data"}), t.datas = t.mainData = null, s(e, a, t), u(a, function (n) {
                u(e.TRANSFERABLE_METHODS, function (e) {
                    n.wrapMethod(e, c.curry(i, t))
                })
            }), e.wrapMethod("cloneShallow", c.curry(r, t)), u(e.CHANGABLE_METHODS, function (i) {
                e.wrapMethod(i, c.curry(n, t))
            }), c.assert(a[e[_n]] === e)
        }

        function i(t, e) {
            if (o(this)) {
                var i = c[On]({}, this[h]);
                i[this[_n]] = e, s(e, i, t)
            } else l(e, this[_n], this[d], t);
            return e
        }

        function n(t, e) {
            return t.struct && t.struct[Gn](this), e
        }

        function r(t, e) {
            return u(e[h], function (i, n) {
                i !== e && l(i.cloneShallow(), n, e, t)
            }), e
        }

        function a(t) {
            var e = this[d];
            return null == t || null == e ? e : e[h][t]
        }

        function o(t) {
            return t[d] === t
        }

        function s(t, e, i) {
            t[h] = {}, u(e, function (e, n) {
                l(e, n, t, i)
            })
        }

        function l(t, e, i, n) {
            i[h][e] = t, t[d] = i, t[_n] = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = a
        }

        var c = t(vr), u = c.each, h = "\x00__link_datas", d = "\x00__link_mainData";
        return e
    }),e("echarts/chart/helper/EffectSymbol", [gr, vr, E, vi, Be, "./Symbol"], function (t) {
        function e(t) {
            return n[gn](t) || (t = [+t, +t]), t
        }

        function i(t, e) {
            l.call(this);
            var i = new s(t, e), n = new l;
            this.add(i), this.add(n), n.beforeUpdate = function () {
                this.attr(i.getScale())
            }, this[li](t, e)
        }

        var n = t(vr), r = t(E), a = t(vi), o = t(Be), s = t("./Symbol"), l = a.Group, c = 3, u = i[ir];
        return u.stopEffectAnimation = function () {
            this[ni](1)[rn]()
        }, u.startEffectAnimation = function (t, e, i, n, a, o) {
            for (var s = this._symbolType, l = this._color, u = this[ni](1), h = 0; c > h; h++) {
                var d = r[O](s, -.5, -.5, 1, 1, l);
                d.attr({
                    style: {stroke: e === Ne ? l : null, fill: "fill" === e ? l : null, strokeNoScale: !0},
                    z2: 99,
                    silent: !0,
                    scale: [1, 1],
                    z: a,
                    zlevel: o
                });
                var f = -h / c * t + n;
                d[hi]("", !0).when(t, {scale: [i, i]}).delay(f).start(), d.animateStyle(!0).when(t, {opacity: 0}).delay(f).start(), u.add(d)
            }
        }, u.highlight = function () {
            this[Pn](Ti)
        }, u.downplay = function () {
            this[Pn](Li)
        }, u[li] = function (t, i) {
            function n() {
                w[Pn](Ti), p !== Tn && this.startEffectAnimation(m, g, v, y, x, _)
            }

            function r() {
                w[Pn](Li), p !== Tn && this.stopEffectAnimation()
            }

            var a = t[ri];
            this[ni](0)[li](t, i);
            var s = this[ni](1), l = t[Ai](i), c = t[Mi](i, _e), u = e(t[Mi](i, xe)), h = t[Mi](i, "color");
            s.attr("scale", u), s[yn](function (t) {
                t.attr({fill: h})
            });
            var d = l[N]("symbolOffset");
            if (d) {
                var f = s[Ui];
                f[0] = o[Ee](d[0], u[0]), f[1] = o[Ee](d[1], u[1])
            }
            s[Ye] = (l[N]("symbolRotate") || 0) * Math.PI / 180 || 0, this._symbolType = c, this._color = h;
            var p = a.get("showEffectOn"), v = l.get("rippleEffect.scale"), g = l.get("rippleEffect.brushType"), m = 1e3 * l.get("rippleEffect.period"), y = i / t.count(), x = l[N]("z") || 0, _ = l[N](xn) || 0;
            this.stopEffectAnimation(), p === Tn && this.startEffectAnimation(m, g, v, y, x, _);
            var w = this[ni](0);
            this.on(Cn, n, this).on(An, r, this).on(Ti, n, this).on(Li, r, this)
        }, u.fadeOut = function (t) {
            this.off(Cn).off(An).off(Ti).off(Li), t && t()
        }, n[on](i, l), i
    }),e("echarts/component/helper/SelectController", [gr, "zrender/mixin/Eventful", vr, vi], function (t) {
        function e(t, e, i) {
            g.call(this), this.type = t, this.zr = e, this.opt = y.clone(i), this.group = new x.Group, this._containerRect = null, this._track = [], this._dragging, this._cover, this._disabled = !0, this._handlers = {
                mousedown: w(a, this),
                mousemove: w(o, this),
                mouseup: w(s, this)
            }, b(L, function (t) {
                this.zr.on(t, this._handlers[t])
            }, this)
        }

        function i(t) {
            t[yn](function (t) {
                t.z = C
            })
        }

        function n(t, e) {
            var i = this.group.transformCoordToLocal(t, e);
            return !this._containerRect || this._containerRect[mi](i[0], i[1])
        }

        function r(t) {
            var e = t.event;
            e.preventDefault && e.preventDefault()
        }

        function a(t) {
            if (!(this._disabled || t[Sn] && t[Sn][_])) {
                r(t);
                var e = t[F], i = t[Z];
                n.call(this, e, i) && (this._dragging = !0, this._track = [[e, i]])
            }
        }

        function o(t) {
            this._dragging && !this._disabled && (r(t), l.call(this, t))
        }

        function s(t) {
            this._dragging && !this._disabled && (r(t), l.call(this, t, !0), this._dragging = !1, this._track = [])
        }

        function l(t, e) {
            var i = t[F], r = t[Z];
            if (n.call(this, i, r)) {
                this._track.push([i, r]);
                var a = c.call(this) ? k[this.type].getRanges.call(this) : [];
                u.call(this, a), this[Pn](Qe, y.clone(a)), e && this[Pn]("selectEnd", y.clone(a))
            }
        }

        function c() {
            var t = this._track;
            if (!t[zn])return !1;
            var e = t[t[zn] - 1], i = t[0], n = e[0] - i[0], r = e[1] - i[1], a = A(n * n + r * r, .5);
            return a > T
        }

        function u(t) {
            var e = k[this.type];
            t && t[zn] ? (this._cover || (this._cover = e[Zn].call(this), this.group.add(this._cover)), e[Gn].call(this, t)) : (this.group[En](this._cover), this._cover = null), i(this.group)
        }

        function d() {
            var t = this.group, e = t[U];
            e && e[En](t)
        }

        function f() {
            var t = this.opt;
            return new x.Rect({style: {stroke: t[Ne], fill: t.fill, lineWidth: t[m], opacity: t[Hi]}})
        }

        function p() {
            return y.map(this._track, function (t) {
                return this.group.transformCoordToLocal(t[0], t[1])
            }, this)
        }

        function v() {
            var t = p.call(this), e = t[zn] - 1;
            return 0 > e && (e = 0), [t[0], t[e]]
        }

        var g = t("zrender/mixin/Eventful"), y = t(vr), x = t(vi), w = y.bind, b = y.each, M = Math.min, S = Math.max, A = Math.pow, C = 1e4, T = 2, L = ["mousedown", h, "mouseup"];
        e[ir] = {
            constructor: e, enable: function (t, e) {
                this._disabled = !1, d.call(this), this._containerRect = e !== !1 ? e || t[Qi]() : null, t.add(this.group)
            }, update: function (t) {
                u.call(this, t && y.clone(t))
            }, disable: function () {
                this._disabled = !0, d.call(this)
            }, dispose: function () {
                this.disable(), b(L, function (t) {
                    this.zr.off(t, this._handlers[t])
                }, this)
            }
        }, y.mixin(e, g);
        var k = {
            line: {
                create: f, getRanges: function () {
                    var t = v.call(this), e = M(t[0][0], t[1][0]), i = S(t[0][0], t[1][0]);
                    return [[e, i]]
                }, update: function (t) {
                    var e = t[0], i = this.opt.width;
                    this._cover[ii]({x: e[0], y: -i / 2, width: e[1] - e[0], height: i})
                }
            }, rect: {
                create: f, getRanges: function () {
                    var t = v.call(this), e = [M(t[1][0], t[0][0]), M(t[1][1], t[0][1])], i = [S(t[1][0], t[0][0]), S(t[1][1], t[0][1])];
                    return [[[e[0], i[0]], [e[1], i[1]]]]
                }, update: function (t) {
                    var e = t[0];
                    this._cover[ii]({x: e[0][0], y: e[1][0], width: e[0][1] - e[0][0], height: e[1][1] - e[1][0]})
                }
            }
        };
        return e
    }),e("echarts/component/dataZoom/history", [gr, vr], function (t) {
        function e(t) {
            var e = t[r];
            return e || (e = t[r] = [{}]), e
        }

        var i = t(vr), n = i.each, r = "\x00_ec_hist_store", a = {
            push: function (t, i) {
                var r = e(t);
                n(i, function (e, i) {
                    for (var n = r[zn] - 1; n >= 0; n--) {
                        var a = r[n];
                        if (a[i])break
                    }
                    if (0 > n) {
                        var o = t.queryComponents({mainType: "dataZoom", subType: "select", id: i})[0];
                        if (o) {
                            var s = o.getPercentRange();
                            r[0][i] = {dataZoomId: i, start: s[0], end: s[1]}
                        }
                    }
                }), r.push(i)
            }, pop: function (t) {
                var i = e(t), r = i[i[zn] - 1];
                i[zn] > 1 && i.pop();
                var a = {};
                return n(r, function (t, e) {
                    for (var n = i[zn] - 1; n >= 0; n--) {
                        var t = i[n][e];
                        if (t) {
                            a[e] = t;
                            break
                        }
                    }
                }), a
            }, clear: function (t) {
                t[r] = null
            }, count: function (t) {
                return e(t)[zn]
            }
        };
        return a
    }),e("echarts/component/helper/interactionMutex", [gr], function () {
        function t(t) {
            return t[e] || (t[e] = {})
        }

        var e = "\x00_ec_interaction_mutex", i = {
            take: function (e, i) {
                t(i)[e] = !0
            }, release: function (e, i) {
                t(i)[e] = !1
            }, isTaken: function (e, i) {
                return !!t(i)[e]
            }
        };
        return i
    }),e("echarts/component/dataZoomSelect", [gr, "./dataZoom/typeDefaulter", "./dataZoom/DataZoomModel", "./dataZoom/DataZoomView", "./dataZoom/SelectZoomModel", "./dataZoom/SelectZoomView", "./dataZoom/dataZoomProcessor", "./dataZoom/dataZoomAction"], function (t) {
        t("./dataZoom/typeDefaulter"), t("./dataZoom/DataZoomModel"), t("./dataZoom/DataZoomView"), t("./dataZoom/SelectZoomModel"), t("./dataZoom/SelectZoomView"), t("./dataZoom/dataZoomProcessor"), t("./dataZoom/dataZoomAction")
    }),e("echarts/visual/VisualMapping", [gr, vr, "zrender/tool/color", yi], function (t) {
        function e(t) {
            var e = t.pieceList;
            t.hasSpecialVisual = !1, c.each(e, function (e, i) {
                e.originIndex = i, null != e.visual && (t.hasSpecialVisual = !0)
            })
        }

        function i(t) {
            var e = t[D], i = t.visual, n = t.categoryMap = {};
            if (d(e, function (t, e) {
                    n[t] = e
                }), !c[gn](i)) {
                var r = [];
                c[Bn](i) ? d(i, function (t, e) {
                    var i = n[e];
                    r[null != i ? i : p] = t
                }) : r[p] = i, i = t.visual = r
            }
            for (var a = e[zn] - 1; a >= 0; a--)null == i[a] && (delete n[e[a]], e.pop())
        }

        function n(t, e) {
            var i = t.visual, n = [];
            c[Bn](i) ? d(i, function (t) {
                n.push(t)
            }) : null != i && n.push(i);
            var r = {color: 1, symbol: 1};
            e || 1 !== n[zn] || t.type in r || (n[1] = n[0]), t.visual = n
        }

        function r(t) {
            return {
                applyVisual: function (e, i, n) {
                    e = this.mapValueToVisual(e), n("color", t(i("color"), e))
                }, mapValueToVisual: function (t) {
                    var e = this._normalizeData(t), i = this._getSpecifiedVisual(t), n = this[Pi].visual;
                    return null == i && (i = l(this) ? s(this, n, e) : h(e, [0, 1], n, !0)), i
                }
            }
        }

        function a(t, e) {
            return t[Math.round(h(e, [0, 1], [0, t[zn] - 1], !0))]
        }

        function o(t, e, i) {
            i("color", this.mapValueToVisual(t))
        }

        function s(t, e, i) {
            return e[t[Pi].loop && i !== p ? i % e[zn] : i]
        }

        function l(t) {
            return t[Pi].mappingMethod === be
        }

        var c = t(vr), u = t("zrender/tool/color"), h = t(yi)[ze], d = c.each, f = c[Bn], p = -1, v = function (t) {
            var r = t.mappingMethod, a = t.type, o = this[Pi] = c.clone(t);
            this.type = a, this.mappingMethod = r, this._normalizeData = m[r], this._getSpecifiedVisual = c.bind(y[r], this, a), c[On](this, g[a]), "piecewise" === r ? (n(o), e(o)) : r === be ? o[D] ? i(o) : n(o, !0) : (c.assert(o.dataExtent), n(o))
        };
        v[ir] = {
            constructor: v,
            applyVisual: null,
            isValueActive: null,
            mapValueToVisual: null,
            getNormalizer: function () {
                return c.bind(this._normalizeData, this)
            }
        };
        var g = v.visualHandlers = {
            color: {
                applyVisual: o, getColorMapper: function () {
                    var t = l(this) ? this[Pi].visual : c.map(this[Pi].visual, u.parse);
                    return c.bind(l(this) ? function (e, i) {
                        return !i && (e = this._normalizeData(e)), s(this, t, e)
                    } : function (e, i, n) {
                        var r = !!n;
                        return !i && (e = this._normalizeData(e)), n = u.fastMapToColor(e, t, n), r ? n : c.stringify(n, "rgba")
                    }, this)
                }, mapValueToVisual: function (t) {
                    var e = this[Pi].visual, i = this._normalizeData(t), n = this._getSpecifiedVisual(t);
                    return null == n && (n = l(this) ? s(this, e, i) : u.mapToColor(i, e)), n
                }
            }, colorHue: r(function (t, e) {
                return u.modifyHSL(t, e)
            }), colorSaturation: r(function (t, e) {
                return u.modifyHSL(t, null, e)
            }), colorLightness: r(function (t, e) {
                return u.modifyHSL(t, null, null, e)
            }), colorAlpha: r(function (t, e) {
                return u.modifyAlpha(t, e)
            }), opacity: {
                applyVisual: function (t, e, i) {
                    i(Hi, this.mapValueToVisual(t))
                }, mapValueToVisual: function (t) {
                    var e = this._normalizeData(t), i = this._getSpecifiedVisual(t), n = this[Pi].visual;
                    return null == i && (i = l(this) ? s(this, n, e) : h(e, [0, 1], n, !0)), i
                }
            }, symbol: {
                applyVisual: function (t, e, i) {
                    var n = this.mapValueToVisual(t);
                    if (c[an](n))i(_e, n); else if (f(n))for (var r in n)n.hasOwnProperty(r) && i(r, n[r])
                }, mapValueToVisual: function (t) {
                    var e = this._normalizeData(t), i = this._getSpecifiedVisual(t), n = this[Pi].visual;
                    return null == i && (i = l(this) ? s(this, n, e) : a(n, e) || {}), i
                }
            }, symbolSize: {
                applyVisual: function (t, e, i) {
                    i(xe, this.mapValueToVisual(t))
                }, mapValueToVisual: function (t) {
                    var e = this._normalizeData(t), i = this._getSpecifiedVisual(t), n = this[Pi].visual;
                    return null == i && (i = l(this) ? s(this, n, e) : h(e, [0, 1], n, !0)), i
                }
            }
        }, m = {
            linear: function (t) {
                return h(t, this[Pi].dataExtent, [0, 1], !0)
            }, piecewise: function (t) {
                var e = this[Pi].pieceList, i = v.findPieceIndex(t, e);
                return null != i ? h(i, [0, e[zn] - 1], [0, 1], !0) : void 0
            }, category: function (t) {
                var e = this[Pi][D] ? this[Pi].categoryMap[t] : t;
                return null == e ? p : e
            }
        }, y = {
            linear: c.noop, piecewise: function (t, e) {
                var i = this[Pi], n = i.pieceList;
                if (i.hasSpecialVisual) {
                    var r = v.findPieceIndex(e, n), a = n[r];
                    if (a && a.visual)return a.visual[t]
                }
            }, category: c.noop
        };
        return v.addVisualHandler = function (t, e) {
            g[t] = e
        }, v.isValidType = function (t) {
            return g.hasOwnProperty(t)
        }, v.eachVisual = function (t, e, i) {
            c[Bn](t) ? c.each(t, e, i) : e.call(i, t)
        }, v.mapVisual = function (t, e, i) {
            var n, r = c[gn](t) ? [] : c[Bn](t) ? {} : (n = !0, null);
            return v.eachVisual(t, function (t, a) {
                var o = e.call(i, t, a);
                n ? r = o : r[a] = o
            }), r
        }, v.retrieveVisuals = function (t) {
            var e, i = {};
            return t && d(g, function (n, r) {
                t.hasOwnProperty(r) && (i[r] = t[r], e = !0)
            }), e ? i : null
        }, v.prepareVisualTypes = function (t) {
            if (f(t)) {
                var e = [];
                d(t, function (t, i) {
                    e.push(i)
                }), t = e
            } else {
                if (!c[gn](t))return [];
                t = t.slice()
            }
            return t.sort(function (t, e) {
                return "color" === e && "color" !== t && 0 === t[vn]("color") ? 1 : -1
            }), t
        }, v.dependsOn = function (t, e) {
            return "color" === e ? !(!t || 0 !== t[vn](e)) : t === e
        }, v.findPieceIndex = function (t, e) {
            for (var i = 0, n = e[zn]; n > i; i++) {
                var r = e[i];
                if (null != r.value && r.value === t)return i
            }
            for (var i = 0, n = e[zn]; n > i; i++) {
                var r = e[i], a = r[Q];
                if (a)if (a[0] === -1 / 0) {
                    if (t < a[1])return i
                } else if (1 / 0 === a[1]) {
                    if (a[0] < t)return i
                } else if (r[Q][0] <= t && t <= r[Q][1])return i
            }
        }, v
    }),e("echarts/component/helper/RoamController", [gr, "zrender/mixin/Eventful", vr, "zrender/core/event", "./interactionMutex"], function (t) {
        function e(t) {
            if (!t[Sn] || !t[Sn][_]) {
                var e = t[F], i = t[Z], n = this.rectProvider && this.rectProvider();
                n && n[mi](e, i) && (this._x = e, this._y = i, this._dragging = !0)
            }
        }

        function i(t) {
            if (this._dragging && (u.stop(t.event), "pinch" !== t.gestureEvent)) {
                if (d.isTaken("globalPan", this._zr))return;
                var e = t[F], i = t[Z], n = e - this._x, r = i - this._y;
                this._x = e, this._y = i;
                var a = this[Sn];
                if (a) {
                    var o = a[Ui];
                    o[0] += n, o[1] += r, a.dirty()
                }
                u.stop(t.event), this[Pn]("pan", n, r)
            }
        }

        function n() {
            this._dragging = !1
        }

        function r(t) {
            var e = t.wheelDelta > 0 ? 1.1 : 1 / 1.1;
            o.call(this, t, e, t[F], t[Z])
        }

        function a(t) {
            if (!d.isTaken("globalPan", this._zr)) {
                var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
                o.call(this, t, e, t.pinchX, t.pinchY)
            }
        }

        function o(t, e, i, n) {
            var r = this.rectProvider && this.rectProvider();
            if (r && r[mi](i, n)) {
                u.stop(t.event);
                var a = this[Sn], o = this[L];
                if (a) {
                    var s = a[Ui], l = a.scale, c = this.zoom = this.zoom || 1;
                    if (c *= e, o) {
                        var h = o.min || 0, d = o.max || 1 / 0;
                        c = Math.max(Math.min(d, c), h)
                    }
                    var f = c / this.zoom;
                    this.zoom = c, s[0] -= (i - s[0]) * (f - 1), s[1] -= (n - s[1]) * (f - 1), l[0] *= f, l[1] *= f, a.dirty()
                }
                this[Pn]("zoom", e, i, n)
            }
        }

        function s(t, o, s) {
            this[Sn] = o, this.rectProvider = s, this[L], this.zoom, this._zr = t;
            var u = c.bind, d = u(e, this), f = u(i, this), p = u(n, this), v = u(r, this), g = u(a, this);
            l.call(this), this[W] = function (e) {
                this.disable(), null == e && (e = !0), (e === !0 || "move" === e || "pan" === e) && (t.on("mousedown", d), t.on(h, f), t.on("mouseup", p)), (e === !0 || "scale" === e || "zoom" === e) && (t.on("mousewheel", v), t.on("pinch", g))
            }, this.disable = function () {
                t.off("mousedown", d), t.off(h, f), t.off("mouseup", p), t.off("mousewheel", v), t.off("pinch", g)
            }, this[kn] = this.disable, this.isDragging = function () {
                return this._dragging
            }, this.isPinching = function () {
                return this._pinching
            }
        }

        var l = t("zrender/mixin/Eventful"), c = t(vr), u = t("zrender/core/event"), d = t("./interactionMutex");
        return c.mixin(s, l), s
    }),e("echarts/coord/radar/IndicatorAxis", [gr, vr, "../Axis"], function (t) {
        function e(t, e, i) {
            n.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model
        }

        var i = t(vr), n = t("../Axis");
        return i[on](e, n), e
    }),e("echarts/component/axis/RadiusAxisView", [gr, vr, vi, "./AxisBuilder", Ri], function (t) {
        function e(t, e, i) {
            return {
                position: [t.cx, t.cy],
                rotation: i / 180 * Math.PI,
                labelDirection: -1,
                tickDirection: -1,
                nameDirection: 1,
                labelRotation: e[Jn](A).get(l),
                z2: 1
            }
        }

        var i = t(vr), n = t(vi), r = t("./AxisBuilder"), a = [T, A, C, "axisName"], o = ["splitLine", "splitArea"];
        t(Ri)[cn]({
            type: "radiusAxis", render: function (t, n) {
                if (this.group[rn](), t.get("show")) {
                    var s = n[ve]("polar", t.get(Y)), l = s[Ni].getAngleAxis(), c = t.axis, u = s[Ni], h = c.getTicksCoords(), d = l[we]()[0], f = c[we](), p = e(u, t, d), v = new r(t, p);
                    i.each(a, v.add, v), this.group.add(v.getGroup()), i.each(o, function (e) {
                        t.get(e + ".show") && this["_" + e](t, u, d, f, h)
                    }, this)
                }
            }, _splitLine: function (t, e, r, a, o) {
                var s = t[Jn]("splitLine"), l = s[Jn](lr), c = l.get("color"), u = 0;
                c = c instanceof Array ? c : [c];
                for (var h = [], d = 0; d < o[zn]; d++) {
                    var f = u++ % c[zn];
                    h[f] = h[f] || [], h[f].push(new n[y]({shape: {cx: e.cx, cy: e.cy, r: o[d]}, silent: !0}))
                }
                for (var d = 0; d < h[zn]; d++)this.group.add(n.mergePath(h[d], {
                    style: i[Vn]({
                        stroke: c[d % c[zn]],
                        fill: null
                    }, l[Ue]()), silent: !0
                }))
            }, _splitArea: function (t, e, r, a, o) {
                var s = t[Jn]("splitArea"), l = s[Jn]("areaStyle"), c = l.get("color"), u = 0;
                c = c instanceof Array ? c : [c];
                for (var h = [], d = o[0], f = 1; f < o[zn]; f++) {
                    var p = u++ % c[zn];
                    h[p] = h[p] || [], h[p].push(new n[ui]({
                        shape: {
                            cx: e.cx,
                            cy: e.cy,
                            r0: d,
                            r: o[f],
                            startAngle: 0,
                            endAngle: 2 * Math.PI
                        }, silent: !0
                    })), d = o[f]
                }
                for (var f = 0; f < h[zn]; f++)this.group.add(n.mergePath(h[f], {
                    style: i[Vn]({fill: c[f % c[zn]]}, l[z]()),
                    silent: !0
                }))
            }
        })
    }),e("echarts/data/Graph", [gr, vr], function (t) {
        function e(t, e) {
            this.id = null == t ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this[Mn] = null == e ? -1 : e
        }

        function i(t, e, i) {
            this.node1 = t, this.node2 = e, this[Mn] = null == i ? -1 : i
        }

        var n = t(vr), r = function (t) {
            this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData
        }, a = r[ir];
        a.type = "graph", a.isDirected = function () {
            return this._directed
        }, a.addNode = function (t, i) {
            t = t || "" + i;
            var n = this._nodesMap;
            if (!n[t]) {
                var r = new e(t, i);
                return r.hostGraph = this, this.nodes.push(r), n[t] = r, r
            }
        }, a.getNodeByIndex = function (t) {
            var e = this.data[Si](t);
            return this.nodes[e]
        }, a.getNodeById = function (t) {
            return this._nodesMap[t]
        }, a.addEdge = function (t, n, r) {
            var a = this._nodesMap, o = this._edgesMap;
            if (typeof t === sn && (t = this.nodes[t]), typeof n === sn && (n = this.nodes[n]), t instanceof e || (t = a[t]), n instanceof e || (n = a[n]), t && n) {
                var s = t.id + "-" + n.id;
                if (!o[s]) {
                    var l = new i(t, n, r);
                    return l.hostGraph = this, this._directed && (t.outEdges.push(l), n.inEdges.push(l)), t.edges.push(l), t !== n && n.edges.push(l), this.edges.push(l), o[s] = l, l
                }
            }
        }, a.getEdgeByIndex = function (t) {
            var e = this.edgeData[Si](t);
            return this.edges[e]
        }, a.getEdge = function (t, i) {
            t instanceof e && (t = t.id), i instanceof e && (i = i.id);
            var n = this._edgesMap;
            return this._directed ? n[t + "-" + i] : n[t + "-" + i] || n[i + "-" + t]
        }, a.eachNode = function (t, e) {
            for (var i = this.nodes, n = i[zn], r = 0; n > r; r++)i[r][Mn] >= 0 && t.call(e, i[r], r)
        }, a.eachEdge = function (t, e) {
            for (var i = this.edges, n = i[zn], r = 0; n > r; r++)i[r][Mn] >= 0 && i[r].node1[Mn] >= 0 && i[r].node2[Mn] >= 0 && t.call(e, i[r], r)
        }, a.breadthFirstTraverse = function (t, i, n, r) {
            if (i instanceof e || (i = this._nodesMap[i]), i) {
                for (var a = "out" === n ? "outEdges" : "in" === n ? "inEdges" : "edges", o = 0; o < this.nodes[zn]; o++)this.nodes[o].__visited = !1;
                if (!t.call(r, i, null))for (var s = [i]; s[zn];)for (var l = s.shift(), c = l[a], o = 0; o < c[zn]; o++) {
                    var u = c[o], h = u.node1 === l ? u.node2 : u.node1;
                    if (!h.__visited) {
                        if (t.call(h, h, l))return;
                        s.push(h), h.__visited = !0
                    }
                }
            }
        }, a[Gn] = function () {
            for (var t = this.data, e = this.edgeData, i = this.nodes, n = this.edges, r = 0, a = i[zn]; a > r; r++)i[r][Mn] = -1;
            for (var r = 0, a = t.count(); a > r; r++)i[t[Si](r)][Mn] = r;
            e.filterSelf(function (t) {
                var i = n[e[Si](t)];
                return i.node1[Mn] >= 0 && i.node2[Mn] >= 0
            });
            for (var r = 0, a = n[zn]; a > r; r++)n[r][Mn] = -1;
            for (var r = 0, a = e.count(); a > r; r++)n[e[Si](r)][Mn] = r
        }, a.clone = function () {
            for (var t = new r(this._directed), e = this.nodes, i = this.edges, n = 0; n < e[zn]; n++)t.addNode(e[n].id, e[n][Mn]);
            for (var n = 0; n < i[zn]; n++) {
                var a = i[n];
                t.addEdge(a.node1.id, a.node2.id, a[Mn])
            }
            return t
        }, e[ir] = {
            constructor: e, degree: function () {
                return this.edges[zn]
            }, inDegree: function () {
                return this.inEdges[zn]
            }, outDegree: function () {
                return this.outEdges[zn]
            }, getModel: function (t) {
                if (!(this[Mn] < 0)) {
                    var e = this.hostGraph, i = e.data[Ai](this[Mn]);
                    return i[Jn](t)
                }
            }
        }, i[ir][Jn] = function (t) {
            if (!(this[Mn] < 0)) {
                var e = this.hostGraph, i = e.edgeData[Ai](this[Mn]);
                return i[Jn](t)
            }
        };
        var o = function (t, e) {
            return {
                getValue: function (i) {
                    var n = this[t][e];
                    return n.get(n.getDimension(i || "value"), this[Mn])
                }, setVisual: function (i, n) {
                    this[Mn] >= 0 && this[t][e][wi](this[Mn], i, n)
                }, getVisual: function (i, n) {
                    return this[t][e][Mi](this[Mn], i, n)
                }, setLayout: function (i, n) {
                    this[Mn] >= 0 && this[t][e][Ve](this[Mn], i, n)
                }, getLayout: function () {
                    return this[t][e][fi](this[Mn])
                }, getGraphicEl: function () {
                    return this[t][e][pi](this[Mn])
                }, getRawIndex: function () {
                    return this[t][e][Si](this[Mn])
                }
            }
        };
        return n.mixin(e, o("hostGraph", "data")), n.mixin(i, o("hostGraph", "edgeData")), r.Node = e, r.Edge = i, r
    }),e("echarts/component/dataZoom/roams", [gr, vr, "../../component/helper/RoamController", "../../util/throttle"], function (t) {
        function e(t) {
            var e = t.getZr();
            return e[d] || (e[d] = {})
        }

        function i(t, e, i) {
            var n = new c(t.getZr());
            return n[W](), n.on("pan", h(r, i)), n.on("zoom", h(a, i)), n
        }

        function n(t) {
            l.each(t, function (e, i) {
                e.count || (e.controller.off("pan").off("zoom"), delete t[i])
            })
        }

        function r(t, e, i) {
            o(t, function (n) {
                return n.panGetRange(t.controller, e, i)
            })
        }

        function a(t, e, i, n) {
            o(t, function (r) {
                return r.zoomGetRange(t.controller, e, i, n)
            })
        }

        function o(t, e) {
            var i = [];
            l.each(t.dataZoomInfos, function (t) {
                var n = e(t);
                n && i.push({dataZoomId: t.dataZoomId, start: n[0], end: n[1]})
            }), t[Rn](i)
        }

        function s(t, e) {
            t[Rn]({type: "dataZoom", batch: e})
        }

        var l = t(vr), c = t("../../component/helper/RoamController"), u = t("../../util/throttle"), h = l.curry, d = "\x00_ec_dataZoom_roams", f = {
            register: function (t, r) {
                var a = e(t), o = r.dataZoomId, c = r.coordId;
                l.each(a, function (t) {
                    var e = t.dataZoomInfos;
                    e[o] && l[vn](r.allCoordIds, c) < 0 && (delete e[o], t.count--)
                }), n(a);
                var h = a[c];
                h || (h = a[c] = {
                    coordId: c,
                    dataZoomInfos: {},
                    count: 0
                }, h.controller = i(t, r, h), h[Rn] = l.curry(s, t));
                var d = r[Ni][Ci]().clone();
                h.controller.rectProvider = function () {
                    return d
                }, u.createOrUpdate(h, Rn, r.throttleRate, "fixRate"), !h.dataZoomInfos[o] && h.count++, h.dataZoomInfos[o] = r
            }, unregister: function (t, i) {
                var r = e(t);
                l.each(r, function (t) {
                    var e = t.dataZoomInfos;
                    e[i] && (delete e[i], t.count--)
                }), n(r)
            }, shouldRecordRange: function (t, e) {
                if (t && "dataZoom" === t.type && t.batch)for (var i = 0, n = t.batch[zn]; n > i; i++)if (t.batch[i].dataZoomId === e)return !1;
                return !0
            }, generateCoordId: function (t) {
                return t.type + "\x00_" + t.id
            }
        };
        return f
    }),e("echarts/component/timeline/TimelineView", [gr, "../../view/Component"], function (t) {
        var e = t("../../view/Component");
        return e[On]({type: "timeline"})
    }),e("echarts/component/timeline/TimelineAxis", [gr, vr, "../../coord/Axis", "../../coord/axisHelper"], function (t) {
        var e = t(vr), i = t("../../coord/Axis"), n = t("../../coord/axisHelper"), r = function (t, e, n, r) {
            i.call(this, t, e, n), this.type = r || "value", this._autoLabelInterval, this.model = null
        };
        return r[ir] = {
            constructor: r, getLabelInterval: function () {
                var t = this.model, i = t[Jn](Xe), r = i.get(Q);
                if (null != r && "auto" != r)return r;
                var r = this._autoLabelInterval;
                return r || (r = this._autoLabelInterval = n.getAxisLabelInterval(e.map(this.scale[oe](), this[te], this), n[pe](this, i.get(M)), i[Jn](nn)[tn](), t.get(u) === Ae)), r
            }, isLabelIgnored: function (t) {
                if (this.type === be) {
                    var e = this.getLabelInterval();
                    return typeof e === fn && !e(t, this.scale[ae](t)) || t % (e + 1)
                }
            }
        }, e[on](r, i), r
    }),e("echarts/component/dataZoom/SelectZoomModel", [gr, "./DataZoomModel"], function (t) {
        var e = t("./DataZoomModel");
        return e[On]({type: "dataZoom.select"})
    }),e("echarts/component/dataZoom/SelectZoomView", [gr, "./DataZoomView"], function (t) {
        return t("./DataZoomView")[On]({type: "dataZoom.select"})
    }),e("echarts/component/visualMap/VisualMapModel", [gr, vr, sr, Ri, Ei, "../../visual/visualDefault", "../../visual/VisualMapping", Be], function (t) {
        function e(t, e) {
            var n, r = ["inRange", "outOfRange", Sn, "controller", "color"];
            i.each(r, function (t) {
                e.hasOwnProperty(t) && (n = !0)
            }), n && i.each(r, function (n) {
                e.hasOwnProperty(n) ? t[n] = i.clone(e[n]) : delete t[n]
            })
        }

        var i = t(vr), n = t(sr), r = t(Ri), a = t(Ei), o = t("../../visual/visualDefault"), s = t("../../visual/VisualMapping"), l = s.mapVisual, c = s.eachVisual, u = t(Be), h = i[gn], d = i.each, f = u.asc, p = u[ze], v = r[un]({
            type: "visualMap",
            dependencies: [Dn],
            dataBound: [-1 / 0, 1 / 0],
            stateList: ["inRange", "outOfRange"],
            layoutMode: {type: "box", ignoreSize: !0},
            defaultOption: {
                show: !0,
                zlevel: 0,
                z: 4,
                min: 0,
                max: 200,
                dimension: null,
                inRange: null,
                outOfRange: null,
                left: 0,
                right: null,
                top: null,
                bottom: 0,
                itemWidth: null,
                itemHeight: null,
                inverse: !1,
                orient: "vertical",
                seriesIndex: null,
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                contentColor: "#5793f3",
                inactiveColor: "#aaa",
                borderWidth: 0,
                padding: 5,
                textGap: 10,
                precision: 0,
                color: ["#bf444c", "#d88273", "#f6efa6"],
                formatter: null,
                text: null,
                textStyle: {color: "#333"}
            },
            init: function (t, e, i) {
                this._dataExtent, this.controllerVisuals = {}, this.targetVisuals = {}, this.textStyleModel, this.itemSize, this[P](t, i), this.doMergeOption({}, !0)
            },
            mergeOption: function (t) {
                v[Vi](this, zi, arguments), this.doMergeOption(t, !1)
            },
            doMergeOption: function (t, i) {
                var r = this[Pi];
                !i && e(r, t), n[Xn] || (r.realtime = !1), this.textStyleModel = this[Jn](nn), this.resetItemSize(), this.completeVisualOption()
            },
            formatValueText: function (t, e) {
                function n(t) {
                    return t === l[0] ? "min" : t === l[1] ? "max" : (+t)[Di](s)
                }

                var r, a, o = this[Pi], s = o.precision, l = this.dataBound, c = o[M];
                return i[gn](t) && (t = t.slice(), r = !0), a = e ? t : r ? [n(t[0]), n(t[1])] : n(t), i[an](c) ? c[mn]("{value}", r ? a[0] : a)[mn]("{value2}", r ? a[1] : a) : i.isFunction(c) ? r ? c(t[0], t[1]) : c(t) : r ? t[0] === l[0] ? "< " + a[1] : t[1] === l[1] ? "> " + a[0] : a[0] + " - " + a[1] : a
            },
            resetTargetSeries: function () {
                var t = this[Pi], e = null == t[bn];
                t[bn] = e ? [] : a[b](t[bn]), e && this[j][In](function (e, i) {
                    var n = e[ur]();
                    "list" === n.type && t[bn].push(i)
                })
            },
            resetExtent: function () {
                var t = this[Pi], e = f([t.min, t.max]);
                this._dataExtent = e
            },
            getDataDimension: function (t) {
                var e = this[Pi].dimension;
                return null != e ? e : t[Te][zn] - 1
            },
            getExtent: function () {
                return this._dataExtent.slice()
            },
            resetVisual: function (t) {
                function e(e, a) {
                    d(this.stateList, function (o) {
                        var l = a[o] || (a[o] = n()), c = this[Pi][e][o] || {};
                        d(c, function (n, a) {
                            if (s.isValidType(a)) {
                                var c = {type: a, dataExtent: r, visual: n};
                                t && t.call(this, c, o), l[a] = new s(c), "controller" === e && a === Hi && (c = i.clone(c), c.type = "colorAlpha", l.__hidden.__alphaForOpacity = new s(c))
                            }
                        }, this)
                    }, this)
                }

                function n() {
                    var t = function () {
                    };
                    t[ir].__hidden = t[ir];
                    var e = new t;
                    return e
                }

                var r = this[we]();
                e.call(this, "controller", this.controllerVisuals), e.call(this, Sn, this.targetVisuals)
            },
            completeVisualOption: function () {
                function t(t) {
                    h(r.color) && !t.inRange && (t.inRange = {color: r.color.slice()[k]()}), d(this.stateList, function (e) {
                        var n = t[e];
                        if (i[an](n)) {
                            var r = o.get(n, "active", v);
                            r ? (t[e] = {}, t[e][n] = r) : delete t[e]
                        }
                    }, this)
                }

                function e(t, e, i) {
                    var n = t[e], r = t[i];
                    n && !r && (r = t[i] = {}, d(n, function (t, e) {
                        if (s.isValidType(e)) {
                            var i = o.get(e, "inactive", v);
                            null != i && (r[e] = i, "color" !== e || r.hasOwnProperty(Hi) || r.hasOwnProperty("colorAlpha") || (r[Hi] = [0, 0]))
                        }
                    }))
                }

                function n(t) {
                    var e = (t.inRange || {})[_e] || (t.outOfRange || {})[_e], n = (t.inRange || {})[xe] || (t.outOfRange || {})[xe], r = this.get("inactiveColor");
                    d(this.stateList, function (a) {
                        var o = this.itemSize, s = t[a];
                        s || (s = t[a] = {color: v ? r : [r]}), null == s[_e] && (s[_e] = e && i.clone(e) || (v ? "roundRect" : ["roundRect"])), null == s[xe] && (s[xe] = n && i.clone(n) || (v ? o[0] : [o[0], o[0]])), s[_e] = l(s[_e], function (t) {
                            return "none" === t || "square" === t ? "roundRect" : t
                        });
                        var u = s[xe];
                        if (null != u) {
                            var h = -1 / 0;
                            c(u, function (t) {
                                t > h && (h = t)
                            }), s[xe] = l(u, function (t) {
                                return p(t, [0, h], [0, o[0]], !0)
                            })
                        }
                    }, this)
                }

                var r = this[Pi], a = {
                    inRange: r.inRange,
                    outOfRange: r.outOfRange
                }, u = r[Sn] || (r[Sn] = {}), f = r.controller || (r.controller = {});
                i.merge(u, a), i.merge(f, a);
                var v = this.isCategory();
                t.call(this, u), t.call(this, f), e.call(this, u, "inRange", "outOfRange"), e.call(this, u, "outOfRange", "inRange"), n.call(this, f)
            },
            eachTargetSeries: function (t, e) {
                i.each(this[Pi][bn], function (i) {
                    t.call(e, this[j].getSeriesByIndex(i))
                }, this)
            },
            isCategory: function () {
                return !!this[Pi][D]
            },
            resetItemSize: function () {
                this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))]
            },
            setSelected: i.noop,
            getValueState: i.noop
        });
        return v
    }),e("echarts/action/roamHelper", [gr], function () {
        var t = {};
        return t.updateCenterAndZoom = function (t, e, i) {
            var n = t.getZoom(), r = t.getCenter(), a = e.zoom, o = t[Se](r);
            if (null != e.dx && null != e.dy) {
                o[0] -= e.dx, o[1] -= e.dy;
                var r = t.pointToData(o);
                t.setCenter(r)
            }
            if (null != a) {
                if (i) {
                    var s = i.min || 0, l = i.max || 1 / 0;
                    a = Math.max(Math.min(n * a, l), s) / n
                }
                t.scale[0] *= a, t.scale[1] *= a;
                var c = t[Ui], u = (e.originX - c[0]) * (a - 1), h = (e.originY - c[1]) * (a - 1);
                c[0] -= u, c[1] -= h, t.updateTransform();
                var r = t.pointToData(o);
                t.setCenter(r), t.setZoom(a * n)
            }
            return {center: t.getCenter(), zoom: t.getZoom()}
        }, t
    }),e("echarts/coord/parallel/ParallelAxis", [gr, vr, "../Axis"], function (t) {
        var e = t(vr), i = t("../Axis"), n = function (t, e, n, r, a) {
            i.call(this, t, e, n), this.type = r || "value", this.axisIndex = a
        };
        return n[ir] = {constructor: n, model: null}, e[on](n, i), n
    }),e("echarts/chart/treemap/helper", [gr, vr], function (t) {
        var e = t(vr), i = {
            retrieveTargetInfo: function (t, e) {
                if (t && ("treemapZoomToNode" === t.type || "treemapRootToNode" === t.type)) {
                    var i = e[ur]().tree.root, n = t.targetNode;
                    if (n && i.contains(n))return {node: n};
                    var r = t.targetNodeId;
                    if (null != r && (n = i.getNodeById(r)))return {node: n}
                }
            }, getPathToRoot: function (t) {
                for (var e = []; t;)t = t[B], t && e.push(t);
                return e[k]()
            }, aboveViewRoot: function (t, n) {
                var r = i.getPathToRoot(t);
                return e[vn](r, n) >= 0
            }
        };
        return i
    }),e("echarts/chart/treemap/Breadcrumb", [gr, vi, me, vr], function (t) {
        function e(t, e) {
            this.group = new n.Group, t.add(this.group), this._onSelect = e || a.noop
        }

        function i(t, e, i, n, r, a) {
            var o = [[r ? t : t - l, e], [t + i, e], [t + i, e + n], [r ? t : t - l, e + n]];
            return !a && o[Ln](2, 0, [t + i + l, e + n / 2]), !r && o.push([t, e + n / 2]), o
        }

        var n = t(vi), r = t(me), a = t(vr), o = 8, s = 8, l = 5;
        return e[ir] = {
            constructor: e, render: function (t, e, i) {
                var n = t[Jn]("breadcrumb"), a = this.group;
                if (a[rn](), n.get("show") && i) {
                    var o = n[Jn](ie), s = o[Jn](nn), l = {
                        pos: {
                            left: n.get("left"),
                            right: n.get("right"),
                            top: n.get("top"),
                            bottom: n.get(Hn)
                        },
                        box: {width: e[Kn](), height: e[Yn]()},
                        emptyItemWidth: n.get("emptyItemWidth"),
                        totalWidth: 0,
                        renderList: []
                    };
                    this._prepare(n, i, l, s), this._renderContent(n, i, l, o, s), r.positionGroup(a, l.pos, l.box)
                }
            }, _prepare: function (t, e, i, n) {
                for (var r = e; r; r = r[B]) {
                    var a = r[Jn]().get("name"), l = n.getTextRect(a), c = Math.max(l.width + 2 * o, i.emptyItemWidth);
                    i.totalWidth += c + s, i.renderList.push({node: r, text: a, width: c})
                }
            }, _renderContent: function (t, e, o, l, c) {
                for (var u = 0, h = o.emptyItemWidth, d = t.get(Fn), f = r.getAvailableSize(o.pos, o.box), p = o.totalWidth, v = o.renderList, g = v[zn] - 1; g >= 0; g--) {
                    var m = v[g], y = m.width, x = m.text;
                    p > f.width && (p -= y - h, y = h, x = ""), this.group.add(new n[R]({
                        shape: {points: i(u, 0, y, d, g === v[zn] - 1, 0 === g)},
                        style: a[Vn](l[Wi](), {lineJoin: "bevel", text: x, textFill: c[$i](), textFont: c[tn]()}),
                        z: 10,
                        onclick: a.bind(this._onSelect, this, m.node)
                    })), u += y + s
                }
            }, remove: function () {
                this.group[rn]()
            }
        }, e
    }),e("echarts/util/array/nest", [gr, vr], function (t) {
        function e() {
            function t(e, r) {
                if (r >= n[zn])return e;
                for (var a = -1, o = e[zn], s = n[r++], l = {}, c = {}; ++a < o;) {
                    var u = s(e[a]), h = c[u];
                    h ? h.push(e[a]) : c[u] = [e[a]]
                }
                return i.each(c, function (e, i) {
                    l[i] = t(e, r)
                }), l
            }

            function e(t, a) {
                if (a >= n[zn])return t;
                var o = [], s = r[a++];
                return i.each(t, function (t, i) {
                    o.push({key: i, values: e(t, a)})
                }), s ? o.sort(function (t, e) {
                    return s(t.key, e.key)
                }) : o
            }

            var n = [], r = [];
            return {
                key: function (t) {
                    return n.push(t), this
                }, sortKeys: function (t) {
                    return r[n[zn] - 1] = t, this
                }, entries: function (i) {
                    return e(t(i, 0), 0)
                }
            }
        }

        var i = t(vr);
        return e
    }),e("echarts/util/animation", [gr, vr], function (t) {
        function e() {
            var t, e = [], n = {};
            return {
                add: function (t, r, a, o, s) {
                    return i[an](o) && (s = o, o = 0), n[t.id] ? !1 : (n[t.id] = 1, e.push({
                        el: t,
                        target: r,
                        time: a,
                        delay: o,
                        easing: s
                    }), !0)
                }, done: function (e) {
                    return t = e, this
                }, start: function () {
                    function i() {
                        r--, r || (e[zn] = 0, n = {}, t && t())
                    }

                    for (var r = e[zn], a = 0, o = e[zn]; o > a; a++) {
                        var s = e[a];
                        s.el.animateTo(s[Sn], s.time, s.delay, s.easing, i)
                    }
                    return this
                }
            }
        }

        var i = t(vr);
        return {createWrap: e}
    }),e("echarts/visual/visualDefault", [gr, vr], function (t) {
        var e = t(vr), i = {
            get: function (t, i, r) {
                var a = e.clone((n[t] || {})[i]);
                return r && e[gn](a) ? a[a[zn] - 1] : a
            }
        }, n = {
            color: {active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"]},
            colorHue: {active: [0, 360], inactive: [0, 0]},
            colorSaturation: {active: [.3, 1], inactive: [0, 0]},
            colorLightness: {active: [.9, .5], inactive: [0, 0]},
            colorAlpha: {active: [.3, 1], inactive: [0, 0]},
            opacity: {active: [.3, 1], inactive: [0, 0]},
            symbol: {active: [dr, "roundRect", "diamond"], inactive: ["none"]},
            symbolSize: {active: [10, 50], inactive: [0, 0]}
        };
        return i
    }),e("echarts/coord/parallel/AxisModel", [gr, c, vr, "../../model/mixin/makeStyleMapper", "../axisModelCreator", Be, "../axisModelCommonMixin"], function (t) {
        function e(t, e) {
            return e.type || (e.data ? be : "value")
        }

        var i = t(c), n = t(vr), r = t("../../model/mixin/makeStyleMapper"), a = t("../axisModelCreator"), o = t(Be), s = i[On]({
            type: "baseParallelAxis",
            axis: null,
            activeIntervals: [],
            getAreaSelectStyle: function () {
                return r([["fill", "color"], [m, "borderWidth"], [Ne, Ge], ["width", "width"], [Hi, Hi]]).call(this[Jn]("areaSelectStyle"))
            },
            setActiveIntervals: function (t) {
                var e = this.activeIntervals = n.clone(t);
                if (e)for (var i = e[zn] - 1; i >= 0; i--)o.asc(e[i])
            },
            getActiveState: function (t) {
                var e = this.activeIntervals;
                if (!e[zn])return Li;
                if (null == t)return "inactive";
                for (var i = 0, n = e[zn]; n > i; i++)if (e[i][0] <= t && t <= e[i][1])return "active";
                return "inactive"
            }
        }), l = {
            type: "value",
            dim: null,
            parallelIndex: null,
            areaSelectStyle: {
                width: 20,
                borderWidth: 1,
                borderColor: "rgba(160,197,232)",
                color: "rgba(160,197,232)",
                opacity: .3
            },
            z: 10
        };
        return n.merge(s[ir], t("../axisModelCommonMixin")), a(g, s, e, l), s
    }),e("echarts/component/axis/parallelAxisAction", [gr, Ri], function (t) {
        var e = t(Ri), i = {type: "axisAreaSelect", event: "axisAreaSelected", update: "updateVisual"};
        e[pn](i, function (t, e) {
            e[qn]({mainType: "parallelAxis", query: t}, function (e) {
                e.axis.model.setActiveIntervals(t.intervals)
            })
        })
    }),e("echarts/component/visualMap/helper", [gr, me, vr, "../../data/DataDiffer"], function (t) {
        var e = t(me), i = t(vr), n = t("../../data/DataDiffer"), r = {
            getItemAlign: function (t, i, n) {
                var r = t[Pi], a = r.align;
                if (null != a && "auto" !== a)return a;
                for (var o = {
                    width: i[Kn](),
                    height: i[Yn]()
                }, s = r[u] === Ae ? 1 : 0, l = [["left", "right", "width"], ["top", Hn, Fn]], c = l[s], h = [0, null, 10], d = {}, f = 0; 3 > f; f++)d[l[1 - s][f]] = h[f], d[c[f]] = 2 === f ? n[0] : r[c[f]];
                var p = [["x", "width", 3], ["y", Fn, 0]][s], v = e[Ki](d, o, r[Yi]);
                return c[(v.margin[p[2]] || 0) + v[p[0]] + .5 * v[p[1]] < .5 * o[p[1]] ? 0 : 1]
            }, convertDataIndicesToBatch: function (t) {
                var e = [];
                return i.each(t, function (t) {
                    i.each(t.dataIndices, function (i) {
                        e.push({seriesId: t.seriesId, dataIndex: i})
                    })
                }), e
            }, removeDuplicateBatch: function (t, e) {
                function r(t) {
                    return t.seriesId + "-" + t[Mn]
                }

                function a(t) {
                    s[1].push(e[t])
                }

                function o(e) {
                    s[0].push(t[e])
                }

                var s = [[], []];
                return new n(t, e, r, r).add(a)[Gn](i.noop)[En](o)[qe](), s
            }
        };
        return r
    }),e("echarts/chart/graph/adjustEdge", [gr, "zrender/core/curve", ar], function (t) {
        function e(t, e, i) {
            for (var n, u = t[0], h = t[1], d = t[2], f = 1 / 0, p = i * i, v = .1, g = .1; .9 >= g; g += .1) {
                r[0] = s(u[0], h[0], d[0], g), r[1] = s(u[1], h[1], d[1], g);
                var m = c(l(r, e) - p);
                f > m && (f = m, n = g)
            }
            for (var y = 0; 32 > y; y++) {
                var x = n + v;
                a[0] = s(u[0], h[0], d[0], n), a[1] = s(u[1], h[1], d[1], n), o[0] = s(u[0], h[0], d[0], x), o[1] = s(u[1], h[1], d[1], x);
                var m = l(a, e) - p;
                if (c(m) < .01)break;
                var _ = l(o, e) - p;
                v /= 2, 0 > m ? _ >= 0 ? n += v : n -= v : _ >= 0 ? n -= v : n += v
            }
            return n
        }

        var i = t("zrender/core/curve"), n = t(ar), r = [], a = [], o = [], s = i.quadraticAt, l = n.distSquare, c = Math.abs;
        return function (t, r) {
            var a = [], o = i.quadraticSubdivide, s = [[], [], []], l = [[], []], c = [];
            r /= 2, t.eachEdge(function (t) {
                var i = t[H](), u = t[G]("fromSymbol"), h = t[G]("toSymbol");
                i.__original || (i.__original = [n.clone(i[0]), n.clone(i[1])], i[2] && i.__original.push(n.clone(i[2])));
                var d = i.__original;
                if (null != i[2]) {
                    if (n.copy(s[0], d[0]), n.copy(s[1], d[2]), n.copy(s[2], d[1]), u && "none" != u) {
                        var f = e(s, d[0], t.node1[G](xe) * r);
                        o(s[0][0], s[1][0], s[2][0], f, a), s[0][0] = a[3], s[1][0] = a[4], o(s[0][1], s[1][1], s[2][1], f, a), s[0][1] = a[3], s[1][1] = a[4]
                    }
                    if (h && "none" != h) {
                        var f = e(s, d[1], t.node2[G](xe) * r);
                        o(s[0][0], s[1][0], s[2][0], f, a), s[1][0] = a[1], s[2][0] = a[2], o(s[0][1], s[1][1], s[2][1], f, a), s[1][1] = a[1], s[2][1] = a[2]
                    }
                    n.copy(i[0], s[0]), n.copy(i[1], s[2]), n.copy(i[2], s[1])
                } else n.copy(l[0], d[0]), n.copy(l[1], d[1]), n.sub(c, l[1], l[0]), n[gi](c, c), u && "none" != u && n.scaleAndAdd(l[0], l[0], c, t.node1[G](xe) * r), h && "none" != h && n.scaleAndAdd(l[1], l[1], c, -t.node2[G](xe) * r), n.copy(i[0], l[0]), n.copy(i[1], l[1])
            })
        }
    }),e("echarts/chart/graph/simpleLayoutHelper", [gr, "./simpleLayoutEdge"], function (t) {
        var e = t("./simpleLayoutEdge");
        return function (t) {
            var i = t[Ni];
            if (!i || "view" === i.type) {
                var n = t[I]();
                n.eachNode(function (t) {
                    var e = t[Jn]();
                    t[$]([+e.get("x"), +e.get("y")])
                }), e(n)
            }
        }
    }),e("echarts/component/axis/ParallelAxisView", [gr, vr, "./AxisBuilder", "../helper/SelectController", Ri], function (t) {
        function e(t, e, i) {
            return i && "axisAreaSelect" === i.type && e[_i]({mainType: "parallelAxis", query: i})[0] === t
        }

        var i = t(vr), n = t("./AxisBuilder"), r = t("../helper/SelectController"), a = [T, A, C, "axisName"], o = t(Ri)[cn]({
            type: "parallelAxis",
            _selectController: null,
            render: function (t, r, o, s) {
                if (!e(t, r, s) && (this.axisModel = t, this.api = o, this.group[rn](), t.get("show"))) {
                    var l = r[ve](g, t.get("parallelIndex"))[Ni], c = t.getAreaSelectStyle(), u = c.width, h = l.getAxisLayout(t.axis.dim), d = i[On]({
                        strokeContainThreshold: u,
                        axisLineSilent: !(u > 0)
                    }, h), f = new n(t, d);
                    i.each(a, f.add, f);
                    var p = f.getGroup();
                    this.group.add(p), this._buildSelectController(p, c, t, o)
                }
            },
            _buildSelectController: function (t, e, n, a) {
                var o = n.axis, s = this._selectController;
                s || (s = this._selectController = new r("line", a.getZr(), e), s.on(Qe, i.bind(this._onSelected, this))), s[W](t);
                var l = i.map(n.activeIntervals, function (t) {
                    return [o[te](t[0], !0), o[te](t[1], !0)]
                });
                s[Gn](l)
            },
            _onSelected: function (t) {
                var e = this.axisModel, n = e.axis, r = i.map(t, function (t) {
                    return [n.coordToData(t[0], !0), n.coordToData(t[1], !0)]
                });
                this.api[Rn]({type: "axisAreaSelect", parallelAxisId: e.id, intervals: r})
            },
            remove: function () {
                this._selectController && this._selectController.disable()
            },
            dispose: function () {
                this._selectController && (this._selectController[kn](), this._selectController = null)
            }
        });
        return o
    }),e("echarts/component/visualMap/VisualMapView", [gr, Ri, vr, vi, Ie, me, "../../visual/VisualMapping"], function (t) {
        var e = t(Ri), i = t(vr), n = t(vi), r = t(Ie), a = t(me), o = t("../../visual/VisualMapping");
        return e[cn]({
            type: "visualMap",
            autoPositionValues: {left: 1, right: 1, top: 1, bottom: 1},
            init: function (t, e) {
                this[j] = t, this.api = e, this.visualMapModel, this._updatableShapes = {}
            },
            render: function (t) {
                return this.visualMapModel = t, t.get("show") === !1 ? void this.group[rn]() : void this.doRender.apply(this, arguments)
            },
            renderBackground: function (t) {
                var e = this.visualMapModel, i = r.normalizeCssArray(e.get(Yi) || 0), a = t[Qi]();
                t.add(new n.Rect({
                    z2: -1,
                    silent: !0,
                    shape: {x: a.x - i[3], y: a.y - i[0], width: a.width + i[3] + i[1], height: a[Fn] + i[0] + i[2]},
                    style: {fill: e.get(jn), stroke: e.get(Ge), lineWidth: e.get("borderWidth")}
                }))
            },
            getControllerVisual: function (t, e, n) {
                function r(t) {
                    return c[t]
                }

                function a(t, e) {
                    c[t] = e
                }

                n = n || {};
                var s = n.forceState, l = this.visualMapModel, c = {};
                if (e === _e && (c[_e] = l.get("itemSymbol")), "color" === e) {
                    var u = l.get("contentColor");
                    c.color = u
                }
                var h = l.controllerVisuals[s || l.getValueState(t)], d = o.prepareVisualTypes(h);
                return i.each(d, function (i) {
                    var s = h[i];
                    n.convertOpacityToAlpha && i === Hi && (i = "colorAlpha", s = h.__alphaForOpacity), o.dependsOn(i, e) && s && s.applyVisual(t, r, a)
                }), c[e]
            },
            positionGroup: function (t) {
                var e = this.visualMapModel, i = this.api;
                a.positionGroup(t, e[Ji](), {width: i[Kn](), height: i[Yn]()})
            },
            doRender: i.noop
        })
    }),e("echarts/chart/graph/simpleLayoutEdge", [gr, ar], function (t) {
        var e = t(ar);
        return function (t) {
            t.eachEdge(function (t) {
                var i = t[Jn]().get("lineStyle.normal.curveness") || 0, n = e.clone(t.node1[H]()), r = e.clone(t.node2[H]()), a = [n, r];
                i > 0 && a.push([(n[0] + r[0]) / 2 - (n[1] - r[1]) * i, (n[1] + r[1]) / 2 - (r[0] - n[0]) * i]), t[$](a)
            })
        }
    }),e("echarts/component/visualMap/PiecewiseView", [gr, "./VisualMapView", vr, vi, E, me, "./helper"], function (t) {
        var e = t("./VisualMapView"), i = t(vr), n = t(vi), r = t(E), a = t(me), o = t("./helper"), s = e[On]({
            type: "visualMap.piecewise",
            doRender: function () {
                function t(t) {
                    var r = t.piece, a = new n.Group;
                    a.onclick = i.bind(this._onItemClick, this, r), this._enableHoverLink(a, t.indexInModelPieceList);
                    var s = this._getRepresentValue(r);
                    if (this._createItemSymbol(a, s, [0, 0, d[0], d[1]]), p) {
                        var u = this.visualMapModel.getValueState(s);
                        a.add(new n.Text({
                            style: {
                                x: "right" === h ? -o : d[0] + o,
                                y: d[1] / 2,
                                text: r.text,
                                textVerticalAlign: "middle",
                                textAlign: h,
                                textFont: l,
                                fill: c,
                                opacity: "outOfRange" === u ? .5 : 1
                            }
                        }))
                    }
                    e.add(a)
                }

                var e = this.group;
                e[rn]();
                var r = this.visualMapModel, o = r.get("textGap"), s = r.textStyleModel, l = s[tn](), c = s[$i](), h = this._getItemAlign(), d = r.itemSize, f = this._getViewData(), p = !f.endsText, v = !p;
                v && this._renderEndsText(e, f.endsText[0], d), i.each(f.viewPieceList, t, this), v && this._renderEndsText(e, f.endsText[1], d), a.box(r.get(u), e, r.get("itemGap")), this.renderBackground(e), this.positionGroup(e)
            },
            _enableHoverLink: function (t, e) {
                function n(t) {
                    var i = this.visualMapModel;
                    i[Pi].hoverLink && this.api[Rn]({
                        type: t,
                        batch: o.convertDataIndicesToBatch(i.findTargetDataIndices(e))
                    })
                }

                t.on(Cn, i.bind(n, this, "highlight")).on(An, i.bind(n, this, "downplay"))
            },
            _getItemAlign: function () {
                var t = this.visualMapModel, e = t[Pi];
                if (e[u] === f)return o.getItemAlign(t, this.api, t.itemSize);
                var i = e.align;
                return i && "auto" !== i || (i = "left"), i
            },
            _renderEndsText: function (t, e, i) {
                if (e) {
                    var r = new n.Group, a = this.visualMapModel.textStyleModel;
                    r.add(new n.Text({
                        style: {
                            x: i[0] / 2,
                            y: i[1] / 2,
                            textVerticalAlign: "middle",
                            textAlign: "center",
                            text: e,
                            textFont: a[tn](),
                            fill: a[$i]()
                        }
                    })), t.add(r)
                }
            },
            _getViewData: function () {
                var t = this.visualMapModel, e = i.map(t.getPieceList(), function (t, e) {
                    return {piece: t, indexInModelPieceList: e}
                }), n = t.get("text"), r = t.get(u), a = t.get(fe);
                return (r === Ae ? a : !a) ? e[k]() : n && (n = n.slice()[k]()), {viewPieceList: e, endsText: n}
            },
            _getRepresentValue: function (t) {
                var e;
                if (this.visualMapModel.isCategory())e = t.value; else if (null != t.value)e = t.value; else {
                    var i = t[Q] || [];
                    e = (i[0] + i[1]) / 2
                }
                return e
            },
            _createItemSymbol: function (t, e, i) {
                t.add(r[O](this.getControllerVisual(e, _e), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color")))
            },
            _onItemClick: function (t) {
                var e = this.visualMapModel, n = e[Pi], r = i.clone(n[Qe]), a = e.getSelectedMapKey(t);
                "single" === n.selectedMode ? (r[a] = !0, i.each(r, function (t, e) {
                    r[e] = e === a
                })) : r[a] = !r[a], this.api[Rn]({
                    type: "selectDataRange",
                    from: this.uid,
                    visualMapId: this.visualMapModel.id,
                    selected: r
                })
            }
        });
        return s
    }),e("echarts/component/visualMap/PiecewiseModel", [gr, "./VisualMapModel", vr, "../../visual/VisualMapping"], function (t) {
        function e(t, e) {
            var i = t[fe];
            (t[u] === f ? !i : i) && e[k]()
        }

        var i = t("./VisualMapModel"), n = t(vr), r = t("../../visual/VisualMapping"), a = i[On]({
            type: "visualMap.piecewise",
            defaultOption: {
                selected: null,
                align: "auto",
                itemWidth: 20,
                itemHeight: 14,
                itemSymbol: "roundRect",
                pieceList: null,
                categories: null,
                splitNumber: 5,
                selectedMode: "multiple",
                itemGap: 10,
                hoverLink: !0
            },
            doMergeOption: function (t, e) {
                a[Vi](this, "doMergeOption", arguments), this._pieceList = [], this.resetTargetSeries(t, e), this.resetExtent();
                var i = this._mode = this._decideMode();
                o[this._mode].call(this), this._resetSelected(t, e);
                var r = this[Pi][D];
                this.resetVisual(function (t, e) {
                    i === D ? (t.mappingMethod = be, t[D] = n.clone(r)) : (t.mappingMethod = "piecewise", t.pieceList = n.map(this._pieceList, function (t) {
                        var t = n.clone(t);
                        return "inRange" !== e && (t.visual = null), t
                    }))
                })
            },
            _resetSelected: function (t, e) {
                var i = this[Pi], r = this._pieceList, a = (e ? i : t)[Qe] || {};
                if (i[Qe] = a, n.each(r, function (t) {
                        var e = this.getSelectedMapKey(t);
                        e in a || (a[e] = !0)
                    }, this), "single" === i.selectedMode) {
                    var o = !1;
                    n.each(r, function (t) {
                        var e = this.getSelectedMapKey(t);
                        a[e] && (o ? a[e] = !1 : o = !0)
                    }, this)
                }
            },
            getSelectedMapKey: function (t) {
                return this._mode === D ? t.value + "" : t.index + ""
            },
            getPieceList: function () {
                return this._pieceList
            },
            _decideMode: function () {
                var t = this[Pi];
                return t.pieces && t.pieces[zn] > 0 ? "pieces" : this[Pi][D] ? D : S
            },
            setSelected: function (t) {
                this[Pi][Qe] = n.clone(t)
            },
            getValueState: function (t) {
                var e = r.findPieceIndex(t, this._pieceList);
                return null != e && this[Pi][Qe][this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange"
            },
            findTargetDataIndices: function (t) {
                var e = [];
                return this.eachTargetSeries(function (i) {
                    var n = [], a = i[ur]();
                    a.each(this.getDataDimension(a), function (e, i) {
                        var a = r.findPieceIndex(e, this._pieceList);
                        a === t && n.push(i)
                    }, !0, this), e.push({seriesId: i.id, dataIndices: n})
                }, this), e
            }
        }), o = {
            splitNumber: function () {
                var t = this[Pi], e = t.precision, i = this[we](), n = t[S];
                n = Math.max(parseInt(n, 10), 1), t[S] = n;
                for (var r = (i[1] - i[0]) / n; +r[Di](e) !== r && 5 > e;)e++;
                t.precision = e, r = +r[Di](e);
                for (var a = 0, o = i[0]; n > a; a++, o += r) {
                    var s = a === n - 1 ? i[1] : o + r;
                    this._pieceList.push({text: this.formatValueText([o, s]), index: a, interval: [o, s]})
                }
            }, categories: function () {
                var t = this[Pi];
                n.each(t[D], function (t) {
                    this._pieceList.push({text: this.formatValueText(t, !0), value: t})
                }, this), e(t, this._pieceList)
            }, pieces: function () {
                var t = this[Pi];
                n.each(t.pieces, function (t, e) {
                    n[Bn](t) || (t = {value: t});
                    var i, a = {text: "", index: e};
                    if (null != t.label && (a.text = t.label, i = !0), t.hasOwnProperty("value"))a.value = t.value, i || (a.text = this.formatValueText(a.value)); else {
                        var o = t.min, s = t.max;
                        null == o && (o = -1 / 0), null == s && (s = 1 / 0), o === s && (a.value = o), a[Q] = [o, s], i || (a.text = this.formatValueText([o, s]))
                    }
                    a.visual = r.retrieveVisuals(t), this._pieceList.push(a)
                }, this), e(t, this._pieceList)
            }
        };
        return a
    }),e("echarts/chart/graph/circularLayoutHelper", [gr, ar], function (t) {
        var e = t(ar);
        return function (t) {
            var i = t[Ni];
            if (!i || "view" === i.type) {
                var n = i[Qi](), r = t[ur](), a = r.graph, o = 0, s = r.getSum("value"), l = 2 * Math.PI / (s || r.count()), c = n.width / 2 + n.x, u = n[Fn] / 2 + n.y, h = Math.min(n.width, n[Fn]) / 2;
                a.eachNode(function (t) {
                    var e = t.getValue("value");
                    o += l * (s ? e : 2) / 2, t[$]([h * Math.cos(o) + c, h * Math.sin(o) + u]), o += l * (s ? e : 2) / 2
                }), a.eachEdge(function (t) {
                    var i, n = t[Jn]().get("lineStyle.normal.curveness") || 0, r = e.clone(t.node1[H]()), a = e.clone(t.node2[H]()), o = (r[0] + a[0]) / 2, s = (r[1] + a[1]) / 2;
                    n > 0 && (n *= 3, i = [c * n + o * (1 - n), u * n + s * (1 - n)]), t[$]([r, a, i])
                })
            }
        }
    }),e("echarts/chart/graph/forceHelper", [gr, ar], function (t) {
        var e = t(ar), i = e.scaleAndAdd;
        return function (t, n, r) {
            for (var a = r.rect, o = a.width, s = a[Fn], l = [a.x + o / 2, a.y + s / 2], c = null == r.gravity ? .1 : r.gravity, u = 0; u < t[zn]; u++) {
                var h = t[u];
                h.p || (h.p = e[Zn](o * (Math.random() - .5) + l[0], s * (Math.random() - .5) + l[1])), h.pp = e.clone(h.p), h.edges = null
            }
            var d = .6;
            return {
                warmUp: function () {
                    d = .5
                }, setFixed: function (e) {
                    t[e].fixed = !0
                }, setUnfixed: function (e) {
                    t[e].fixed = !1
                }, step: function (r) {
                    for (var a = [], o = t[zn], s = 0; s < n[zn]; s++) {
                        var u = n[s], h = u.n1, f = u.n2;
                        e.sub(a, f.p, h.p);
                        var p = e.len(a) - u.d, v = f.w / (h.w + f.w);
                        e[gi](a, a), !h.fixed && i(h.p, h.p, a, v * p * d), !f.fixed && i(f.p, f.p, a, -(1 - v) * p * d)
                    }
                    for (var s = 0; o > s; s++) {
                        var g = t[s];
                        g.fixed || (e.sub(a, l, g.p), e.scaleAndAdd(g.p, g.p, a, c * d))
                    }
                    for (var s = 0; o > s; s++)for (var h = t[s], m = s + 1; o > m; m++) {
                        var f = t[m];
                        e.sub(a, f.p, h.p);
                        var p = e.len(a);
                        0 === p && (e.set(a, Math.random() - .5, Math.random() - .5), p = 1);
                        var y = (h.rep + f.rep) / p / p;
                        !h.fixed && i(h.pp, h.pp, a, y), !f.fixed && i(f.pp, f.pp, a, -y)
                    }
                    for (var x = [], s = 0; o > s; s++) {
                        var g = t[s];
                        g.fixed || (e.sub(x, g.p, g.pp), e.scaleAndAdd(g.p, g.p, x, d), e.copy(g.pp, g.p))
                    }
                    d = .992 * d, r && r(t, n, .01 > d)
                }
            }
        }
    }),e("zrender", ["zrender/zrender"], function (t) {
        return t
    }),e("echarts", ["echarts/echarts"], function (t) {
        return t
    });
    var mr = t("echarts");
    return mr.graphic = t("echarts/util/graphic"), mr.number = t("echarts/util/number"), mr.format = t("echarts/util/format"), t("echarts/chart/bar"), t("echarts/chart/line"), t("echarts/chart/pie"), t("echarts/chart/scatter"), t("echarts/chart/candlestick"), t("echarts/chart/radar"), t("echarts/chart/heatmap"), t("echarts/chart/treemap"), t("echarts/chart/map"), t("echarts/chart/lines"), t("echarts/chart/graph"), t("echarts/chart/boxplot"), t("echarts/chart/parallel"), t("echarts/chart/gauge"), t("echarts/chart/funnel"), t("echarts/chart/sankey"), t("echarts/chart/effectScatter"), t("echarts/component/grid"), t("echarts/component/polar"), t("echarts/component/geo"), t("echarts/component/title"), t("echarts/component/legend"), t("echarts/component/tooltip"), t("echarts/component/markPoint"), t("echarts/component/markLine"), t("echarts/component/timeline"), t("echarts/component/dataZoom"), t("echarts/component/visualMap"), t("echarts/component/toolbox"), t("zrender/vml/vml"), mr
});